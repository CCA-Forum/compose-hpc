#!/usr/bin/swipl -q -O -t main -s
% -*- prolog -*-, not perl
/**
 * GRAMOLA: Code generator for BRAID intermediate representation grammars
 *   `I'd rather write a program to write programs to write programs
 *    than write a program to write programs.'
 *
 *
 * Input: a grammar specification
 *
 * Output: Python code to create and typecheck expressions of that grammar
 *
 * Usage:
 *   grep '^%%' grammar_def.pl | sed 's/^%%//g' >ir_def.py
 *   swipl -f gramola.pl -t main -q <grammar_def.pl >>ir_def.py
 */

main(_) :-
    format('~n~n# Automatically generated by GRAMOLA.~n'),
    format('#     ### ### #### ### ###~n'),
    format('#     ### DO NOT EDIT! ###~n'),
    format('#     ### ### #### ### ###~n'),
    prompt(_, ''),
    read_term(Docstrings, [variable_names(Varnames), singletons(warning)]),

    format('~n~n## Token definitions~n~n'),
    maplist(tokendef, Varnames),

    format('~n~n## Constructor definitions~n~n'),
    copy_term(Docstrings, Grammar),
    maplist(docref, Varnames),
    maplist(unify, Grammar),
    maplist(rhs_of, Grammar, GrammarRHS),
    maplist(constructor, GrammarRHS, Docstrings).

rhs_of(_=B, B).
unify(A=B) :- A = B.
docref(Name=Var) :-
    atom_concat('\\c ', Name, Ref),
    downcase_atom(Ref, Var).
tokendef(Name=_) :-
    downcase_atom(Name, Token),
    (	atom_concat(Token1, '_', Token) % remove trailing underscore from rhs
    ;	Token1 = Token ),
    format('~a = \'~a\'~n', [Token, Token1]).

% helper for alternatives
validation1(Arg, Var, N) :- !,
    format('    el'),
    (	Arg = (A|B)
    ->	type_check(A, Var, N),
	validation1(B, Var, N)
    ;	type_check(Arg, Var, N)
    ).

%% validation/2: output validation code for a given grammar node
% alternatives
validation(Arg, Var, N) :- !,
    %A =.. [Type|Args],
    format('    '),
    (	Arg = (A|B)
    ->	type_check(A, Var, N),
	validation1(B, Var, N)
    ;	type_check(Arg, Var, N)
    ),
    format('    else: raise Exception(\'Grammar Error in argument \'+repr(~a))~n', [Var]).

% atom
type_check(A, Var, _) :-
    atom(A),
    format('if (~a == ~a):~n', [Var, A]),
    format('        pass~n').

% list
type_check([A], Var, _) :-
    A =.. [Type|_],
    format('if instanceof(~a, list):~n', [Var]),
    format('        for ~a in ~a:~n', [Type, Var]),
    format('            is_~a(~a)~n', [Type, Type]).

% tuple
type_check(A, Var, N) :-
    A =.. [Type|_],
    format('if (~a[~d] == ~a):~n', [Var, N, Type]),
    format('        is_~a(~a)~n', [Type, Var]).

%% validations/2
% iterate over all elements of a tuple and print validation code
validations(Args, Var) :-
    validations(Args, Var, 0).
validations([], _, _).
validations([Arg|Args], Var, I) :-
    format(atom(Var1), '~a[~d]', [Var, I]),
    validation(Arg, Var1, 0),
    %check_arg(Arg, Var, I),
    I1 is I+1,
    validations(Args, Var, I1).



%% constructor/2: output a constructor for a given grammar node
constructor(Atom, _) :-
    atom(Atom),
    format('def ~a():~n    return ~a~n', [Atom, Atom]).

constructor([], _).
constructor(_A|_B, Doc) :- format('# skipping ~w~n', [Doc]).

constructor(Term, Docstring) :-
    ground(Term), % sanity check
    Term =.. [Type|[Arg|Args]],
    pretty(Docstring, Doc),
    format('def ~a(*args):~n', [Type]),
    format('    """~n'),
    format('    Construct an ~a. Valid arguments are ~n    ~w~n', [Type, Doc]),
    format('    """~n'),
    validations([Arg|Args], 'args'),
    format('    return tuple(args)~n~n').

constructor(Error, _) :-
    format('**ERROR: In ~w~n', [Error]),
    halt(1).

% pretty-print grammar for the docstring
pretty(Atom, Atom) :- atom(Atom).
pretty([List], PrettyList1) :-
    pretty(List, PrettyList),
    format(atom(PrettyList1), '[~w]', [PrettyList]).
pretty(A|B, PrettyTerm) :-
    pretty(A, PrettyA),
    pretty(B, PrettyB),
    format(atom(PrettyTerm), '~w~n    |~w', [PrettyA, PrettyB]).
pretty(A=B, Rule) :-
    B =.. [_|Args],
    maplist(pretty, Args, PrettyArgs),
    atomic_list_concat([A|PrettyArgs], ', ', PrettyArgs1),
    format(atom(Rule), '(~w)', [PrettyArgs1]).
