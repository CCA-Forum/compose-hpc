#!/usr/bin/swipl -q -O -t main -s
% -*- prolog -*-, not perl
/**
 * GRAMOLA: Code generator for BRAID intermediate representation grammars
 *   `I'd rather write a program to write programs to write programs
 *    than write a program to write programs.'
 *
 *
 * Input: a grammar specification
 *
 * Output: Python code to create and typecheck expressions of that grammar
 *
 * Usage:
 *   egrep '^%[^%]' $< | sed -e 's/^% %%/##/g' -e 's/^%//g' >$@; \
 *   swipl -f gramola.pl -t main -q <grammar_def.pl >>ir_def.py
 */

:- use_module(library(ordsets)).

main(_) :-
    guitracer,
    format('~n~n# Automatically generated by GRAMOLA.~n'),
    format('#     ### ### #### ### ###~n'),
    format('#     ### DO NOT EDIT! ###~n'),
    format('#     ### ### #### ### ###~n'),
    prompt(_, ''),
    read_term(Docstrings, [variable_names(Varnames), singletons(warning)]),
    copy_term(Docstrings, Grammar),

    format('~n~n## Token definitions~n~n'),
    copy_term(Docstrings, G),
    gather_tokens(G, T1),
    ord_union(T1, [], Tokens),
    maplist(tokendef, Tokens), !,

    format('~n~n## Constructor definitions~n~n'),
    maplist(docref, Varnames), !,
    % fixme use try catch instead
    (	maplist(unify, Grammar)
    ;	format(user_error, '**ERROR: did you use the same symbol twice on the LHS?~n', []),
	fail), !,
    maplist(rhs_of, Grammar, GrammarRHS), !,
    maplist(constructor, GrammarRHS, Docstrings).

main(_) :-
    format(user_error, 'Internal error. Please complain to <adrian@llnl.gov>.~n', []).

python_reserved_word(A) :-
    memberchk(A, ['False','True','None','NotImplemented','Ellipsis',
		   and,as,assert,break,class,continue,def,del,elif,
		   else,except,exec,finally,for,from,global,if,import,
		   in,is,lambda,not,or,pass,print,raise,return,try,
		   while,with,yield]).

safe_atom(Atom, Safe) :-
    (	python_reserved_word(Atom)
    ->	atom_concat(Atom, '_', Safe)
    ;	Atom = Safe).

rhs_of(_=B, B).
unify(A=B) :- A = B, !.
unify(Fail) :- format(user_error, '**Failed in rule `~w\'~n', [Fail]), fail.
docref(Name=Var) :-
    atom_concat('\\c ', Name, Ref),
    downcase_atom(Ref, Var).

% ignore python builtins
tokendef(str).
tokendef(float).
tokendef(int).
tokendef(Token) :-
    safe_atom(Token, TokenS),
    format('~a = \'~a\'~n', [TokenS, Token]).

% recursively collect all functors from the grammar
gather_tokens([], []).
gather_tokens(V, []) :- var(V).
gather_tokens(_=B, Ts) :- gather_tokens(B, Ts).
gather_tokens([A|As], Ts) :-
    gather_tokens(A, TA),
    gather_tokens(As, TAs),
    ord_union(TA, TAs, Ts).
gather_tokens(A|B, Ts) :-
    gather_tokens(A, TAs),
    gather_tokens(B, TBs),
    ord_union(TAs, TBs, Ts).
gather_tokens(A, [A]) :- atom(A).
gather_tokens(A, Ts1) :-
    A =.. [Name|As],
    gather_tokens(As, Ts),
    ord_union([Name], Ts, Ts1).


% helper for alternatives
validation1(Arg, Var, Indent) :- !,
    format('~ael', [Indent]),
    (	Arg = (A|B)
    ->	type_check(A, Var, Indent),
	validation1(B, Var, Indent)
    ;	type_check(Arg, Var, Indent)
    ).

%% validation/2: output validation code for a given grammar node
% alternatives
validation(Arg, Var, Indent) :- !,
    %A =.. [Type|Args],
    format(Indent),
    (	Arg = (A|B)
    ->	type_check(A, Var, Indent),
	validation1(B, Var, Indent)
    ;	type_check(Arg, Var, Indent)
    ),
    format('~aelse: raise Exception(\'Grammar Error in argument \'+repr(~a))~n', [Indent,Var]).

% builtin
type_check(A, Var, Indent) :-
    member(A, [int, str, float]),
    format('if (instanceof(~a, ~a)):~n', [Var, A]),
    format('~a    pass~n', [Indent]).

% atom
type_check(A, Var, Indent) :-
    atom(A),
    safe_atom(A, AS),
    format('if (~a == ~a):~n', [Var, AS]),
    format('~a    pass~n', [Indent]).

% list
type_check([A], Var, Indent) :-
    format('if instanceof(~a, list):~n', [Var]),
    format('~a    for arg in ~a:~n', [Indent, Var]),
    atom_concat(Indent, '        ', Indent1),
    validation(A, 'arg', Indent1).

% alternatives
type_check(A|B, Var, Indent) :-
    type_check(A, Var, Indent),
    validation1(B, Var, Indent).

% tuple
type_check(A, Var, Indent) :-
    A =.. [Type|_],
    safe_atom(Type, TypeS),
    format('if (~a[0] == ~a):~n', [Var, TypeS]),
    format('~a    is_~a(~a)~n', [Indent, Type, Var]).

%% validations/2
% iterate over all elements of a tuple and print validation code
validations(Args, Var) :-
    validations(Args, Var, 0).
validations([], _, _).
validations([Arg|Args], Var, I) :-
    format(atom(Var1), '~a[~d]', [Var, I]),
    validation(Arg, Var1, '    '),
    %check_arg(Arg, Var, I),
    I1 is I+1,
    validations(Args, Var, I1).

%% upcase_atom/2 convert 'abc' to 'Abc'
upcase_atom(A, A1) :-
    atom_chars(A, [C|Cs]),
    char_type(C1, to_upper(C)),
    atom_chars(A1, [C1|Cs]).

%% constructor/2: output a constructor for a given grammar node
constructor([], _).
constructor(_A|_B, Doc)    :- format('# skipping ~w~n', [Doc]).
constructor([_|_], Doc) :- format('# skipping ~w~n', [Doc]).
constructor(Atom, _) :-
    atom(Atom),
    upcase_atom(Atom, Def),
    safe_atom(Def, Def1),
    format('def ~a():~n    return ~a~n', [Def1, Atom]).

constructor(Term, Docstring) :-
    ground(Term),		% sanity check
    Term =.. [Type|[Arg|Args]],
    pretty(Docstring, Doc),
    upcase_atom(Type, Def),
    safe_atom(Def, Def1),
    format('def ~a(*args):~n', [Def1]),
    format('    """~n'),
    format('    Construct a "~a" node. Valid arguments are ~n    ~w~n', [Type, Doc]),
    format('    """~n'),
    validations([Arg|Args], 'args'),
    format('    return tuple(args)~n~n').

constructor(Error, _) :-
    format(user_error, '**ERROR: In ~w~n', [Error]),
    (	ground(Error),
	format(user_error, 'Internal error, spawning debugger.~n', []),
	gtrace
    ;	format(user_error, 'Most probably missing a definition in above term.~n', []),
	format(user_error, 'Look for symbols like `_G123\'.~n', [])
    ),
    halt(1).

% pretty-print grammar for the docstring
pretty(Atom, PrettyAtom) :-
    atom(Atom),
    format(atom(PrettyAtom), '~a()', [Atom]).
pretty([List], PrettyList1) :-
    pretty(List, PrettyList),
    format(atom(PrettyList1), '[~w]', [PrettyList]).
pretty(A|B, PrettyTerm) :-
    pretty(A, PrettyA),
    pretty(B, PrettyB),
    format(atom(PrettyTerm), '~w~n    |~w', [PrettyA, PrettyB]).
pretty(A=B, Rule) :-
    B =.. [_|Args],
    sub_atom(A, 3, _, 0, ShortA),
    maplist(pretty, Args, PrettyArgs),
    atomic_list_concat(PrettyArgs, ', ', PrettyArgs1),
    format(atom(Rule), '(\\c "~a", ~w)', [ShortA, PrettyArgs1]).
pretty(Tuple, Rule) :-
    Tuple =.. [Type|Args],
    maplist(pretty, Args, PrettyArgs),
    atomic_list_concat(PrettyArgs, ', ', PrettyArgs1),
    format(atom(Rule), '(\\c "~a", ~w)', [Type,PrettyArgs1]).
