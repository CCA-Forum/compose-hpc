%% -*- prolog -*-
%%# Pipe this into GRAMOLA
%%# Lines starting with a single '%' will be presereved.
%%# To avoid duplicate doxygen comments, '% %%' will be replaced by '##'
%% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%#!/usr/bin/env python
%# -*- python -*-
% %% @package sidl
%# Grammar for the SIDL intermediate representation (IR).
%# This is NOT a grammar for SIDL, the language.
%#
%# Please report bugs to <adrian@llnl.gov>.
%#
%# \authors <pre>
%#
%# Copyright (c) 2011, Lawrence Livermore National Security, LLC.
%# Produced at the Lawrence Livermore National Laboratory
%# Written by Adrian Prantl <adrian@llnl.gov>.
%#  
%# LLNL-CODE-473891.
%# All rights reserved.
%#  
%# This file is part of BRAID. For details, see 
%# http://compose-hpc.sourceforge.net/. 
%# Please read the COPYRIGHT file for Our Notice and
%# for the BSD License.
%#
%# </pre>

%# Built-in types are [str, int, float]
%# Do not forget to add parentheses around ( A|B )!
%# Prefix an underscore to suppress singleton warning.
[  
  _File = file([Require], [Import], [UserType]),
  Version = version(str | float | int),
  Require = require(ScopedID, Version),
  Import = import(ScopedID, Version),
  Package = package(Name, Version, [UserType]),
  UserType = user_type([(TypeAttr|CustomAttr)], CIPSE),
  CIPSE = ( Class
	  | Interface
	  | Package
	  | Struct
	  | Enum ),
  TypeAttr = type_attribute(final | abstract),
  Name = identifier(str),
  Enum = enum(Name, [Enumerator]),
  Enumerator = enumerator(Name, int),
  Struct = struct(Name, [StructItem]),
  StructItem = struct_item(TypeVoid, Name),
  Class = class(Name, [Extends], [Implements], [Invariant], [Method]),
  Interface = interface(Name, [Extends], [Invariant], [Method]),
  Implements = ( implements(ScopedID)
	       | implements_all(ScopedID)),
  Method = method(TypeVoid, MethodName, [MethodAttr], [Arg], [Except], [From], [Require], [Ensure]),
  MethodName = method_name(Name, Extension),
  Extension = str,
  TypeVoid = ( void | Type ),
  MethodAttr = ( oneway
	       | local
	       | static
	       | abstract
	       | final
	       | nonblocking
	       | copy ),
  From = from(ScopedID),
  Invariant = invariant(Assertion),
  Assertion = assertion(Name, AssertExpr),
  Except = except([ScopedID]),
  Ensure = ensure([ScopedID]),
  Extends = extends([ScopedID]),
  Arg = ( arg([ArgAttr], Mode, TypeVoid, Name)
        | rarg([ArgAttr], Mode, Rarray) ),
  ArgAttr = (copy | [str]),
  CustomAttr = ( custom_attribute(str)
	       | custom_attribute_assoc(str, str)
	       ),
  Mode = (in | out | inout),
  Type = (PrimitiveType | Array | UserType),
  PrimitiveType = primitive_type(
      void|bool|char|int|long|float|double|fcomplex|dcomplex|string|opaque),	  
  Array = array(ScalarType, Dimension, Orientation),
  ScalarType = (PrimitiveType|ScopedID),
  Dimension = int,
  Orientation = (row_major|column_major),
  Rarray = rarray(PrimitiveType, Dimension, Name, Extents),
  Extents = SimpleIntExpression,
  SimpleIntExpression = int, % resolved by the parser?
  AssertExpr = ( ifx_expression(BinOp, AssertExpr, AssertExpr)
	       | prefix_expression(UnOp, AssertExpr)
	       | fn_eval(Name, [Arg])
	       | var_ref(Name)
	       | Name
	       | Literal
	       ),
  BinOp = (log_or|log_and|eq|ne|bit_or|bit_and|bit_xor|lt|gt|lshift|rshift
	  |plus|minus|times|divide|modulo|rem|pow),
  UnOp = ( is|log_not|bit_not ),
  ScopedID = scoped_id([Name], Extension),
  Literal = (int | float | str | pure | result | Complex),
  Complex = complex(float, float)
].