%% -*- prolog -*-
%%# Pipe this into GRAMOLA
%%# Lines starting with a single '%' will be presereved.
%%# To avoid duplicate doxygen comments, '% %%' will be replaced by '##'
%% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%#!/usr/bin/env python
%# -*- python -*-
% %% @package ir
%# Convenience definitions for intermediate representation (IR) nodes.
%#
%# Please report bugs to <adrian@llnl.gov>.
%#
%# \authors <pre>
%#
%# Copyright (c) 2011, Lawrence Livermore National Security, LLC.
%# Produced at the Lawrence Livermore National Laboratory
%# Written by Adrian Prantl <adrian@llnl.gov>.
%#  
%# LLNL-CODE-473891.
%# All rights reserved.
%#  
%# This file is part of BRAID. For details, see 
%# http://compose-hpc.sourceforge.net/. 
%# Please read the COPYRIGHT file for Our Notice and
%# for the BSD License.
%#
%# </pre>
%#
%#
%# <h2>Grammar definition</h2>
%#
%%# Built-in types are [str, int, float]
%%# Do not forget to add parentheses around ( A|B )!
%%# In alternatives, atoms must come first: atom|complex(something).
%%# Prefix an underscore to suppress singleton warnings.
[
  Stmt = stmt(Do_while | While | break | return(Expr) | If | goto(Expr) | Expr),
  Do_while = do_while(Body, Expr),
  While = while(Expr, Body),
  If = if(Expr, Body),
  Body = [Stmt],
  Expr = ( Literal
	 | call(Expr, [Expr])
         | var_decl(Identifier)
         | var_defn(Identifier)
	 | var_ref(Identifier)
	 | get_struct_item(Struct, Identifier, Struct_item)
	 | set_struct_item(Struct, Identifier, Struct_item, Expr)
         | assignment(VarRefExpr)
	 | infix_expr(Bin_op, Expr, Expr)
	 | prefix_expr(Un_op, Expr)
	 ),
  Bin_op = (log_or|log_and|eq|ne|bit_or|bit_and|bit_xor|lt|gt|lshift|rshift
	   |plus|minus|times|divide|modulo|rem|pow),
  Un_op = ( is|log_not|bit_not ),
  Literal = (int | float | str | pure | result | Complex | true | false),
  Complex = complex(float, float),
  Struct = struct(Identifier, [Struct_item]),
  Struct_item = struct_item(Type, Identifier),
  Enum = struct(Identifier, [Enum_item]),
  Enum_item = enum_item(Identifier),
  VarRefExpr = (Identifier | pointer(VarRefExpr) | deref(VarRefExpr)),
  Fn_decl = fn_decl(Type, Identifier, [Arg]),
  Fn_defn = fn_defn(Type, Identifier, [Arg], [Stmt]),
  Arg = arg([Attr], Mode, Type, Identifier),
  Attr = [],
  Mode = (in | out | inout),
  Type = (primitive_type(void | int) | User_type),
  User_type = [],
  Identifier = identifier(str)
].
%def Plus(A, B):
%    """
%    same as Infix_expr(ir.plus, A, B)
%    """
%    return Infix_expr(plus, A, B)
%