From a83f19cf8805455f6c08ed1acb57c5a096054711 Mon Sep 17 00:00:00 2001
From: Adrian Prantl <adrian@llnl.gov>
Date: Wed, 25 Jul 2012 11:37:45 -0700
Subject: [PATCH 06/11] split chpl_gen_main into init and shutdown

---
 compiler/AST/symbol.cpp                    |    2 +
 compiler/include/symbol.h                  |    2 +
 compiler/passes/buildDefaultFunctions.cpp  |   42 +++++++++++++++++++++++++++-
 compiler/passes/codegen.cpp                |    9 +++++-
 compiler/passes/insertLineNumbers.cpp      |    2 +
 compiler/passes/parallel.cpp               |   34 +++++++++++++++++++++-
 compiler/resolution/callDestructors.cpp    |    2 +
 compiler/resolution/functionResolution.cpp |    8 +++--
 runtime/src/chplinit.c                     |   16 ++++++++++
 9 files changed, 110 insertions(+), 7 deletions(-)

diff --git a/compiler/AST/symbol.cpp b/compiler/AST/symbol.cpp
index 91a0092..24b97b8 100644
--- a/compiler/AST/symbol.cpp
+++ b/compiler/AST/symbol.cpp
@@ -26,6 +26,8 @@
 // The function that represents the compiler-generated entry point
 //
 FnSymbol *chpl_gen_main = NULL;
+FnSymbol *chpl_gen_init = NULL;
+FnSymbol *chpl_gen_shutdown = NULL;
 
 ModuleSymbol* rootModule = NULL;
 ModuleSymbol* theProgram = NULL;
diff --git a/compiler/include/symbol.h b/compiler/include/symbol.h
index aa459ae..103d6c2 100644
--- a/compiler/include/symbol.h
+++ b/compiler/include/symbol.h
@@ -16,6 +16,8 @@
 // The function that represents the compiler-generated entry point
 //
 extern FnSymbol* chpl_gen_main;
+extern FnSymbol* chpl_gen_init;
+extern FnSymbol* chpl_gen_shutdown;
 
 class SymExpr;
 class DefExpr;
diff --git a/compiler/passes/buildDefaultFunctions.cpp b/compiler/passes/buildDefaultFunctions.cpp
index 78d4430..fd4e065 100644
--- a/compiler/passes/buildDefaultFunctions.cpp
+++ b/compiler/passes/buildDefaultFunctions.cpp
@@ -299,6 +299,44 @@ static void build_chpl_entry_points(void) {
   chpl_user_main->cname = "chpl_user_main";
 
   //
+  // global init function
+  //
+  chpl_gen_init = new FnSymbol("chpl_gen_init");
+  chpl_gen_init->cname = "chpl_gen_init";
+  chpl_gen_init->retType = dtVoid;
+  chpl_gen_init->addFlag(FLAG_EXPORT); 
+  chpl_gen_init->addFlag(FLAG_TEMP);
+  mainModule->block->insertAtTail(new DefExpr(chpl_gen_init));
+  normalize(chpl_gen_init);
+
+  // We have to initialize the main module explicitly.
+  // It will initialize all the modules it uses, recursively.
+  chpl_gen_init->insertAtHead(new CallExpr(mainModule->initFn));
+
+  VarSymbol* endCount = newTemp("_endCount");
+  chpl_gen_init->insertAtHead(new CallExpr("chpl_startTrackingMemory"));
+  chpl_gen_init->insertAtHead(new CallExpr(PRIM_SET_END_COUNT, endCount));
+  chpl_gen_init->insertAtHead(new CallExpr(PRIM_MOVE, endCount, new CallExpr("_endCountAlloc")));
+  chpl_gen_init->insertAtHead(new DefExpr(endCount));
+
+  //
+  // global shutdown function
+  //
+  chpl_gen_shutdown = new FnSymbol("chpl_gen_shutdown");
+  chpl_gen_shutdown->cname = "chpl_gen_shutdown";
+  chpl_gen_shutdown->retType = dtVoid;
+  chpl_gen_shutdown->addFlag(FLAG_EXPORT);
+  chpl_gen_shutdown->addFlag(FLAG_TEMP);
+  mainModule->block->insertAtTail(new DefExpr(chpl_gen_shutdown));
+  normalize(chpl_gen_shutdown);
+
+  endCount = newTemp("_endCount");
+  chpl_gen_shutdown->insertAtHead(new CallExpr(PRIM_MOVE, endCount, new CallExpr(PRIM_GET_END_COUNT)));
+  chpl_gen_shutdown->insertAtHead(new DefExpr(endCount));
+  chpl_gen_shutdown->insertBeforeReturn(new CallExpr("_waitEndCount"));
+  chpl_gen_shutdown->insertBeforeReturn(new CallExpr("_endCountFree", endCount));
+
+  //
   // chpl_gen_main is the entry point for the compiler-generated cdoe.
   // It accounts for the initialization and memory tracking of the
   // code
@@ -310,9 +348,10 @@ static void build_chpl_entry_points(void) {
   chpl_gen_main->addFlag(FLAG_TEMP);
   mainModule->block->insertAtTail(new DefExpr(chpl_gen_main));
   normalize(chpl_gen_main);
+  chpl_gen_main->insertAtHead(new CallExpr("chpl_gen_shutdown"));
 
   if (!fLibraryCompile) {
-    SET_LINENO(chpl_gen_main);
+    SET_LINENO(chpl_gen_init);
     chpl_gen_main->insertAtHead(new CallExpr("main"));
   }
 
@@ -329,6 +368,7 @@ static void build_chpl_entry_points(void) {
     chpl_gen_main->insertBeforeReturn(new CallExpr("_waitEndCount"));
     //chpl_gen_main->insertBeforeReturn(new CallExpr("_endCountFree", endCount));
   }
+  chpl_gen_main->insertAtHead(new CallExpr("chpl_gen_init"));
 }
 
 static void build_record_equality_function(ClassType* ct) {
diff --git a/compiler/passes/codegen.cpp b/compiler/passes/codegen.cpp
index 10b11c5..032c28a 100644
--- a/compiler/passes/codegen.cpp
+++ b/compiler/passes/codegen.cpp
@@ -107,7 +107,14 @@ static void legalizeName(Symbol* sym) {
   }
 
   // Add chpl_ to operator names.
-  if ((sym->cname[0] == '_' && (sym->cname[1] == '_' || (sym->cname[1] >= 'A' && sym->cname[1] <= 'Z')))) {
+  // hilde sez:  This is very kludgy.  What do we really mean?
+  if ((!strncmp("chpl_", sym->cname, 5) && 
+       (strcmp("chpl_gen_main", sym->cname) &&
+	strcmp("chpl_gen_init", sym->cname) &&
+	strcmp("chpl_gen_shutdown", sym->cname) &&
+	strcmp("chpl_user_main", sym->cname)) 
+       && sym->cname[5] != '_') ||
+      (sym->cname[0] == '_' && (sym->cname[1] == '_' || (sym->cname[1] >= 'A' && sym->cname[1] <= 'Z')))) {
     sym->cname = astr("chpl__", sym->cname);
   }
 }
diff --git a/compiler/passes/insertLineNumbers.cpp b/compiler/passes/insertLineNumbers.cpp
index 27eb7c1..beb051e 100644
--- a/compiler/passes/insertLineNumbers.cpp
+++ b/compiler/passes/insertLineNumbers.cpp
@@ -88,6 +88,8 @@ insertLineNumber(CallExpr* call) {
   } else if (!strcmp(fn->name, "chpl__heapAllocateGlobals") ||
              !strcmp(fn->name, "chpl__initModuleGuards") ||
              !strcmp(fn->name, "chpl_gen_main") ||
+             !strcmp(fn->name, "chpl_gen_init") ||
+             !strcmp(fn->name, "chpl_gen_shutdown") ||
              ((mod->modTag == MOD_USER || mod->modTag == MOD_MAIN) && 
               !fn->hasFlag(FLAG_TEMP) && !fn->hasFlag(FLAG_INLINE)) ||
              (developer && strcmp(fn->name, "halt"))) {
diff --git a/compiler/passes/parallel.cpp b/compiler/passes/parallel.cpp
index 8428f69..efe4a4c 100644
--- a/compiler/passes/parallel.cpp
+++ b/compiler/passes/parallel.cpp
@@ -193,18 +193,44 @@ static void create_block_fn_wrapper(CallExpr* fcall, ClassType* ctype, VarSymbol
   normalize(wrap_fn);
 }
 
-
 static void
 insertEndCount(FnSymbol* fn,
                Type* endCountType,
                Vec<FnSymbol*>& queue,
                Map<FnSymbol*,Symbol*>& endCountMap) {
   if (fn == chpl_gen_main) {
+    // Create a handle for the global end count
+    VarSymbol* var = newTemp("_endCount_global", endCountType);
+    VarSymbol* ref = newTemp("_endCount_ref", endCountType->getRefType());
+    fn->insertAtHead(new CallExpr(PRIM_MOVE, ref, new CallExpr(PRIM_ADDR_OF, var)));
+    fn->insertAtHead(new DefExpr(var));
+    fn->insertAtHead(new DefExpr(ref));
+    endCountMap.put(fn, ref);
+    queue.add(fn);
+
+  } else if (fn == chpl_gen_init) {
+    // expects a reference to the global end count
+    ArgSymbol* arg = new ArgSymbol(INTENT_OUT, "_endCount", endCountType->getRefType());
+    fn->insertFormalAtTail(arg);
+    VarSymbol* var = newTemp("_endCount", endCountType);
+    fn->insertAtHead(new DefExpr(var));
+    fn->insertBeforeReturn(new CallExpr(PRIM_MOVE, arg, var));
+    endCountMap.put(fn, var);
+    queue.add(fn);
+
+  } else if (fn == chpl_gen_shutdown) {
+    // expects a reference to the global end count
+    ArgSymbol* arg = new ArgSymbol(INTENT_BLANK, "_endCount", endCountType->getRefType());
+    fn->insertFormalAtTail(arg);
     VarSymbol* var = newTemp("_endCount", endCountType);
+    fn->insertBeforeReturn(new CallExpr(PRIM_MOVE, arg, var));
+    fn->insertAtHead(new CallExpr(PRIM_MOVE, var, new CallExpr(PRIM_DEREF, arg)));
     fn->insertAtHead(new DefExpr(var));
     endCountMap.put(fn, var);
     queue.add(fn);
+
   } else {
+    // all other functions
     ArgSymbol* arg = new ArgSymbol(INTENT_BLANK, "_endCount", endCountType);
     fn->insertFormalAtTail(arg);
     VarSymbol* var = newTemp("_endCount", endCountType);
@@ -861,7 +887,11 @@ parallel(void) {
       FnSymbol* pfn = call->getFunction();
       if (!endCountMap.get(pfn))
         insertEndCount(pfn, endCountType, queue, endCountMap);
-      call->insertAtTail(endCountMap.get(pfn));
+
+      if (fn == chpl_gen_main)
+	call->insertAtTail(new CallExpr(PRIM_DEREF, endCountMap.get(pfn)));
+      else
+	call->insertAtTail(endCountMap.get(pfn));
     }
   }
 
diff --git a/compiler/resolution/callDestructors.cpp b/compiler/resolution/callDestructors.cpp
index e112d78..18d8f86 100644
--- a/compiler/resolution/callDestructors.cpp
+++ b/compiler/resolution/callDestructors.cpp
@@ -347,6 +347,8 @@ static void insertGlobalAutoDestroyCalls() {
   if( ! fNoInternalModules ) {
     chpl_gen_main->defPoint->insertBefore(new DefExpr(fn));
     chpl_gen_main->insertBeforeReturnAfterLabel(new CallExpr(fn));
+    chpl_gen_shutdown->defPoint->insertBefore(new DefExpr(fn));
+    chpl_gen_shutdown->insertBeforeReturnAfterLabel(new CallExpr(fn));
   }
   forv_Vec(DefExpr, def, gDefExprs) {
     if (isModuleSymbol(def->parentSymbol))
diff --git a/compiler/resolution/functionResolution.cpp b/compiler/resolution/functionResolution.cpp
index cc6ff9d..ce8f19d 100644
--- a/compiler/resolution/functionResolution.cpp
+++ b/compiler/resolution/functionResolution.cpp
@@ -255,7 +255,7 @@ resolveUninsertedCall(Type* type, CallExpr* call) {
     else
       type->symbol->defPoint->insertBefore(call);
   } else
-    chpl_gen_main->insertAtHead(call);
+    chpl_gen_init->insertAtHead(call);
   resolveCall(call);
   call->remove();
   return call->isResolved();
@@ -290,7 +290,7 @@ static void
 resolveAutoCopy(Type* type) {
   SET_LINENO(type->symbol);
   Symbol* tmp = newTemp(type);
-  chpl_gen_main->insertAtHead(new DefExpr(tmp));
+  chpl_gen_init->insertAtHead(new DefExpr(tmp));
   CallExpr* call = new CallExpr("chpl__autoCopy", tmp);
   FnSymbol* fn = resolveUninsertedCall(type, call);
   resolveFns(fn);
@@ -303,7 +303,7 @@ static void
 resolveAutoDestroy(Type* type) {
   SET_LINENO(type->symbol);
   Symbol* tmp = newTemp(type);
-  chpl_gen_main->insertAtHead(new DefExpr(tmp));
+  chpl_gen_shutdown->insertAtHead(new DefExpr(tmp));
   CallExpr* call = new CallExpr("chpl__autoDestroy", tmp);
   FnSymbol* fn = resolveUninsertedCall(type, call);
   resolveFns(fn);
@@ -5037,6 +5037,8 @@ resolve() {
   resolveUses(mainModule);
 
   resolveFns(chpl_gen_main);
+  resolveFns(chpl_gen_init);
+  resolveFns(chpl_gen_shutdown);
   USR_STOP();
 
   resolveExports();
diff --git a/runtime/src/chplinit.c b/runtime/src/chplinit.c
index f533f21..ee66c18 100644
--- a/runtime/src/chplinit.c
+++ b/runtime/src/chplinit.c
@@ -139,6 +139,17 @@ void chpl_init(int argc, char* argv[]) {
 }
 
 /**
+ * Global variable to hold the global endCount for Chapel libraries.
+ * It is used by chpl_library_[init|shutdown] and needs to be passed to
+ * every user function that uses parallel constructs (I think).
+ */
+struct wide_endCount_t { int locale; void* addr; };
+struct wide_endCount_t chpl_endCount_global = {0,NULL};
+struct wide_endCount_t chpl_wide_endCount_global = {0,&chpl_endCount_global};
+extern void chpl_gen_init(void*);
+extern void chpl_gen_shutdown(void*);
+
+/**
  * This acts as a replacement to be used in chpl_task_callMain() for
  * Chapel libraries. It is automatically called by
  * chpl_init_library().
@@ -159,6 +170,10 @@ static void chpl_library_init(void) {
   //
   CHPL_TASK_STD_MODULES_INITIALIZED();
 
+  // This code is generated into chpl_gen_main for non-libraries
+  chpl_wide_endCount_global.locale = chpl_localeID;
+  chpl_endCount_global.locale = chpl_localeID;
+  chpl_gen_init(&chpl_wide_endCount_global);
 }
 
 /**
@@ -166,6 +181,7 @@ static void chpl_library_init(void) {
  */
 static void chpl_library_shutdown(void) {
   chpl_msg(2, "[locale = 0] Shutting down Chapel runtime.\n");
+  chpl_gen_shutdown(&chpl_wide_endCount_global);
   chpl_exit_all(0);
 }
 
-- 
1.7.0.4

