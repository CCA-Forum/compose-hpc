
use vect;;

use sidl;
// DO-NOT-DELETE splicer.begin(vect.Impl)

// *********************************************************************
// *********************************************************************
// IMPLEMENTATION NOTICE
//
// Right now this is a 1-1 port of the C++ testcase.
// Somebody ought to rewrite it into more idiomatic Chapel.
//
// *********************************************************************
// *********************************************************************

// DO-NOT-DELETE splicer.end(vect.Impl)

class vect_vExcept_Impl {
// DO-NOT-DELETE splicer.begin(vect.vExcept.Impl)
// DO-NOT-DELETE splicer.end(vect.vExcept.Impl)

/**
 * builtin method
 */
export vect_vExcept__ctor_impl proc _ctor(in _this: opaque, inout _ex: sidl.sidl_BaseInterface__object) {
    // DO-NOT-DELETE splicer.begin(vect.vExcept._ctor)
    // DO-NOT-DELETE splicer.end(vect.vExcept._ctor)
}


/**
 * builtin method
 */
export vect_vExcept__ctor2_impl proc _ctor2(in _this: opaque, in private_data: opaque, inout _ex: sidl.sidl_BaseInterface__object) {
    // DO-NOT-DELETE splicer.begin(vect.vExcept._ctor2)
    // DO-NOT-DELETE splicer.end(vect.vExcept._ctor2)
}


/**
 * builtin method
 */
export vect_vExcept__dtor_impl proc _dtor(in _this: opaque, inout _ex: sidl.sidl_BaseInterface__object) {
    // DO-NOT-DELETE splicer.begin(vect.vExcept._dtor)
    // DO-NOT-DELETE splicer.end(vect.vExcept._dtor)
}


/**
 * builtin method
 */
export vect_vExcept__load_impl proc _load(in _this: opaque, inout _ex: sidl.sidl_BaseInterface__object) {
    // DO-NOT-DELETE splicer.begin(vect.vExcept._load)
    // DO-NOT-DELETE splicer.end(vect.vExcept._load)
}

} // class vect_vExcept_Impl


class vect_vDivByZeroExcept_Impl {
// DO-NOT-DELETE splicer.begin(vect.vDivByZeroExcept.Impl)
// DO-NOT-DELETE splicer.end(vect.vDivByZeroExcept.Impl)

/**
 * builtin method
 */
export vect_vDivByZeroExcept__ctor_impl proc _ctor(in _this: opaque, inout _ex: sidl.sidl_BaseInterface__object) {
    // DO-NOT-DELETE splicer.begin(vect.vDivByZeroExcept._ctor)
    // DO-NOT-DELETE splicer.end(vect.vDivByZeroExcept._ctor)
}


/**
 * builtin method
 */
export vect_vDivByZeroExcept__ctor2_impl proc _ctor2(in _this: opaque, in private_data: opaque, inout _ex: sidl.sidl_BaseInterface__object) {
    // DO-NOT-DELETE splicer.begin(vect.vDivByZeroExcept._ctor2)
    // DO-NOT-DELETE splicer.end(vect.vDivByZeroExcept._ctor2)
}


/**
 * builtin method
 */
export vect_vDivByZeroExcept__dtor_impl proc _dtor(in _this: opaque, inout _ex: sidl.sidl_BaseInterface__object) {
    // DO-NOT-DELETE splicer.begin(vect.vDivByZeroExcept._dtor)
    // DO-NOT-DELETE splicer.end(vect.vDivByZeroExcept._dtor)
}


/**
 * builtin method
 */
export vect_vDivByZeroExcept__load_impl proc _load(in _this: opaque, inout _ex: sidl.sidl_BaseInterface__object) {
    // DO-NOT-DELETE splicer.begin(vect.vDivByZeroExcept._load)
    // DO-NOT-DELETE splicer.end(vect.vDivByZeroExcept._load)
}

} // class vect_vDivByZeroExcept_Impl


class vect_vNegValExcept_Impl {
// DO-NOT-DELETE splicer.begin(vect.vNegValExcept.Impl)
// DO-NOT-DELETE splicer.end(vect.vNegValExcept.Impl)

/**
 * builtin method
 */
export vect_vNegValExcept__ctor_impl proc _ctor(in _this: opaque, inout _ex: sidl.sidl_BaseInterface__object) {
    // DO-NOT-DELETE splicer.begin(vect.vNegValExcept._ctor)
    // DO-NOT-DELETE splicer.end(vect.vNegValExcept._ctor)
}


/**
 * builtin method
 */
export vect_vNegValExcept__ctor2_impl proc _ctor2(in _this: opaque, in private_data: opaque, inout _ex: sidl.sidl_BaseInterface__object) {
    // DO-NOT-DELETE splicer.begin(vect.vNegValExcept._ctor2)
    // DO-NOT-DELETE splicer.end(vect.vNegValExcept._ctor2)
}


/**
 * builtin method
 */
export vect_vNegValExcept__dtor_impl proc _dtor(in _this: opaque, inout _ex: sidl.sidl_BaseInterface__object) {
    // DO-NOT-DELETE splicer.begin(vect.vNegValExcept._dtor)
    // DO-NOT-DELETE splicer.end(vect.vNegValExcept._dtor)
}


/**
 * builtin method
 */
export vect_vNegValExcept__load_impl proc _load(in _this: opaque, inout _ex: sidl.sidl_BaseInterface__object) {
    // DO-NOT-DELETE splicer.begin(vect.vNegValExcept._load)
    // DO-NOT-DELETE splicer.end(vect.vNegValExcept._load)
}

} // class vect_vNegValExcept_Impl


class vect_Utils_Impl {
// DO-NOT-DELETE splicer.begin(vect.Utils.Impl)
// DO-NOT-DELETE splicer.end(vect.Utils.Impl)

/**
 * builtin method
 */
export vect_Utils__ctor_impl proc _ctor(in _this: opaque, inout _ex: sidl.sidl_BaseInterface__object) {
    // DO-NOT-DELETE splicer.begin(vect.Utils._ctor)
    // DO-NOT-DELETE splicer.end(vect.Utils._ctor)
}


/**
 * builtin method
 */
export vect_Utils__ctor2_impl proc _ctor2(in _this: opaque, in private_data: opaque, inout _ex: sidl.sidl_BaseInterface__object) {
    // DO-NOT-DELETE splicer.begin(vect.Utils._ctor2)
    // DO-NOT-DELETE splicer.end(vect.Utils._ctor2)
}


/**
 * builtin method
 */
export vect_Utils__dtor_impl proc _dtor(in _this: opaque, inout _ex: sidl.sidl_BaseInterface__object) {
    // DO-NOT-DELETE splicer.begin(vect.Utils._dtor)
    // DO-NOT-DELETE splicer.end(vect.Utils._dtor)
}


/**
 * builtin method
 */
export vect_Utils__load_impl proc _load(in _this: opaque, inout _ex: sidl.sidl_BaseInterface__object) {
    // DO-NOT-DELETE splicer.begin(vect.Utils._load)
    // DO-NOT-DELETE splicer.end(vect.Utils._load)
}

} // class vect_Utils_Impl


// all static member functions of vect_Utils
// FIXME: chpl allows only one module per library // module vect_Utils_static_Impl {

/**
 * 
 * Return TRUE if the specified vector is the unit vector, within the
 * given tolerance level; otherwise, return FALSE.
 * 
 */
export vect_Utils_vuIsZero_impl proc vuIsZero(in u: opaque /* array< > */, in tol: real(64), inout _ex: sidl.sidl_BaseInterface__object): bool {
    // DO-NOT-DELETE splicer.begin(vect.Utils.vuIsZero)
  var is = true;
  var u_meta = sidl.double_array.cast(u);
  var u_data = createBorrowedArray1d(u_meta);

  if u_meta._not_nil() then {
    var maxI = u_meta.upper(0);
    var i = u_meta.lower(0);
    while (i <= maxI) && is {
      var absVal = fabs(u_data[i]);
      if ( absVal > fabs(tol) ) then {
         is = false;
      }
      i+=1;
    }
  } else {
    is = false;
  }
                                                                              
  return is;
    // DO-NOT-DELETE splicer.end(vect.Utils.vuIsZero)
}


/**
 * 
 * Return TRUE if the specified vectors are equal, within the given
 * tolerance level; otherwise, return FALSE.
 * 
 */
export vect_Utils_vuIsUnit_impl proc vuIsUnit(in u: opaque /* array< > */, in tol: real(64), inout _ex: sidl.sidl_BaseInterface__object): bool {
    // DO-NOT-DELETE splicer.begin(vect.Utils.vuIsUnit)
  var is = false;
  var throwaway: sidl.BaseInterface;
  var vNorm = vect.Utils_static.vuNorm(u, tol, vect.BadLevel.NoVio, throwaway); 
  if ( fabs(vNorm - 1.0) <= fabs(tol) ) then {
    is = true;
  } else {
    is = false;
  }

  return is;
    // DO-NOT-DELETE splicer.end(vect.Utils.vuIsUnit)
}


/**
 * 
 * Return TRUE if the specified vectors are orthogonal, within the given
 * tolerance; otherwise, return FALSE.
 * 
 */
export vect_Utils_vuAreEqual_impl proc vuAreEqual(in u: opaque /* array< > */, in v: opaque /* array< > */, in tol: real(64), inout _ex: sidl.sidl_BaseInterface__object): bool {
    // DO-NOT-DELETE splicer.begin(vect.Utils.vuAreEqual)
  var   are = false;
  var u_meta = sidl.double_array.cast(u);
  var v_meta = sidl.double_array.cast(v);
  var u_data = createBorrowedArray1d(u_meta);
  var v_data = createBorrowedArray1d(v_meta);

  if ( (u_meta._not_nil()) && (v_meta._not_nil()) )
  {
    var lenU = u_meta.length(1);
    var lenV = v_meta.length(1);
    if ( (lenU == lenV) && (u_meta.dim() == 1) && (v_meta.dim() == 1) )
    {
      are = true;
      var i:int(32)=0;
      while (i < lenU) && are {
        var absDiff = fabs(u_data[i] - v_data[i]);
        if ( absDiff > fabs(tol) ) {
          are = false;
        }
	i += 1;
      }
    }
  }
                                                                              
  return are;
    // DO-NOT-DELETE splicer.end(vect.Utils.vuAreEqual)
}


/**
 * 
 * Return TRUE if the Schwarz (or Cauchy-Schwarz) inequality holds, within
 * the given tolerance; otherwise, return FALSE.
 * 
 */
export vect_Utils_vuAreOrth_impl proc vuAreOrth(in u: opaque /* array< > */, in v: opaque /* array< > */, in tol: real(64), inout _ex: sidl.sidl_BaseInterface__object): bool {
    // DO-NOT-DELETE splicer.begin(vect.Utils.vuAreOrth)
  var are = false;
  var u_meta = sidl.double_array.cast(u);
  var v_meta = sidl.double_array.cast(v);
  var u_data = createBorrowedArray1d(u_meta);
  var v_data = createBorrowedArray1d(v_meta);
                                                                              
  if (u_meta._not_nil()) && (v_meta._not_nil()) then
  {
    var throwaway: sidl.BaseInterface;
    var val = vect.Utils_static.vuDot(u, u, tol, vect.BadLevel.NoVio, throwaway); 
    if ( fabs(val) <= fabs(tol) ) {
      are = true;
    } else {
      are = false;
    }
  }
                                                                              
  return are;
    // DO-NOT-DELETE splicer.end(vect.Utils.vuAreOrth)
}


/**
 * 
 * Return TRUE if the Minkowski (or triangle) inequality holds, within the
 * given tolerance; otherwise, return FALSE.
 * 
 */
export vect_Utils_vuSchwarzHolds_impl proc vuSchwarzHolds(in u: opaque /* array< > */, in v: opaque /* array< > */, in tol: real(64), inout _ex: sidl.sidl_BaseInterface__object): bool {
    // DO-NOT-DELETE splicer.begin(vect.Utils.vuSchwarzHolds)
  var  holds = false;
  var u_meta = sidl.double_array.cast(u);
  var v_meta = sidl.double_array.cast(v);
  var u_data = createBorrowedArray1d(u_meta);
  var v_data = createBorrowedArray1d(v_meta);

  if ( (u_meta._not_nil()) && (v_meta._not_nil()) ) then
  {
    var throwaway: sidl.BaseInterface;
    var vDot = vect.Utils_static.vuDot(u, v, tol, vect.BadLevel.NoVio, throwaway);
    var absNorms = fabs(vect.Utils_static.vuNorm(u, tol, vect.BadLevel.NoVio, throwaway)
                      * vect.Utils_static.vuNorm(v, tol, vect.BadLevel.NoVio, throwaway)); 
    if ( fabs(vDot) <= (absNorms + fabs(tol)) ) then {
      holds = true;
    } else {
      holds = false;
    }
  }
                                                                              
  return holds;
    // DO-NOT-DELETE splicer.end(vect.Utils.vuSchwarzHolds)
}


/**
 * 
 * ******************** double result operations **********************
 * Return the norm (or length) of the specified vector.
 * Note that the size exception is given here simply because the
 * implementation is leveraging the vuDot() method.  Also the tolerance
 * is included to enable the caller to specify the tolerance used in
 * contract checking.
 * 
 */
export vect_Utils_vuTriIneqHolds_impl proc vuTriIneqHolds(in u: opaque /* array< > */, in v: opaque /* array< > */, in tol: real(64), inout _ex: sidl.sidl_BaseInterface__object): bool {
    // DO-NOT-DELETE splicer.begin(vect.Utils.vuTriIneqHolds)
  var  holds = false;
  var u_meta = sidl.double_array.cast(u);
  var v_meta = sidl.double_array.cast(v);
  var u_data = createBorrowedArray1d(u_meta);
  var v_data = createBorrowedArray1d(v_meta);
                                                                                
  if u_meta._not_nil() && v_meta._not_nil() then
  {
    if (u_meta.dim() == 1) && (v_meta.dim() == 1) then {
      var throwaway   : sidl.BaseInterface;
      var sum         = vect.Utils_static.vuSum(u, v, vect.BadLevel.NoVio, throwaway);
      var absNormSum  = fabs(vect.Utils_static.vuNorm(sum, tol, vect.BadLevel.NoVio, throwaway));
      var normU       = vect.Utils_static.vuNorm(u, tol, vect.BadLevel.NoVio, throwaway);
      var normV       = vect.Utils_static.vuNorm(v, tol, vect.BadLevel.NoVio, throwaway);
      var absSumNorms = fabs(normU + normV);
      if ( absNormSum <= absSumNorms + fabs(tol)) {
        holds = true;
      } else {
        holds = false;
      }
    }
  }

  return holds;
    // DO-NOT-DELETE splicer.end(vect.Utils.vuTriIneqHolds)
}


/**
 * 
 * Return the dot (, inner, or scalar) product of the specified vectors.
 * 
 */
export vect_Utils_vuNorm_impl proc vuNorm(in u: opaque /* array< > */, in tol: real(64), in badLevel: BadLevel, inout _ex: sidl.sidl_BaseInterface__object): real(64) {
    // DO-NOT-DELETE splicer.begin(vect.Utils.vuNorm)
  var u_meta = sidl.double_array.cast(u);
  var u_data = createBorrowedArray1d(u_meta);
  var    res = 0.0 :real(64);

  var msg = "vuNorm: vNegValExcept: Cannot sqrt() a negative value.";
  var throwaway: sidl.BaseInterface;
                                                                                
  if (badLevel == vect.BadLevel.NoVio)
  {
    if (u_meta._not_nil())
    {
      var dot = vect.Utils_static.vuDot(u, u, tol, vect.BadLevel.NoVio, throwaway); 
      if (dot > 0.0) then {
        res = sqrt(dot);
      } else if (dot < 0.0) then {
        /* Note that this should NEVER happen! */
        res = -5.0 :real(64);
        var ex = vect.vNegValExcept_static.create(throwaway);
        ex.setNote(msg, throwaway);
        ex.add("vect_Impl.chpl", 389, "vect.vNegValExcept", throwaway);
	_ex = ex.as_sidl_BaseInterface();
        return -1: real(64); //throw ex;
      }
    }
  } else if (badLevel == vect.BadLevel.NegRes) {
    res = -5.0 :real(64);
  } else if (badLevel == vect.BadLevel.PosRes) {
    res = 5.0 :real(64);
  } else if (badLevel == vect.BadLevel.ZeroRes) {
    res = 0.0 :real(64);
  } else {
    res = -5.0 :real(64);
  }
                                                                                
  return res;
    // DO-NOT-DELETE splicer.end(vect.Utils.vuNorm)
}


/**
 * 
 * ******************** vector result operations ***********************
 * Return the (scalar) product of the specified vector.
 * 
 */
export vect_Utils_vuDot_impl proc vuDot(in u: opaque /* array< > */, in v: opaque /* array< > */, in tol: real(64), in badLevel: BadLevel, inout _ex: sidl.sidl_BaseInterface__object): real(64) {
    // DO-NOT-DELETE splicer.begin(vect.Utils.vuDot)
  var dot = 0.0;
  var u_meta = sidl.double_array.cast(u);
  var v_meta = sidl.double_array.cast(v);
  var u_data = createBorrowedArray1d(u_meta);
  var v_data = createBorrowedArray1d(v_meta);
         
  var lenU: int(32);
  if u_meta._not_nil() then lenU = u_meta.length(1); else lenU = 0;
  if (badLevel == vect.BadLevel.NoVio) 
  {
    if u_meta._not_nil() && v_meta._not_nil() then
    {
      var lenV = v_meta.length(1);
      if (lenU == lenV) && (u_meta.dim() == 1) && (v_meta.dim() == 1) then
      {
	[i in 0..#lenU] dot += u_data[i:int(32)] * v_data[i:int(32)];
      }
    }
  } else if (badLevel == vect.BadLevel.NegRes) {
    dot = -5.0;
  } else if (badLevel == vect.BadLevel.PosRes) {
    dot = 5.0;
  } else {
    dot = -1.0;
  }
                                                                                
  return dot:real(64);
    // DO-NOT-DELETE splicer.end(vect.Utils.vuDot)
}


/**
 * 
 * Return the negation of the specified vector.
 * 
 */
export vect_Utils_vuProduct_impl proc vuProduct(in a: real(64), in u: opaque /* array< > */, in badLevel: BadLevel, inout _ex: sidl.sidl_BaseInterface__object): opaque /* array< > */ {
    // DO-NOT-DELETE splicer.begin(vect.Utils.vuProduct)
  var u_meta = sidl.double_array.cast(u);
  var u_data = createBorrowedArray1d(u_meta);
                                                                                
  var lenU: int(32);
  if u_meta._not_nil() then lenU = u_meta.length(1); else lenU = 0;

  if badLevel == vect.BadLevel.NoVio then
  {
    var prod = sidl.double_array.create1d(lenU);
    if u_meta._not_nil() then {
      [i in 0..#lenU] prod(2)[i:int(32)] = a * u_data[i:int(32)];
    }
    return prod(1).generic;

  } else if (badLevel == vect.BadLevel.NullRes) {
    var prod: opaque; // NULL
    return prod;

  } else if (badLevel == vect.BadLevel.TwoDRes) {
    var prod = sidl.double_array.create2dCol(lenU, lenU);
    return prod(1).generic;

  } else if (badLevel == vect.BadLevel.WrongSizeRes) {
    var prod = sidl.double_array.create1d(lenU+5);
    return prod(1).generic;

  } else {
    var prod: opaque; // NULL
    return prod;
  }
    // DO-NOT-DELETE splicer.end(vect.Utils.vuProduct)
}


/**
 * 
 * Return the normalizaton of the specified vector.
 * Note the tolerance is included because the implementation invokes 
 * vuDot().
 * 
 */
export vect_Utils_vuNegate_impl proc vuNegate(in u: opaque /* array< > */, in badLevel: BadLevel, inout _ex: sidl.sidl_BaseInterface__object): opaque /* array< > */ {
    // DO-NOT-DELETE splicer.begin(vect.Utils.vuNegate)
  var u_meta = sidl.double_array.cast(u);
  var lenU: int(32);
  if u_meta._not_nil() then lenU = u_meta.length(1); else lenU = 0;
  if badLevel == vect.BadLevel.NoVio then {
    if u_meta._not_nil() then {
      var throwaway: sidl.BaseInterface;
      return vect.Utils_static.vuProduct(-1.0, u, vect.BadLevel.NoVio, throwaway);
    }
  } else if (badLevel == vect.BadLevel.NullRes) {
    var negU: opaque; // NULL
    return negU;

  } else if (badLevel == vect.BadLevel.TwoDRes) {
    var negU = sidl.double_array.create2dCol(lenU, lenU);
    return negU(1).generic;

  } else if (badLevel == vect.BadLevel.WrongSizeRes) {
    var negU = sidl.double_array.create1d(lenU+5);
    return negU(1).generic;

  }

  var negU: opaque; // NULL
  return negU;
    // DO-NOT-DELETE splicer.end(vect.Utils.vuNegate)
}


/**
 * 
 * Return the sum of the specified vectors.
 * 
 */
export vect_Utils_vuNormalize_impl proc vuNormalize(in u: opaque /* array< > */, in tol: real(64), in badLevel: BadLevel, inout _ex: sidl.sidl_BaseInterface__object): opaque /* array< > */ {
    // DO-NOT-DELETE splicer.begin(vect.Utils.vuNormalize)
  var u_meta = sidl.double_array.cast(u);
  var lenU: int(32);
  if u_meta._not_nil() then lenU = u_meta.length(1); else lenU = 0;

  if badLevel == vect.BadLevel.NoVio then 
  {
    if u_meta._not_nil() then
    {
      var throwaway: sidl.BaseInterface;
      var val = vect.Utils_static.vuNorm(u, tol, vect.BadLevel.NoVio, throwaway);
/* #ifdef DEBUG */
/*       fprintf(stderr, "vect.Utils.vuNormalize: val=%f\n", val); */
/* #endif /\* DEBUG *\/ */
      if val != 0.0 then {
	var throwaway: sidl.BaseInterface;
        var prod = vect.Utils_static.vuProduct(1.0/val, u, vect.BadLevel.NoVio, throwaway);
	return prod;
      } else {
        // prod = NULL;
/* #ifdef DEBUG */
/*         fprintf(stderr, "vect.Utils.vuNormalize: throwing DBZ exception\n"); */
/* #endif /\* DEBUG *\/ */
        var ex = vect.vDivByZeroExcept_static.create(throwaway);
        ex.setNote("vuNormalize: vDivByZeroExcept: Cannot divide by zero.", throwaway);
        ex.add("vect_Impl.chpl", 564, "vect.vDivByZeroExcept", throwaway);
	_ex = ex.as_sidl_BaseInterface();
        //throw ex;
	return u;
      }
    }
  } else if badLevel == vect.BadLevel.NullRes then {
    var prod: opaque; // NULL
    return prod;

  } else if badLevel == vect.BadLevel.TwoDRes then {
    var prod = sidl.double_array.create2dCol(lenU, lenU);
    return prod(1).generic;

  } else if badLevel == vect.BadLevel.WrongSizeRes then {
    var prod = sidl.double_array.create1d(lenU+5);
    return prod(1).generic;

  }
  
  var prod: opaque; // NULL
  return prod;
    // DO-NOT-DELETE splicer.end(vect.Utils.vuNormalize)
}


/**
 * 
 * Return the difference of the specified vectors.
 * 
 */
export vect_Utils_vuSum_impl proc vuSum(in u: opaque /* array< > */, in v: opaque /* array< > */, in badLevel: BadLevel, inout _ex: sidl.sidl_BaseInterface__object): opaque /* array< > */ {
    // DO-NOT-DELETE splicer.begin(vect.Utils.vuSum)
  var u_meta = sidl.double_array.cast(u);
  var v_meta = sidl.double_array.cast(v);
  var u_data = createBorrowedArray1d(u_meta);
  var v_data = createBorrowedArray1d(v_meta);
  var lenU: int(32);
  if u_meta._not_nil() then lenU = u_meta.length(1); else lenU = 0;

  if badLevel == vect.BadLevel.NoVio then 
  {
    if u_meta._not_nil() && v_meta._not_nil()  then
    {
      var lenV = v_meta.length(1);  // sidlLength(v._get_ior(), 0);
      if  (lenU == lenV) && (u_meta.dim() == 1) && (v_meta.dim() == 1)  then
      {
	var sum = sidl.double_array.create1d(lenU);
        [i in 0..#lenU] sum(2)[i:int(32)] = u_data[i:int(32)] + v_data[i:int(32)];
	return sum(1).generic;
      }
    }
  } else if badLevel == vect.BadLevel.NullRes then {
    var sum: opaque; // NULL
    return sum;

  } else if badLevel == vect.BadLevel.TwoDRes then {
    var sum = sidl.double_array.create2dCol(lenU, lenU);
    return sum(1).generic;

  } else if badLevel == vect.BadLevel.WrongSizeRes then {
    var sum = sidl.double_array.create1d(lenU+5);
    return sum(1).generic;

  }
  
  var sum: opaque; // NULL
  return sum;
    // DO-NOT-DELETE splicer.end(vect.Utils.vuSum)
}


export vect_Utils_vuDiff_impl proc vuDiff(in u: opaque /* array< > */, in v: opaque /* array< > */, in badLevel: BadLevel, inout _ex: sidl.sidl_BaseInterface__object): opaque /* array< > */ {
    // DO-NOT-DELETE splicer.begin(vect.Utils.vuDiff)
  var u_meta = sidl.double_array.cast(u);
  var v_meta = sidl.double_array.cast(v);
  var u_data = createBorrowedArray1d(u_meta);
  var v_data = createBorrowedArray1d(v_meta);
  var lenU: int(32);
  if u_meta._not_nil() then lenU = u_meta.length(1); else lenU = 0;

  if badLevel == vect.BadLevel.NoVio then
  {
    if u_meta._not_nil() && v_meta._not_nil()  then
    {
      var lenV = v_meta.length(1);  // sidlLength(v._get_ior(), 0);
      if  (lenU == lenV) && (u_meta.dim() == 1) && (v_meta.dim() == 1)  then
      {
	var diff = sidl.double_array.create1d(lenU);
        [i in 0..#lenU] diff(2)[i:int(32)] = u_data[i:int(32)] - v_data[i:int(32)];
	return diff(1).generic;
      }
    }
  } else if badLevel == vect.BadLevel.NullRes then {
    var diff: opaque; // NULL
    return diff;

  } else if badLevel == vect.BadLevel.TwoDRes then {
    var diff = sidl.double_array.create2dCol(lenU, lenU);
    return diff(1).generic;

  } else if badLevel == vect.BadLevel.WrongSizeRes then {
    var diff = sidl.double_array.create1d(lenU+5);
    return diff(1).generic;

  }
  
  var diff: opaque; // NULL
  return diff;
    // DO-NOT-DELETE splicer.end(vect.Utils.vuDiff)
}

//} // module vect_Utils_static_Impl


