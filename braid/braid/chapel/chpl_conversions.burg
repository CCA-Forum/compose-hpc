# -*- python -*-
# Process this file with burg.py
## @package chapel.conversions
#
# BURG-style low-level type conversion rules for IOR <-> Chapel.
#
# Please report bugs to <adrian@llnl.gov>.
#
# Calls are modeled as follows:
# <pre>
# bool f(in a:int, inout b:char)
#
#              assign
#              /    \
#            cons   call
#            /  \    / \
#          ret  b   f  cons
#                      /  \
#                     a    b
#
# rules can be
# chpl <-- cons(chpl, chpl)
#
# </pre> 
#
# \authors <pre>
#
# Copyright (c) 2011, 2012 Lawrence Livermore National Security, LLC.
# Produced at the Lawrence Livermore National Laboratory
# Written by Adrian Prantl <adrian@llnl.gov>.
#
# LLNL-CODE-473891.
# All rights reserved.
#
# This file is part of BRAID. For details, see
# http://compose-hpc.sourceforge.net/.
# Please read the COPYRIGHT file for Our Notice and
# for the BSD License.
#
# </pre>


#------------------------------------------------------------------------
# Declaration of additional arguments for the rule actions
#------------------------------------------------------------------------
%action arguments: (convs, skel, dest, full_type, type_conv)

#------------------------------------------------------------------------
import babel, ior, ir, sidl
import chapel.chpl as chpl
from codegen import CCodeGenerator, CFile

def c_gen(ir, scope=None):
    if scope == None:
        scope = CFile()
    return CCodeGenerator().generate(ir, scope)

# def XXXXsidl_arg_to_ir(symbol_table, (arg, attrs, mode, typ, name)):
#     return arg, attrs, mode, sidl_type_to_ir(symbol_table, typ), name

# def XXXXsidl_type_to_ir(symbol_table, typ):
#     """
#     Converts objects and arrays into their corresponding chapel types.
#     The implicit expectation is that typ was passed to
#     \c babel.lower_ir(lower_scoped_ids=False) .

#     FIX ME merge this code with lower_ir!!!!!!!!!!!!!!!!!!!

#     """
#     if babel.is_obj_type(symbol_table, typ):
#         iortype = babel.ior_type(symbol_table, typ)
    
#     elif typ[0] == sidl.struct: #babel.is_struct_type(symbol_table, typ):
#         #iortype = babel.lower_ir(*symbol_table[typ])
#         #if (mode == sidl.in_):
#         #    iortype = ir.Pointer_type(iortype)

#         def conv_rarray_items((struct, name, items, docstring)):
#             def f((item, typ, name)):
#                 #if typ[0] == ir.rarray:
#                 #    import pdb; pdb.set_trace()
#                 #    return item, convert_arg((arg, attrs, mode, typ, name))[2][3], name
#                 #el
#                 if typ[0] == ir.struct:
#                     return item, conv_rarray_items(typ), name
#                 else: return item, sidl_type_to_ir(symbol_table, typ), name

#             return struct, name, map(f, items), docstring

#         iortype = conv_rarray_items(typ)

#     elif typ[0] == sidl.scoped_id:
#         import pdb; pdb.set_trace()
#         # Other Symbol
#         iortype = symbol_table[typ][1]

#     elif typ == sidl.void:
#         iortype = ir.pt_void

#     elif typ == sidl.opaque:
#         iortype = ir.Pointer_type(ir.pt_void)

#     elif typ == (sidl.array, [], [], []): 
#         # This comment is there so the Chapel code generator won't
#         # recognize the type as an array. For generic SIDL arrays, we
#         # actually want a C struct type.
#         iortype = ir.Pointer_type(ir.Struct('sidl__array /* IOR */', [], ''))
#         if name == '_retval':
#             iortype = ir.Pointer_type(ir.pt_void)

#     elif typ[0] == sidl.array: # Scalar_type, Dimension, Orientation
#         if typ[1][0] == ir.scoped_id:
#             t = 'BaseInterface'
#         else:
#             t = typ[1][1]
#         iortype = ir.Pointer_type(ir.Struct('sidl_%s__array /* IOR */'%t, [], ''))

#     elif typ[0] == sidl.rarray: # Scalar_type, Dimension, ExtentsExpr
#         iortype = ir.Typedef_type('sidl_%s__array'%typ[1][1])
    
#     else: 
#         iortype = typ
#     return iortype



def ir_arg_to_chpl((arg, attrs, mode, typ, name)):
    return arg, attrs, mode, ir_type_to_chpl(typ), name

def ir_type_to_chpl(typ):
    """
    Convert only the datatype \c typ into its chapel equivalent
    TODO: could we also generate this from the spec below?
    """
    mapping = {
        ir.pt_void:     ir.pt_void,
        ir.pt_bool:     ir.Typedef_type('chpl_bool'),
        ir.pt_string:   ir.const_str,
        ir.pt_int:      ir.pt_int, #ir.Typedef_type('int32_t'),
        ir.pt_long:     ir.pt_long, #ir.Typedef_type('int64_t'),
        ir.pt_char:     ir.const_str,
        ir.pt_fcomplex: ir.Typedef_type('_complex64'), 
        ir.pt_dcomplex: ir.Typedef_type('_complex128'),
        ir.pt_float:    ir.pt_float,
        ir.pt_double:   ir.pt_double,
        sidl.pt_opaque: ir.Pointer_type(ir.pt_void)
        }
    try:
        return mapping[typ]
    except:
        if typ[0] == ir.enum: 
            # the types need to be dissimilar, even if they have the same name
            enum, name, items, comment = typ
            return enum, name, items, 'chpl '+comment
        if typ[0] == ir.typedef_type and typ[1] == 'sidl_bool': 
            return ir.Typedef_type('chpl_bool')
        if typ[0] == 'upcast':
            # part of the hack for self dereferencing
            return typ[1]
        if typ[0] == ir.pointer_type:
            return ir.Pointer_type(ir_type_to_chpl(typ[1]))

        if typ[0] == ir.struct:
            _, name, items, comment = typ
            items1 = map(ir_type_to_chpl, items)
            # User-defined structs are created in the IOR with an
            # '__data' suffix, so we can use the actual name for the
            # Chapel version of the struct.
            if name[-6:] == '__data': 
                name = name[:-6] # Wow, is this unelegant!

            return ir.Struct(name, items1, comment)

        if typ[0] == ir.struct_item:
            return ir.Struct_item(ir_type_to_chpl(typ[1]),typ[2])

        if typ[0] == sidl.array:
            return get_array_type(typ)[1]

        if typ[0] == sidl.rarray:
            return get_array_type(typ)[1]

        return typ


def strip(typ):
    if typ[0] == ir.pointer_type and typ[1][0] == ir.struct:
        return ir.struct
    # strip unnecessary details from aggregate types
    if (typ[0] == sidl.class_ or 
        typ[0] == sidl.interface):
        return ior.ext
    if (typ[0] == ir.enum or
        typ[0] == ir.rarray or
        typ[0] == ir.pointer_type or
        typ[0] == ir.struct):
        return typ[0]
    return typ

def copy_other_items(convs, items, a0, dest):
    """
    copy all struct items that need not to be converted
    """
    for _, typ, name in items:
        if typ[0] == ir.struct:
            copy_other_items(convs, ir.struct_struct_items(typ), a0+name+'.', dest+'.'+name)

        if ir_type_to_chpl(typ) == typ: # boy, is this inefficient!!
            convs.append(ir.Stmt(ir.Assignment(dest+'.'+name, a0+name)))

def get_struct_items(full_type):
    t = full_type[1] if full_type[0] == ir.pointer_type else full_type
    return ir.struct_struct_items(t) 


def elem_access(typ):
    if typ[0] == ir.struct:
        return '.'
    else: return ''

def get_array_type(full_type):
   if full_type[1] == []:
       t = ''
   elif full_type[1][0] == ir.scoped_id:
       t = '_BaseInterface'
   else:
       t = '_'+full_type[1][1]
   name = 'sidl%s__array'%t
   iortype = ir.Pointer_type(ir.Struct(name, [], ''))
   return name, iortype 

def get_ior_array_type(sidl_array):
    struct_name = sidl_array[1][1]
    m = babel.sidl_array_regex.match(struct_name)
    return m.group(1) if m else ir.void_ptr


def wrap_rarray(convs, a0, fulltype, dest):
    data  = '_braid_%s_data'  %a0
    dom   = '_braid_%s_dom'   %a0
    local = '_braid_%s_local' %a0
    scalar_type = fulltype[1][1]
    iortype = ir.Typedef_type('sidl_%s__array'%scalar_type)

    # sanity check on input array: ensure domain is rectangular
    convs.append(ir.Stmt(ir.Call('performSanityCheck', [dom, '"%s"'%a0])))

    # ensure we are working with a 'local' array
    # FIXME Hack to define a variable without explicitly specifying type
    # should we change the IR to support this?
    convs.append(ir.Stmt(ir.Assignment('var ' + data,
                                      ir.Call("getOpaqueData", [ir.Call(a0, [dom+'.low'])]))))
    convs.append(ir.Stmt(ir.Assignment('var ' + local,
                                      ir.Call("ensureLocalArray", [a0, data]))))

                    
    # Babel is strange when it comes to Rarrays. The convention is to
    # wrap Rarrays inside of a SIDL-Array in the Stub and to unpack it
    # in the Skeleton. However, in some languages (C, C++) we could
    # just directly call the Impl and save all that wrapper code.
    #
    # I found out the the reason behind this is that r-arrays were
    # never meant to be a performance enhancement, but syntactic sugar
    # around the SIDL array implementation to offer a more native
    # interface.
    #
    # TODO: Change the IOR in Babel to use the r-array calling
    # convention.  This will complicate the Python/Fortran/Java
    # backends but simplify the C/C++ ones.
    sidl_wrapping = (ir.stmt, """
var {a}rank = _braid_dom_{arg}.rank: int(32);

var {a}lus = computeLowerUpperAndStride(_braid_local_{arg});
var {a}lower = {a}lus(0): int(32);
var {a}upper = {a}lus(1): int(32);
var {a}stride = {a}lus(2): int(32);

{dest} = {iortype}_borrow(
    {stype}_ptr(_braid_local_{arg}(_braid_local_{arg}.domain.low)),
    //_braid_local_{arg}(_braid_local_{arg}.domain.low),
    {a}rank,
    {a}lower[1],
    {a}upper[1],
    {a}stride[1])""".format(a='_braid_%s_'%a0,
                            arg=a0,
                            dest=dest,
                            iortype=iortype[1],
                            stype=scalar_type))
    
    convs.append(sidl_wrapping)
    # post_call.append((ir.stmt, '//sidl__array_deleteRef((struct sidl__array*)a_tmp)'))


char_lut = '''
/* This burial ground of bytes is used for char [in]out arguments. */
static const unsigned char chpl_char_lut[512] = {
  '''+' '.join(['%d, 0,'%i for i in range(0, 256)])+'''
};
'''

#------------------------------------------------------------------------
%rules:
# Rule format
# -----------
#
# chpl.vcall @ chpl <-- ior.vcall @ C : cost(1)
#   actions
#------------------------------------------------------------------------


# BOOL
#------------------------------------------------------------------------
ior.bool @ C <-- chpl.bool : cost(1)
    convs.append(ir.Comment('sidl_bool is an int, but chapel bool is a char/_Bool'))
    convs.append((ir.stmt, '{dest} = ({typ}){n}'
                  .format(dest=dest, n=a0, typ=c_gen(ir.pt_bool))))

chpl.bool @ C <-- ior.bool : cost(1)
    convs.append(ir.Comment('sidl_bool is an int, but chapel bool is a char/_Bool'))
    convs.append((ir.stmt, '{dest} = ({typ}){n}'
                  .format(dest=dest, n=a0, typ=c_gen(ir_type_to_chpl(ir.pt_bool)))))

# CHAR
#------------------------------------------------------------------------
ior.char @ C <-- chpl.char : cost(1)
    convs.append(ir.Comment('in chapel, a char is a string of length 1'))
    convs.append((ir.stmt, '{dest} = (int){n}[0]'.format(dest=dest, n=a0)))
    skel.cstub.optional.add(char_lut)

chpl.char @ C <-- ior.char : cost(1)
    convs.append(ir.Comment('in chapel, a char is a string of length 1'))
    # we can't allocate a new string, this would leak memory
    convs.append((ir.stmt, '{dest} = (const char*)&chpl_char_lut[2*(unsigned char){n}]'
                  .format(dest=dest, n=a0)))
    skel.cstub.optional.add(char_lut)

# COMPLEX - 32/64 Bit components
#------------------------------------------------------------------------
ior.fcomplex @ C <-- chpl.fcomplex : cost(2)
    fmt = {'dest':dest, 'n':a0}
    convs.append((ir.stmt, '{dest}.real = {n}.re'.format(**fmt)))
    convs.append((ir.stmt, '{dest}.imaginary = {n}.im'.format(**fmt)))

ior.dcomplex @ C <-- chpl.dcomplex : cost(2)
    fmt = {'dest':dest,'n':a0}
    convs.append((ir.stmt, '{dest}.real = {n}.re'.format(**fmt)))
    convs.append((ir.stmt, '{dest}.imaginary = {n}.im'.format(**fmt)))

chpl.fcomplex @ C <-- ior.fcomplex : cost(2)
    fmt = {'dest':dest,'n':a0}
    convs.append((ir.stmt, '{dest}.re = {n}.real'.format(**fmt)))
    convs.append((ir.stmt, '{dest}.im = {n}.imaginary'.format(**fmt)))

chpl.dcomplex @ C <-- ior.dcomplex : cost(2)
    fmt = {'dest':dest,'n':a0}
    convs.append((ir.stmt, '{dest}.re = {n}.real'.format(**fmt)))
    convs.append((ir.stmt, '{dest}.im = {n}.imaginary'.format(**fmt)))

# ENUM
#------------------------------------------------------------------------
ior.enum @ C <-- chpl.enum: cost(1)
    # No special treatment for enums, rely on chpl runtime to set it
    convs.append(ir.Stmt(ir.Assignment(dest, ir.Sign_extend(64, a0))))

chpl.enum @ C <-- ior.enum: cost(1)
    convs.append(ir.Stmt(ir.Assignment(dest, a0)))

# SELF
#------------------------------------------------------------------------
# ior.baseobject @ C <-- upcast(chpl.baseobject): cost(1)
#     # We should find a cleaner way of implementing this
#     #if a0 == 'self' and member_chk(ir.pure, attrs):
#     import pdb; pdb.set_trace()
#     convs.append(ir.Stmt(ir.Assignment(dest, '(({0})((struct sidl_BaseInterface__object*)self)<--d_object)'.format(c_gen(typ)))))
#     return dest

# OBJECTS
#------------------------------------------------------------------------
ior.ext @chpl <-- chpl.ext: cost(1)
     s_id = full_type[1][1]
     name = s_id[2]
     convs.append((ir.stmt, '%s = %s.self_%s'%(dest, a0, name)))

chpl.ext @chpl <-- ior.ext: cost(1)
     s_id = full_type[1][1]     
     # drop the id's extension, which we hijacked for '__object'
     s_id1 = ir.Scoped_id(s_id[1], s_id[2], '')
     name = s_id[2]
     #mod_name = '.'.join(full_type[1]+[name])
     wrap = ir.Call('%s_static.wrap_%s' %(babel.qual_id(s_id1, '.'), name), [a0, '_ex'])
     convs.append(ir.Stmt(ir.Assignment(dest, wrap)))

# STRING
#------------------------------------------------------------------------
ior.string @C <-- chpl.string: cost(0)
    convs.append(ir.Stmt(ir.Assignment(dest, a0)))

chpl.string @C <-- ior.string: cost(1)
    # Convert null pointer into empty string
    convs.append(ir.Stmt(ir.Assignment(dest, a0)))
    convs.append((ir.stmt, 'if ({n} == NULL) {n} = ""'.format(n=dest)))

# INT
#------------------------------------------------------------------------
ior.int @C <-- chpl.int: cost(0)
    pass
chpl.int @C <-- ior.int: cost(0)
    pass

# LONG
#------------------------------------------------------------------------
ior.long @C <-- chpl.long: cost(0)
    pass
chpl.long @C <-- ior.long: cost(0)
    pass

# FLOAT
#------------------------------------------------------------------------
ior.float @C <-- chpl.float: cost(0)
    pass
chpl.float @C <-- ior.float: cost(0)
    pass

# DOUBLE
#------------------------------------------------------------------------
ior.double @C <-- chpl.double: cost(0)
    pass
chpl.double @C <-- ior.double: cost(0)
    pass


# VOID return type
#------------------------------------------------------------------------
chpl.void @C <-- ior.void:cost(0)
    pass
ior.void @C <-- chpl.void:cost(0)
    pass

# OPAQUE
#------------------------------------------------------------------------
chpl.opaque @chpl <-- chpl.pointer_type:cost(0)
    pass
chpl.pointer_type @chpl <-- chpl.opaque:cost(0)
    pass

# FIXME:
# chpl.pointer_type @C <-- ior.*
#   a0 = ir.Pointer_expr(a0)

chpl.pointer_type @C <-- ior.pointer_type :cost(0)
    pass

ior.pointer_type @C <-- chpl.pointer_type :cost(0)
    pass

# STRUCT
#------------------------------------------------------------------------
# FIXME: we would actually need dynamic costs for this situation
ior.struct @C <-- chpl.struct: cost(9)
    items = get_struct_items(full_type)

    #print name, typ, ir_type_to_chpl(typ)

    # recursively generate conversions for all items in the struct
    map(lambda (_, typ, name):
          codegen(type_conv(typ), a0+name+elem_access(typ), strip(typ),
                  convs, skel, dest+'.'+name, typ), items, type_conv)

    # if we need to convert one of the items, we need to convert all of them
    if convs: copy_other_items(convs, items, a0, '%s'%dest)

chpl.struct @C <-- ior.struct: cost(9)
    items = get_struct_items(full_type)
    map(lambda (_, typ, name):
          codegen((strip(typ), a0+'.'+name), type_conv(typ),
                  convs, skel, dest+'.'+name, typ), items, type_conv)
    if convs: copy_other_items(convs, items, '%s.'%a0, dest)

# SIDL ARRAY
#------------------------------------------------------------------------

# for sidl arrays we invoke a chapel code fragment from the C stub
chpl.array @chpl <-- chpl.new_array: cost(1)
    scalar_type = get_ior_array_type(full_type)
    convs.append(ir.Stmt(ir.Assignment(dest, ir.Call('sidl.wrap_%s_array'%scalar_type, [a0]))))


chpl.new_array @chpl <-- ior.array @chpl: cost(1)
    scalar_type = get_ior_array_type(full_type)
# now part of sidl.chpl:
#    skel.gen(ir.Fn_defn(
#            [], ir.pt_void, '%s_to_chpl'%fu_type, 
#            [ir.Arg([], ir.in_, full_type, 'ior')],
#            [ir.Stmt((ir.new, 'sidl.Array', [scalar_type, full_type, dest]))],
#            'argument conversion codelet'))


ior.array @chpl <-- chpl.array: cost(1)
    scalar_type = get_ior_array_type(full_type)
    if scalar_type == ir.void_ptr:
        convs.append(ir.Stmt(ir.Assignment(dest, a0)))
    else:
        convs.append(ir.Stmt(ir.Assignment(dest, a0+'.ior')))

#ior.array @C <-- chpl.array: cost(1)
#    scalar_type = get_array_type(full_type)
#    convs.append((ir.stmt, '{dest} = ({typ}){n}.self'
#                  .format(dest=dest, n=a0, typ=scalar_type)))

    # wrap the C type in a native Chapel object
    #if mode == sidl.inout:
    #    pre_call.append(ir.Stmt(ir.Assignment(iorname, name+'.self')))

                    
    # if name == '_retval':
    #     return_expr.append(conv)
    # else:
    #     post_call.append(ir.Stmt(ir.Assignment(name, conv)))

# RAW ARRAY
#------------------------------------------------------------------------
ior.rarray @chpl <-- chpl.array: cost(4)
    wrap_rarray(convs, a0, full_type, dest)

chpl.array @chpl <-- ior.rarray: cost(4)
    # emit code to copy back elements into non-local array
    sarray = "_braid_wrapped_local_{arg}_sarray".format(arg=a0)
    barray = "_babel_wrapped_local_{arg}_barray".format(arg=a0)
    sarr = ir.Call("new Array", ["%s.eltType"%a0, full_type[1], ior])
    barr = ir.Call("createBorrowedArray{dim}d".format(dim=full_typ[2]), [sarray])
    convs.append(ir.Stmt(ir.Assignment('var ' + sarray, sarr)))
    convs.append(ir.Stmt(ir.Assignment('var ' + barray, barr)))
    convs.append(ir.Stmt(ir.Call('syncNonLocalArray', [barray, a0])))
