# -*- python -*-
# Process this file with burg.py
## @package chapel.conversions
#
# BURG-style low-level type conversion rules for IOR <-> Chapel.
#
# Please report bugs to <adrian@llnl.gov>.
#
# Calls are modeled as follows:
# <pre>
# bool f(in a:int, inout b:char)
#
#              assign
#              /    \
#            cons   call
#            /  \    / \
#          ret  b   f  cons
#                      /  \
#                     a    b
# </pre>
#
# rules can be
# <pre>
#   chpl <-- cons(chpl, chpl)
# </pre>
#
# Structs are modelled as follows
# <pre>
# struct simple { b:bool, c:char, d:double };
# void f(in a:struct simple, in i:int)
#
#     call
#     /  \
#    f   cons
#        /  \
#    struct  i
#    /   \
#   a    item
#        /  \
#       b   item
#           /  \
#          c    d
# </pre>
#
# todo: write about the xeroxing mechanism..
#
# \authors <pre>
#
# Copyright (c) 2011-2013 Lawrence Livermore National Security, LLC.
# Produced at the Lawrence Livermore National Laboratory
# Written by Adrian Prantl <adrian@llnl.gov>.
#
# LLNL-CODE-473891.
# All rights reserved.
#
# This file is part of BRAID. For details, see
# http://compose-hpc.sourceforge.net/.
# Please read the COPYRIGHT file for Our Notice and
# for the BSD License.
#
# </pre>


#------------------------------------------------------------------------
import babel, ior, ir, sidl, re
import chapel.chpl as chpl
from codegen import CCodeGenerator, CFile
from utils import hashable

def c_gen(ir, scope=None):
    if scope == None:
        scope = CFile()
    return CCodeGenerator().generate(ir, scope)

def ir_type_to_chpl(typ, in_struct=False):
    """
    Convert only the datatype \c typ into its chapel equivalent
    TODO: could we also generate this from the spec below?
    """
    mapping = {
        ir.pt_void:     ir.pt_void,
        ir.pt_bool:     ir.Typedef_type('chpl_bool'),
        ir.pt_string:   ir.const_str,
        ir.pt_int:      ir.pt_int, #ir.Typedef_type('int32_t'),
        ir.pt_long:     ir.pt_long, #ir.Typedef_type('int64_t'),
        ir.pt_char:     ir.const_str,
        ir.pt_fcomplex: ir.Typedef_type('_complex64'), 
        ir.pt_dcomplex: ir.Typedef_type('_complex128'),
        ir.pt_float:    ir.pt_float,
        ir.pt_double:   ir.pt_double,
        sidl.pt_opaque: ir.Pointer_type(ir.pt_void)
        }
    try:
        return mapping[typ]
    except:
        if typ[0] == ir.enum: 
            # the types need to be dissimilar, even if they have the same name
            enum, name, items, comment = typ
            return enum, name, items, 'chpl '+comment
        if typ[0] == ir.typedef_type and typ[1] == 'sidl_bool': 
            import pdb; pdb.set_trace()
            return ir.Typedef_type('chpl_bool')
        if typ[0] == 'upcast':
            # part of the hack for self dereferencing
            return typ[1]
        if typ[0] == ir.pointer_type:
            return ir.Pointer_type(ir_type_to_chpl(typ[1], in_struct))

        if typ[0] == ir.struct:
            _, name, items, comment = typ
            items1 = map(ir_type_to_chpl, items)
            # User-defined structs are created in the IOR with an
            # '__data' suffix, so we can use the actual name for the
            # Chapel version of the struct.
            if name[-6:] == '__data': 
                name = name[:-6] # Wow, is this unelegant!

            return ir.Struct(name, items1, comment)

        if typ[0] == ir.struct_item:
            return ir.Struct_item(ir_type_to_chpl(typ[1], True), typ[2])

        if typ[0] == sidl.array:
            return get_array_type(typ)[1]

        if typ[0] == ir.rarray:
            return typ if not in_struct else get_array_type(typ)[1]

        return typ


def strip(typ):
    if typ[0] == ir.pointer_type and typ[1][0] == ir.struct:
        return ir.struct
    # strip unnecessary details from aggregate types
    if (typ[0] == sidl.class_ or 
        typ[0] == sidl.interface):
        return ior.ext
    if (typ[0] == ir.enum or
        typ[0] == ir.rarray or
        typ[0] == ir.pointer_type or
        typ[0] == ir.struct):
        return typ[0]
    return typ

def get_struct_items(full_type):
    t = full_type[1] if full_type[0] == ir.pointer_type else full_type
    return ir.struct_struct_items(t) 


def elem_access(typ):
    if typ[0] == ir.struct:
        return '.'
    else: return ''

def array_ior_type(array):
    '''
    in case we actually _mean_ the raw IOR struct, obfuscate the type,
    so the code generator doesn't recognize it as an array
    '''
    (ptr, (struct, name, items, docs)) = array
    return (ptr, (struct, '/* ARRAY IOR */'+name, items, docs))


def get_array_type(full_type):
    if full_type[1] == []:
        t = ''
    elif full_type[1][0] == ir.scoped_id:
        t = '_BaseInterface'
    else:
         t = '_'+full_type[1][1]
    name = 'sidl%s__array'%t
    iortype = ir.Pointer_type(ir.Struct(name, (), ''))
    return name, iortype 

def get_raw_ior_array_type(full_type):
    name, typ = get_array_type(full_type)
    return name, array_ior_type(typ)

def get_ior_array_type(sidl_array):
    chpl_type = {
        'bool':     ir.Typedef_type('chpl_bool'),
        'string':   ir.const_str,
        'int':      ir.pt_int, #ir.Typedef_type('int32_t'),
        'long':     ir.pt_long, #ir.Typedef_type('int64_t'),
        'char':     ir.const_str,
        'fcomplex': ir.Typedef_type('_complex64'), 
        'dcomplex': ir.Typedef_type('_complex128'),
        'float':    ir.pt_float,
        'double':   ir.pt_double,
        'opaque':   ir.Pointer_type(ir.pt_void),
        'BaseInterface': ir.Pointer_type(ir.pt_void),
        }
    struct_name = sidl_array[1][1]
    m = babel.sidl_array_regex.match(struct_name)
    if m and m.group(2):
        return chpl_type[m.group(2)], m.group(2)
    else:
        return ir.void_ptr, ir.void_ptr


def wrap_rarray(scope, a0, fulltype, dest):
    # trick the code generator or it would think this is part of a
    # virtual function call
    a0 = c_gen(a0)
    prefix = a0.replace('.', '_')
    data  = '%s_data'  %prefix
    dom   = '%s_dom'   %prefix
    local = '%s_local' %prefix
    rank  = '%s_rank'  %prefix
    lus   = '%s_lus'   %prefix  
    lower = '%s_lower' %prefix
    upper = '%s_upper' %prefix
    stride ='%s_stride'%prefix

    scalar_type = fulltype[1][1]
    iortype = ir.Typedef_type('sidl_%s__array'%scalar_type)

    # sanity check on input array: ensure domain is rectangular
    scope.gen(ir.Stmt(ir.Call('performSanityCheck', [dom, '"%s"'%prefix])))

    # ensure we are working with a 'local' array
    # FIXME Hack to define a variable without explicitly specifying type
    # should we change the IR to support this?
    scope.gen(ir.Copy('var ' + data,  ir.Call("getOpaqueData", [ir.Call(a0, [dom+'.low'])])))
    scope.gen(ir.Copy('var ' + local, ir.Call("ensureLocalArray", [a0, data])))
                    
    # Babel is strange when it comes to Rarrays. The convention is to
    # wrap Rarrays inside of a SIDL-Array in the Stub and to unpack it
    # in the Skeleton. However, in some languages (C, C++) we could
    # just directly call the Impl and save all that wrapper code.
    #
    # I found out the the reason behind this is that r-arrays were
    # never meant to be a performance enhancement, but syntactic sugar
    # around the SIDL array implementation to offer a more native
    # interface.
    #
    # TODO: Change the IOR in Babel to use the r-array calling
    # convention.  This will complicate the Python/Fortran/Java
    # backends but simplify the C/C++ ones.
    scope.gen(ir.Copy('var '+lus,    ir.Call('computeLowerUpperAndStride',[local])))
    scope.gen(ir.Copy('var '+rank,   ir.Cast(ir.pt_int, access(dom,'rank'))))
    scope.gen(ir.Copy('var '+lower,  ir.Cast(ir.pt_int, ir.Call('%s_lus'%prefix, [0]))))
    scope.gen(ir.Copy('var '+upper,  ir.Cast(ir.pt_int, ir.Call('%s_lus'%prefix, [1]))))
    scope.gen(ir.Copy('var '+stride, ir.Cast(ir.pt_int, ir.Call('%s_lus'%prefix, [2]))))
    scope.gen(ir.Copy(dest,
                      ir.Call('%s_borrow'%iortype[1],
                              [ir.Call(scalar_type+'_ptr', 
                                       [ir.Call(local, [access(access(local, 'domain'),'low')])]),
                               rank,
                               ir.Call(lower, [1]),
                               ir.Call(upper, [1]),
                               ir.Call(stride, [1])])))
    return



char_lut = '''
/* This burial ground of bytes is used for char [in]out arguments. */
static const unsigned char chpl_char_lut[512] = {
  '''+' '.join(['%d, 0,'%i for i in range(0, 256)])+'''
};
'''

def orig(ud):
    '''
    return the original (non-temp) name from a pair dest,src.
    '''
    # FIXME
    return ud[1] if len(c_gen(ud[0])) > len(c_gen(ud[1])) else ud[0]

def access(struct, item):
    '''
    shortcut for struct.item
    '''
    return (ir.get_struct_item, None, struct, (ir.struct_item, None, item))

def Cons(a, b):
    '''
    Treat a and b as lists and return a+b.
    None is treated as empty list.
    '''
    if a == None:                 a = []
    elif not isinstance(a, list): a = [a]
    if b == None:                 b = []
    elif not isinstance(b, list): b = [b]
    return a+b

def chain_items(prefix, items, language, symbol_table, dest, src, conv):
    '''
    recursively chain a list of struct items to a tree of items
    '''

    def chain1(items, language, symbol_table, pre0, pre1, conv):
        if len(items) == 0:
            import pdb; pdb.set_trace()
            return None

        _, typ, name = items[-1]
        item = ir_to_burg(typ, language, symbol_table,
                          True, #in_struct
                          access(pre0,name), 
                          access(pre1,name), 
                          [])

        if len(items) == 1:
            return item

        return 'item', item, chain1(items[:-1], language, symbol_table, pre0, pre1, conv)
    
    def tmpname(prefix):
        if prefix[0] == ir.get_struct_item:
            get, s, name, item = prefix
            assert(not strip_deref(name).startswith('_ior'))
            return get, s, '_ior_'+strip_deref(name), item
        return '_ior_' + prefix

    def same_access(a, b):
        if a[0] == ir.deref: return ir.deref, b
        return b

    # FIXME, this is ugly
    if c_gen(src).startswith('_ior_'): 
        pre0 = same_access(dest, prefix)
        pre1 = tmpname(prefix)
    else:
        pre0 = tmpname(prefix)
        pre1 = same_access(src, prefix)

    assert(pre0 <> pre1)

    # reverse items so they are converted first to last eventually
    return chain1(items, language, symbol_table, pre0, pre1, conv)

def ir_to_burg(typ, language, symbol_table, in_struct, *user_data):
    '''
    convert an IR datatype into its native chapel equivalent and
    return the corresponding BURG expression. Invoking codegen() on
    this expression as argument to one of the \c call rules will yield
    a conversion to the IOR.
    '''
    chpl_type_map={
        ir.pt_bool:     bool_chpl_chpl,
        ir.pt_char:     char_chpl_chpl,
        ir.pt_dcomplex: dcomplex_chpl_chpl,
        ir.pt_double:   double_chpl_chpl,
        ir.pt_float:    float_chpl_chpl,
        ir.pt_fcomplex: fcomplex_chpl_chpl,
        ir.pt_int:      int_chpl_chpl,
        ir.pt_long:     long_chpl_chpl,
        ir.pt_string:   string_chpl_chpl,
        ir.void_ptr:    opaque_chpl_chpl,

        ir.enum:        enum_chpl_chpl,
        'ext':          ext_chpl_chpl,
        'array':        array_chpl_chpl,
        ir.rarray:      rarray_chpl_chpl
        }

    ior_type_map={
        ir.pt_bool:     bool_ior_c,
        ir.pt_char:     char_ior_c,
        ir.pt_dcomplex: dcomplex_ior_c,
        ir.pt_double:   double_ior_c,
        ir.pt_float:    float_ior_c,
        ir.pt_fcomplex: fcomplex_ior_c,
        ir.pt_int:      int_ior_c,
        ir.pt_long:     long_ior_c,
        ir.pt_string:   string_ior_c,
        ir.void_ptr:    pointer_type_ior_c,

        ir.enum:        enum_ior_c,
        'ext':          ext_ior_c,
        'array':        array_ior_c,
        ir.rarray:      rarray_ior_c
        }

    struct_chpl_type_map={
        ir.pt_bool:     bool_chpl_chpl,
        ir.pt_char:     char_chpl_chpl,
        ir.pt_dcomplex: dcomplex_chpl_chpl,
        ir.pt_double:   double_chpl_chpl,
        ir.pt_float:    float_chpl_chpl,
        ir.pt_fcomplex: fcomplex_chpl_chpl,
        ir.pt_int:      int_chpl_chpl,
        ir.pt_long:     long_chpl_chpl,
        ir.pt_string:   string_chpl_chpl,
        ir.void_ptr:    opaque_chpl_chpl,

        ir.enum:        enum_chpl_chpl,
        'ext':          ext_chpl_chpl,
        'array':        array_chpl_chpl,
        ir.rarray:      rarray_item_chpl_chpl
        }

    struct_ior_type_map={
        ir.pt_bool:     bool_ior_c,
        ir.pt_char:     char_ior_c,
        ir.pt_dcomplex: dcomplex_ior_c,
        ir.pt_double:   double_ior_c,
        ir.pt_float:    float_ior_c,
        ir.pt_fcomplex: fcomplex_ior_c,
        ir.pt_int:      int_ior_c,
        ir.pt_long:     long_ior_c,
        ir.pt_string:   string_ior_c,
        ir.void_ptr:    pointer_type_ior_c,

        ir.enum:        enum_ior_c,
        'ext':          ext_ior_c,
        'array':        array_ior_c,
        ir.rarray:      rarray_item_ior_c
        }

    if language == 'ior':
        type_map = struct_ior_type_map if in_struct else ior_type_map
    else:
        type_map = struct_chpl_type_map if in_struct else chpl_type_map

    try:
        return type_map[typ], user_data
    except KeyError:  pass # not found
    except TypeError: pass # not hashable

    if typ[0] in [sidl.class_, sidl.interface]:
        return type_map['ext'], typ, user_data

    elif typ[0] == ir.pointer_type:
        if typ == ir.void_ptr:
            return type_map[ir.opaque], user_data

        elif typ[1][0] == ir.struct:
            if babel.is_obj_type(symbol_table, typ[1][1]):
                return type_map['ext'], typ, user_data
            elif babel.sidl_array_regex.match(typ[1][1]):
                return type_map['array'], hashable(typ), user_data
            else: # babel.is_struct_type(symbol_table, typ[1][1]):
                return ir_to_burg(typ[1], language, symbol_table, True, *user_data)
        else: raise Exception()

    elif typ[0] == ir.struct:
        struct, name, items, docstr = typ
        prefix     = strip_deref(orig(user_data))
        #print 'prefix=',prefix
        #print user_data[0], user_data[1], user_data[2]
        item_tree  = chain_items(prefix, items, language, symbol_table, *user_data)
        return ('struct', ('typ', hashable(typ), user_data), item_tree)

    elif typ[0] == ir.rarray:
        return type_map[ir.rarray], typ, user_data

    elif typ[0] == ir.enum:
        return type_map[ir.enum], hashable(typ), user_data

    raise Exception()

def copy_over(typ, a0):
    '''
    merely copy over src into dest without any conversion
    '''
    dest, src, conv = a0
    # was (orig, orig, None) but that doesn't do the right thing for
    # struct items, which sometimes need to be copied regardless,
    # because other struct items warrant a conversion
    return typ, (dest, src, conv)

def xerox_struct((typ, (dest, src, orig)), xitems):
    '''
    Helper for structs, create a dummy conversion action such that a
    temporary struct is allocated. The actual conversions and copy
    operations are generated through the "item" children of the
    struct.
    '''
    def item_convs(items):
        if not isinstance(items, list): return item_convs([items])
        r = []
        for item in items:
            ptr, (dest, src, cconvs) = item
            if cconvs:
                r.extend(cconvs[3])
            else:
                r.append(ir.Copy(dest, src))
        return r

    struct, name, items, docs = typ
    chpl_typ = struct, name[:-6], items, docs
    return chpl_typ, (dest, src, (typ, dest, src, [ir.Comment('xerox')]+item_convs(xitems)))

def c_convs(a):
    'extract the postponed c conversions from an [l,r]value_ior_c, if any'
    _, (_, _, c_xvalue) = a 
    if not c_xvalue: 
        return []
    _t, _dest, _src, conv = c_xvalue
    return conv

def make_carg((mode, (typ, (name1, name2, conv)))):
    # [inout]args = typ, dest_name, src_name, (None | (ctype, cdest_name, csrc_name, conv))
    return ir.Arg([], mode, typ, name1 if mode == ir.out else name2)

def make_stubcall_arg((typ, (name1, name2, _))):
    if typ == outgoing_arg:
        return name2
    if name1 <> name2:
        return name1
    return name2

def get_c_tmp1(arg):
    typ, (_, name, conv) = arg # return src to signal 'no temp needed'
    if conv:
        typ, name, _, _ = conv # use c ior type if available
    return typ, name

def get_c_tmp2(arg):
    typ, (name, _, conv) = arg
    if conv:
        typ, _, name, _ = conv # use c ior type if available
    return typ, name

def ensure_list(a):
    if a == (): return []
    if not isinstance(a, list): return [a]
    return a

def assigns_temporary(stmts, name):
    '''
    figure out if stmts assign name
    '''
    for stmt in stmts:
        if stmt[0] == ir.stmt and stmt[1][0] == ir.assignment:
            _, lhs, rhs = stmt[1]
            
            def appears(lhs, name):
                if lhs == name:
                    return True
                if lhs[0] == ir.get_struct_item:
                    return appears(lhs[2], name)
                return False

            if appears(lhs, name):
                return True
    return False

def outarg_needs_copy(typ):
    if typ[0] == ir.pointer_type and typ[1][0] == ir.struct:
        return False
    return True

def strip_deref(a):
    if isinstance(a, tuple) and a[0] == ir.deref: 
        return a[1]
    return a

def deref_to_addr(arg, mode, idx):
    _, (a1, a2, conv) = arg
    if conv: 
        _, a1, a2, _ = conv # use c ior type if available
        r = (a1, a2)[idx]
        deref = (a1, a2)[1-idx]

    else:
        # use src, because there is no ior conversion
        r = (a1, a2)[1-idx]
        deref = r

    if isinstance(deref, tuple) and deref[0] == ir.deref: 
        return ir.Pointer_expr(r) #if arg[0][0] <> ir.struct and mode <> ir.in_ else r
    if arg[0][0] == ir.struct and mode == ir.in_: return ir.Pointer_expr(r)
    return r

def c_tempvar(arg, idx):
    typ, (a1, a2, conv) = arg
    if conv: 
        _, a1, a2, _ = conv # use c ior name if available
    return typ, (a1, a2)[idx]

def strip_derefs(lvalue):
    t, (dest, src, data) = lvalue
    return t, (strip_deref(dest), strip_deref(src), data)

#------------------------------------------------------------------------
# Test harness
#------------------------------------------------------------------------
def test_harness():
    global debug
    debug = 1
    b = bool_chpl_chpl
    #codegen((b, 'a'), rvalue_ior_c, 0,0,0,0,0)
    #codegen((cons, (b, 'a'), (b, 'b')), rvalue_ior_c, 0,0,0,0,0)
    import chapel.chpl_code as cc
    scope = cc.ChapelFile()
    c_scope = scope.cstub
    codegen((call_assign, (call, (nonvirtual_method, ir.pt_int, 'f', None), 
             (cons, (ext_chpl_chpl, 
                     babel.ir_object_type([], 'name'),
                     ('self', '_f_ior_foo')), 
              (cons, (b, '_f_ior_a', 'a'), (b, '_f_ior_b', 'b')))), #incoming
             (cons, (b, 'retval', '_f_ior_retval'), (b, 'b', '_f_ior_b'))), #outgoing
            stmt, scope, c_scope)
    #codegen((chpl.char, 'test'), ior.char, [], set(), '*')
    #reducetree(label(('chpl.Char')), 'ior.str', ior.char, [], set())
    #print
    #reducetree(label('upcast(ior.object)'), 'ior.baseobject', ior.char, [], set())

#------------------------------------------------------------------------
# Declaration of additional arguments for the rule actions
#------------------------------------------------------------------------
%action arguments: (scope, c_scope)
#------------------------------------------------------------------------
%rules:
# Rule format
# -----------
#
# chpl.vcall @ chpl <-- ior.vcall @ C : cost(1)
#   actions
#------------------------------------------------------------------------

# Naming convention
# lvalue_ior_chpl
# {nodetype}_{representation}_{language the type was created in}

# How to read these rules:
#
#    rvalue_ior_c <-- call(any_method, rvalue_ior_c) :cost(2)
#
# This is a call to a function that expects ior_c arguments 
# (IOR format, call in the C language)

#
# CLIENT
#

# lhs and rhs are swapped, so the actions are executed
# in the correct order
stmt <-- ior_call_assign(rvalue_ior_c, lvalue_chpl_c)    :cost(1)
    ftype, cstub, name, args, call_args, ci = a0

    #print args
    #print call_args
    #print

    # merge in and outargs
    outargs = map(strip_derefs, ensure_list(a1))
    inargs = filter(lambda a: a[0] <> outgoing_arg, args)
    i = 0
    allargs = []
    for arg in args:
        if arg[0] == outgoing_arg:
            allargs.append((ir.out, outargs[i]))
            i += 1
        else:
            if (arg[1][1] == outargs[i][1][0] or 
                (arg[1][1][0] == ir.deref and 
                 arg[1][1][1] == outargs[i][1][0])):
                allargs.append((ir.inout, arg))
                i += 1
            else:
                allargs.append((ir.in_, arg))

    # now that we know all of them, declare temporary variables for
    # the CHAPEL stub
    for mode, (typ, arg) in allargs:
        if arg[0] <> arg[1] or mode == ir.out:
            #print typ
            if mode == ir.out:
                # outgoing args are always passed via a temporary
                # because we don't know their type when the stub call
                # is emitted
                temp = '_ior_'+arg[0]
                scope.genh(ir.Stmt(ir.Var_decl(typ, temp)))
                if outarg_needs_copy(typ):
                    scope.gen(ir.Copy(arg[0], temp))

            else:
                scope.genh(ir.Stmt(ir.Var_decl(typ, arg[0])))

    # Stub in C:
    #
    # generate the remaining conversions (.?value_ior_c)
    #
    if len(outargs) > 0 and outargs[-1][1][0] == '_retval':
        ftype, (_, retval, convs) = outargs[-1]
        if convs: retval = convs[2]

        # always declare an _ior_retval because we will write to
        # it unconditionally
        scope.genh(ir.Stmt(ir.Var_decl(outargs[-1][0], '_ior__retval')))

    else:
        ftype = ir.pt_void


    cstub_type   = ftype
    cstub_args   = map(make_carg, allargs)
    unique_temps = set(map(get_c_tmp1, inargs)+
                       map(get_c_tmp2, outargs))
    cstub_decls  = [ir.Stmt(ir.Var_decl(*tmp)) for tmp in unique_temps 
                    if tmp[1][:5] == '_ior_'] # FIXME

    attrs = []
    join = lambda a, b: a+b
    pre_call =  reduce(join, map(c_convs,  inargs), [])
    post_call = reduce(join, map(c_convs, outargs), [])

    # generate the call to the real function implementation
    call_args1 = []
    for mode, arg in allargs:
        if mode == ir.out:
            call_args1.append(deref_to_addr(arg, mode, 1))
        else: 
            call_args1.append(deref_to_addr(arg, mode, 0))

    call = babel.vcall(name, call_args1, ci)

    if ftype <> ir.pt_void:
        if post_call:
            pre_call.append(ir.Stmt(ir.Var_decl(ftype, '_retval')))
            ior_call = [ir.Copy(retval, call)]
            if not assigns_temporary(post_call, '_retval'):
                #pre_call.append(ir.Stmt(ir.Var_decl(ftype, '_ior__retval')))
                post_call.append(ir.Copy('_retval', retval))
            post_call.append(ir.Stmt(ir.Return('_retval')))
        else:
            ior_call = [ir.Stmt(ir.Return(call))]
    else:
        ior_call = [ir.Stmt(call)]

    cstub_body0 = cstub_decls+pre_call+ior_call+post_call
    cstub_body = [s for s in (cstub_body0) if s]
    scope.cstub.gen(ir.Fn_defn(attrs, cstub_type, cstub, cstub_args, cstub_body,'remaining Stub in C'))
    scope.cstub.genh(ir.Fn_decl(attrs, cstub_type, cstub, cstub_args, 'remaining Stub in C'))
    scope.genh((ir.fn_decl, ['extern']+attrs, cstub_type, cstub, cstub_args, 'remaining Stub in C'))
    return None

# NONVIRTUAL CLIENT (technically: Stub-less clients)
# lhs and rhs are swapped, so the actions are triggered
# in the correct order
stmt <-- ior_call_assign(rvalue_ior_chpl, lvalue_chpl_chpl) :cost(1)
    inargs = a0
    inargs = ensure_list(inargs)
    outargs = map(strip_derefs, ensure_list(a1))

    # now that we know all of them, declare temporary variables for
    # the Chapel stub
    unique_temps = set(map(lambda a: (a[0], a[1][0]), inargs)+
                       map(lambda a: (a[0], a[1][1]), outargs))
    for tmp in unique_temps:
        if tmp[1][:5] == '_ior_' or tmp[1] == '_ex': #FIXME
            scope.genh(ir.Stmt(ir.Var_decl(*tmp)))
    return None

any_method <-- virtual_method : cost(0)
any_method <-- nonvirtual_method : cost(0)

# When we reach this action, the decision for using a stub was already
# made by the instruction selector.
# Call nodes take a tuple (method name, ingoing arguments)
#
# Conversion rules are expected to return a tuple
# typ, dest_name, src_name, (None | (ctype, cdest_name, csrc_name, conv))
rvalue_ior_c <-- ior_call(any_method, rvalue_ior_c) :cost(2)
    ftype, name, ci = a0
    la1 = ensure_list(a1)
    args = map(strip_derefs, la1)

    # generate the call to the C Stub
    cstub_params = map(make_stubcall_arg, args)
    cstub = '%s_%s_cStub'%('_'.join(ci.co.qualified_name), name)
    if ftype <> ir.pt_void:
        call = ir.Copy('_ior__retval', ir.Call(cstub, cstub_params))
    else:
        call = ir.Stmt(ir.Call(cstub, cstub_params))

    scope.gen(call)

    return ftype, cstub, name, args, la1, ci

# nonvirtual methods
rvalue_ior_chpl <-- ior_call(nonvirtual_method, rvalue_ior_chpl) :cost(1)
    ftype, name, ci = a0
    la1 = ensure_list(a1)
    args = map(strip_derefs, la1)
    call_args = map(lambda a: deref_to_addr(a, ir.inout, 0), la1)
    #print 'IMPLEMENT ME'
    if ftype <> ir.pt_void:
        scope.gen(ir.Copy('_ior__retval', ir.Call(name, call_args)))
    else:
        scope.gen(ir.Stmt(ir.Call(name, call_args)))

    # the outgoing pseudo-args are only there to pass the expressions in the right order
    inargs = filter(lambda a: a[0] <> outgoing_arg, args)
    #call_args = map(lambda a: deref_to_addr(a), la1)
    #call = ir.Call(a0, call_args)
    return inargs

#
# SERVER
#

# skeleton -> implementation calls
stmt <-- chpl_call_assign(rvalue_chpl_chpl, lvalue_ior_c) :cost(1)
    ftype, name, ci, call_args, inargs = a0
    inargs = ensure_list(inargs)
    outargs = map(strip_derefs, ensure_list(a1))

    # now that we know all of them, declare temporary variables for
    # the Chapel stub
    unique_temps = set(map(lambda a: c_tempvar(a, 0), inargs)+
                       map(lambda a: c_tempvar(a, 1), outargs))
    for tmp in unique_temps:
        if tmp[1] == '_ex':
            scope.cstub.genh(ir.Stmt(ir.Var_decl(ir.Pointer_type(tmp[0]),tmp[1])))
        elif tmp[1][:6] == '_chpl_':
            scope.cstub.genh(ir.Stmt(ir.Var_decl(*tmp)))

    # merge incoming and outgoing args again
    impl_params = []
    impl_decl_args = []
    i = 0
    for arg in call_args:
        if arg[0] == outgoing_arg:
            impl_decl_args.append(ir.Arg([], ir.out, outargs[i][0], outargs[i][1][1]))
            impl_params.append(deref_to_addr(outargs[i], ir.out, 1))
            i += 1
        else:
            #impl_args.append(arg)
            if (arg[1][1] == outargs[i][1][0] or 
                (arg[1][1][0] == ir.deref and 
                 arg[1][1][1] == outargs[i][1][0])):
                i += 1
                mode = ir.inout
            else:
                mode = ir.in_
            impl_decl_args.append(ir.Arg([], mode, arg[0], arg[1][0]))
            impl_params.append(deref_to_addr(arg, mode, 0))
            

    join = lambda a, b: a+b
    pre_call =  reduce(join, map(c_convs,  inargs), [])
    post_call = reduce(join, map(c_convs, outargs), [])
    # generate the call to the Chapel implementation
    #impl_params = map(lambda a: deref_to_addr(a, 0), args)
    #arg_names   = map(lambda a: strip_derefs(a)[1][1], args)

    if len(outargs) > 0 and outargs[-1][1][0] == '_retval':
        ftype, (_, retval, convs) = outargs[-1]
        if convs: ftype, _, retval, _ = convs
    else:
        ftype = ir.pt_void

    impl = '%s_%s_impl'%('_'.join(ci.co.qualified_name), name)
    call = ir.Call(impl, impl_params)

    if ftype <> ir.pt_void:
        impl_type = c_tempvar(outargs[-1], 1)[0]
        if post_call:
            pre_call.append(ir.Stmt(ir.Var_decl(ftype, '_retval')))
            impl_call = ir.Copy(retval, call)
            if not assigns_temporary(post_call, '_retval'):
                post_call.append(ir.Copy('_retval', retval))
            post_call.append(ir.Stmt(ir.Return('_retval')))
        else:
            impl_call = ir.Stmt(ir.Return(call))
    else:
        impl_type = ir.void
        impl_call = ir.Stmt(call)

    map(scope.cstub.gen, pre_call)
    scope.cstub.gen(impl_call)
    map(scope.cstub.gen, post_call)

    impldecl = (ir.fn_decl, [], impl_type, impl, impl_decl_args, 'user-defined implementation')
    ci.chpl_skel.cstub.gen(impldecl)


    return None

# skeleton -> impl method calls
rvalue_chpl_chpl <-- chpl_call(any_method, rvalue_chpl_chpl) :cost(1)
    ftype, name, ci = a0
    la1 = ensure_list(a1)
    args = map(strip_derefs, la1)

    # the outgoing pseudo-args are only there to pass the expressions in the right order
    inargs = filter(lambda a: a[0] <> outgoing_arg, args)

    return ftype, name, ci, args, inargs


#
# FUSION
#

stmt <-- call(method, rvalue_native_fortran) :cost(1)
    # not yet implemented!
    gen_tmp_vardecls(scope, list(a1))
    scope.gen(ir.Call('%s_fuse'%a0, a1))

#
# MISCELLANEOUS
#

lvalue_ior_c            <-- cons(lvalue_ior_c,     lvalue_ior_c)     : cost(0)
    return Cons(a0, a1)                                              
                                                                     
lvalue_ior_chpl         <-- cons(lvalue_ior_chpl,  lvalue_ior_chpl)  : cost(0)
    return Cons(a0, a1)

lvalue_chpl_c           <-- cons(lvalue_chpl_c,    lvalue_chpl_c)    : cost(0)
    return Cons(a0, a1)

rvalue_ior_c            <-- cons(rvalue_ior_c,     rvalue_ior_c)     : cost(0)
    return Cons(a0, a1)                                              
                                                                     
rvalue_ior_chpl         <-- cons(rvalue_ior_chpl,  rvalue_ior_chpl)  : cost(0)
    return Cons(a0, a1)

rvalue_chpl_chpl        <-- cons(rvalue_chpl_chpl, rvalue_chpl_chpl) : cost(0)
    return Cons(a0, a1)


# this is a pseudo-arg to have all arguments (including the outgoing
# ones) appear in the right order in the call rule
rvalue_ior_c     <-- outgoing_arg  :cost(0)
    return outgoing_arg, a0

rvalue_chpl_chpl <-- outgoing_arg  :cost(0)
    return outgoing_arg, a0

rvalue_ior_chpl  <-- outgoing_arg  :cost(0)
    return outgoing_arg, a0

rvalue_chpl_c    <-- outgoing_arg  :cost(0)
    return outgoing_arg, a0

# this conversion is essentially a no-op; it says that values
# converted at the chpl level are also compatible with a stub
# DO NOT UNCOMMENT THESE, cf. *assign*
# (leave them commented here, so nobody gets the idea to write rules like this)
#value_ior_c     <-- value_ior_chpl   :cost(0)
#value_ior_chpl  <-- value_ior_c      :cost(0)
#value_chpl_c    <-- value_chpl_chpl  :cost(0)
#value_chpl_chpl <-- value_chpl_c     :cost(0)
# END DO NOT UNCOMMENT

# Why is there a distinction between rvalue and lvalue?  
# No technical reason. They only serve to make the call rules more
# readable.
lvalue_ior_c     <-- value_ior_c    :cost(0)
rvalue_ior_c     <-- value_ior_c    :cost(0)
lvalue_ior_chpl  <-- value_ior_chpl :cost(0)
rvalue_ior_chpl  <-- value_ior_chpl :cost(0)
lvalue_chpl_c    <-- value_chpl_c   :cost(0)
rvalue_chpl_c    <-- value_chpl_c   :cost(0)
lvalue_chpl_chpl <-- value_chpl_chpl:cost(0)
rvalue_chpl_chpl <-- value_chpl_chpl:cost(0)

value_chpl_c    <-- bool_chpl_c   :cost(0) 
value_ior_c     <-- bool_ior_c    :cost(0) 
value_chpl_chpl <-- bool_chpl_chpl:cost(0) 
value_ior_chpl  <-- bool_ior_chpl :cost(0) 

value_chpl_c    <-- char_chpl_c   :cost(0) 
value_ior_c     <-- char_ior_c    :cost(0) 
value_chpl_chpl <-- char_chpl_chpl:cost(0) 
value_ior_chpl  <-- char_ior_chpl :cost(0) 

value_chpl_c    <-- string_chpl_c   :cost(0) 
value_ior_c     <-- string_ior_c    :cost(0) 
value_chpl_chpl <-- string_chpl_chpl:cost(0) 
value_ior_chpl  <-- string_ior_chpl :cost(0) 

value_chpl_c    <-- int_chpl_c   :cost(0) 
value_ior_c     <-- int_ior_c    :cost(0) 
value_chpl_chpl <-- int_chpl_chpl:cost(0) 
value_ior_chpl  <-- int_ior_chpl :cost(0) 

value_chpl_c    <-- long_chpl_c   :cost(0) 
value_ior_c     <-- long_ior_c    :cost(0) 
value_chpl_chpl <-- long_chpl_chpl:cost(0) 
value_ior_chpl  <-- long_ior_chpl :cost(0) 

value_chpl_c    <-- float_chpl_c   :cost(0) 
value_ior_c     <-- float_ior_c    :cost(0) 
value_chpl_chpl <-- float_chpl_chpl:cost(0) 
value_ior_chpl  <-- float_ior_chpl :cost(0) 

value_chpl_c    <-- double_chpl_c   :cost(0) 
value_ior_c     <-- double_ior_c    :cost(0) 
value_chpl_chpl <-- double_chpl_chpl:cost(0) 
value_ior_chpl  <-- double_ior_chpl :cost(0) 

value_chpl_c    <-- fcomplex_chpl_c   :cost(0) 
value_ior_c     <-- fcomplex_ior_c    :cost(0) 
value_chpl_chpl <-- fcomplex_chpl_chpl:cost(0) 
value_ior_chpl  <-- fcomplex_ior_chpl :cost(0) 

value_chpl_c    <-- dcomplex_chpl_c   :cost(0) 
value_ior_c     <-- dcomplex_ior_c    :cost(0) 
value_chpl_chpl <-- dcomplex_chpl_chpl:cost(0) 
value_ior_chpl  <-- dcomplex_ior_chpl :cost(0) 

value_chpl_c    <-- opaque_chpl_c      :cost(0) 
value_ior_c     <-- pointer_type_ior_c :cost(0) 
value_chpl_chpl <-- opaque_chpl_chpl   :cost(0) 
value_ior_chpl  <-- pointer_type_ior_chpl :cost(0) 
                 
value_chpl_c    <-- enum_chpl_c     :cost(0) 
value_ior_c     <-- enum_ior_c      :cost(0) 
value_chpl_chpl <-- enum_chpl_chpl  :cost(0) 
value_ior_chpl  <-- enum_ior_chpl   :cost(0) 

# STRUCTS
# -------

# structs have either all-xeroxed or all-original items
value_chpl_c    <-- struct(typ, dvalue_chpl_c)    :cost(0)
    #print 'dstruct_chpl_c: ', a0
    return copy_over(*a0)
value_ior_c     <-- struct(typ, dvalue_ior_c)     :cost(0) 
    #print 'dstruct_ior_c: ', a0
    return copy_over(*a0)
value_chpl_chpl <-- struct(typ, dvalue_chpl_chpl) :cost(0) 
    #print 'dstruct_chpl_chpl: ', a0
    return copy_over(*a0)
value_ior_chpl  <-- struct(typ, dvalue_ior_chpl)  :cost(0) 
    #print 'dstruct_ior_chpl: ', a0
    return copy_over(*a0)
# the cost for this is so high, that even a struct with the max number
# of items (~ 127, a limitation of certain Java implementations on the
# maximum number of arguments a function can take) will not
# accidentally be converted from an xstruct to dstruct. Remember, the
# idea is that once any item in the struct is an x-item, all items
# must be copied.
value_chpl_c    <-- struct(typ, xvalue_chpl_c)    :cost(128) 
    #print 'xerox_struct_chpl_c: ', a0
    return xerox_struct(a0, a1)
value_ior_c     <-- struct(typ, xvalue_ior_c)     :cost(128) 
    #print 'xerox_struct_ior_c: ', a0
    return xerox_struct(a0, a1)
value_chpl_chpl <-- struct(typ, xvalue_chpl_chpl) :cost(128) 
    #print 'xerox_struct_chpl_chpl: ', a0
    return xerox_struct(a0, a1)
value_ior_chpl  <-- struct(typ, xvalue_ior_chpl)  :cost(128) 
    #print 'xerox_struct_ior_chpl: ', a0
    return xerox_struct(a0, a1)

# xvalue is a xerox'd value (tmp copy of all items)
xvalue_ior_c    <-- item(xvalue_ior_c, xvalue_ior_c)     : cost(0)
    #print 'xvalue_ior_c: ', a0
    return Cons(a0, a1)                                              

xvalue_chpl_c   <-- item(xvalue_chpl_c, xvalue_chpl_c)   : cost(0)
    #print 'xvalue: ', a0
    return Cons(a0, a1)                                              

xvalue_ior_chpl <-- item(xvalue_ior_chpl, xvalue_ior_chpl)  : cost(0)
    #print 'xvalue_ior_chpl: ', a0
    return Cons(a0, a1)                                              

xvalue_chpl_chpl<-- item(xvalue_chpl_chpl, xvalue_chpl_chpl) : cost(0)
    #print 'xvalue_chpl_chpl: ', a0
    return Cons(a0, a1)                                              


# xerox a value
xvalue_ior_c    <-- value_ior_c : cost(10)
    (t, (chpl_dest, chpl_src, convs)) = a0
    if convs:
        c_t, c_dest, c_src, c_convs = convs
        return (t, (chpl_dest, chpl_src, (c_t, c_dest, c_src, #[ir.Copy(c_dest, c_src)]+
                        c_convs)))
    else:
        return (t, (chpl_dest, chpl_src, (t, chpl_dest, chpl_src, [ir.Copy(chpl_dest, chpl_src)])))

xvalue_chpl_c   <-- value_chpl_c : cost(10)
    (t, (chpl_dest, chpl_src, convs)) = a0
    if convs:
        c_t, c_dest, c_src, c_convs = convs
        return (t, (chpl_dest, chpl_src, (c_t, c_dest, c_src, #[ir.Copy(c_dest, c_src)]+
                            c_convs)))
    else:
        return (t, (chpl_dest, chpl_src, (t, chpl_dest, chpl_src, [ir.Copy(chpl_dest, chpl_src)])))

xvalue_chpl_chpl<-- value_chpl_chpl : cost(10)
    (t, (dest, src, convs)) = a0 
    scope.gen(ir.Copy(dest, src))
    return a0

xvalue_ior_chpl <-- value_ior_chpl : cost(10)
    (t, (dest, src, convs)) = a0 
    scope.gen(ir.Copy(dest, src))
    return a0

# direct unmodified value
dvalue_ior_c    <-- item(dvalue_ior_c,  dvalue_ior_c)          : cost(0)
    #print 'dvalue_ior_c: ', a0
    return Cons(a0, a1)                                        
dvalue_chpl_c   <-- item(dvalue_chpl_c, dvalue_chpl_c)         : cost(0)
    #print 'dvalue: ', a0
    return Cons(a0, a1)                                            
dvalue_ior_chpl   <-- item(dvalue_ior_chpl,  dvalue_ior_chpl)  : cost(0)
    #print 'dvalue_ior_chpl: ', a0
    return Cons(a0, a1)                                              
dvalue_chpl_chpl  <-- item(dvalue_chpl_chpl, dvalue_chpl_chpl) : cost(0)
    #print 'dvalue_chpl_chpl: ', a0
    return Cons(a0, a1)                                              

#value_chpl_c    <-- struct_chpl_c(dvalue_chpl_c)       :cost(0) 
#value_ior_c     <-- struct_ior_c(dvalue_ior_c)         :cost(0) 
#value_chpl_chpl <-- struct_chpl_chpl(dvalue_chpl_chpl) :cost(0) 
#value_ior_chpl  <-- struct_ior_chpl(dvalue_ior_chpl)   :cost(0) 
# 
#value_chpl_c    <-- struct_chpl_c(xvalue_chpl_c)       :cost(0) 
#value_ior_c     <-- struct_ior_c(xvalue_ior_c)         :cost(0) 
#value_chpl_chpl <-- struct_chpl_chpl(xvalue_chpl_chpl) :cost(0) 
#value_ior_chpl  <-- struct_ior_chpl(xvalue_ior_chpl)   :cost(0) 
                 
value_chpl_c    <-- array_chpl_c   :cost(0) 
value_ior_c     <-- array_ior_c    :cost(0) 
value_chpl_chpl <-- array_chpl_chpl:cost(0) 
value_ior_chpl  <-- array_ior_chpl :cost(0) 
                 
value_chpl_c    <-- rarray_chpl_c   :cost(0) 
value_ior_c     <-- rarray_ior_c    :cost(0) 
value_chpl_chpl <-- rarray_chpl_chpl:cost(0) 
value_ior_chpl  <-- rarray_ior_chpl :cost(0) 

value_chpl_c    <-- ext_chpl_c    :cost(0) 
value_ior_c     <-- ext_ior_c     :cost(0)
value_chpl_chpl <-- ext_chpl_chpl :cost(0) 
value_ior_chpl  <-- ext_ior_chpl  :cost(0) 

# SELF
#------------------------------------------------------------------------
# baseobject_AT_C_ior_chpl <-- upcast(chpl.baseobject): cost(1)
#     # We should find a cleaner way of implementing this
#     #if src == 'self' and member_chk(ir.pure, attrs):
#     import pdb; pdb.set_trace()
#     c_scope.gen(ir.Copy(dest, '(({0})((struct sidl_BaseInterface__object*)self)<--d_object)'.format(c_gen(typ))))
#     return dest

# OBJECTS
#------------------------------------------------------------------------
# conversion is handled in Chapel, ior-chpl -> ior-c is identity
ext_ior_chpl    <-- ext_ior_c    :cost(0)
ext_ior_c       <-- ext_ior_chpl    :cost(0)
ext_chpl_c      <-- ext_chpl_chpl :cost(0)
#ext_chpl_chpl   <-- ext_chpl_c    :cost(0)

ext_ior_chpl    <-- ext_chpl_chpl:cost(1)
    t, (dest, src, conv) = a0
    ptr, (struct, s_id, items, doc) = t
    h_t = ptr, (struct, hashable(s_id), (), doc)

    # hardcoded: Babel exception argument, SERVER-side
    if src == '_ex':
        scope.cstub.gen(ir.Copy(dest, src))
        return h_t, (dest, src, conv)

    name = s_id[2]# +s_id[3] hijacked for '__object'
    scope.gen(ir.Copy(dest, access(src, 'self_'+name)))
    return h_t, (dest, src, conv)

ext_chpl_chpl <-- ext_ior_chpl :cost(1)
    t, (dest, src, conv) = a0
    ptr, (struct, s_id, items, doc) = t
    h_t = ptr, (struct, hashable(s_id), (), doc)

    # hardcoded: Babel exception argument, CLIENT-side
    if src == '_ior__ex':
        scope.gen(ir.Stmt(ir.If(
                    ir.Call("IS_NOT_NULL", ['_ior__ex']), 
                    [ir.Copy('_ex', ir.Call("new BaseInterface", ['_ior__ex']))])))
        return h_t, (dest, src, conv)

    # hardcoded: self argument, SERVER-side
    if src == 'self':
        scope.cstub.gen(ir.Copy(dest, access(ir.Deref(src), 'd_data')))
        return ir.void_ptr, (dest, src, conv)
 
    # regular object with unknown implementation language (interface/class)

    # drop the id's extension, which we hijacked for '__object'
    s_id1 = ir.Scoped_id(s_id[1], s_id[2], '')
    name = s_id[2]
    #mod_name = '.'.join(full_type[1]+[name])
    wrap = ir.Call('%s_static.wrap_%s' %(babel.qual_id(s_id1, '.'), name), [src, '_ex'])
    scope.gen(ir.Copy(dest, wrap))
    return h_t, (dest, src, conv)

# BOOL
#------------------------------------------------------------------------
bool_chpl_c      <-- bool_chpl_chpl :cost(0)
bool_chpl_chpl   <-- bool_chpl_c    :cost(0)
xvalue_ior_c     <-- bool_ior_c     :cost(0)

bool_ior_c      <-- bool_chpl_c: cost(1)
    dest, src, conv = a0
    t = ir.Typedef_type('chpl_bool')
    conv += [ir.Comment('sidl_bool is an int, but chapel bool is a char/_Bool'),
             ir.Copy(dest,'(%s)%s'%(c_gen(ir.pt_int),c_gen(src)))]
    return t, (dest, src, (ir.pt_int, dest, src, conv))

bool_chpl_c <-- bool_ior_c: cost(1)
    dest, src, conv = a0
    t = ir.Typedef_type('chpl_bool')
    conv += [ir.Comment('sidl_bool is an int, but chapel bool is a char/_Bool'),
             ir.Copy(dest,'(%s)%s'%(c_gen(t),c_gen(src)))]
    return t, (dest, src, (ir.pt_int, dest, src, conv))

bool_ior_chpl   <-- bool_chpl_chpl: cost(3)
    dest, src, conv = a0
    import pdb; pdb.set_trace()
    t = ir.Typedef_type('chpl_bool')
    conv += [ir.Copy(dest, ir.Call("convert_bool_chpl_to_ior", [src]))]
    return t, (dest, src, (ir.pt_int, dest, src, conv))



# CHAR
#------------------------------------------------------------------------
char_chpl_c      <-- char_chpl_chpl :cost(0)
char_chpl_chpl   <-- char_chpl_c    :cost(0)
#char_ior_c       <-- char_ior_chpl  :cost(0)
char_ior_chpl    <-- char_ior_c     :cost(0)
xvalue_ior_c     <-- char_ior_c     :cost(0)

char_ior_c <-- char_chpl_c : cost(1)
    dest, src, conv = a0
    conv += [ir.Comment('in chapel, a char is a string of length 1'),
             ir.Copy(dest, ir.Deref(src))] # deref takes 1st char of string
    c_scope.optional.add(char_lut)
    return ir.pt_string, (dest, src, (ir.pt_char, dest, src, conv))

char_chpl_c <-- char_ior_c : cost(1)
    dest, src, conv = a0
    conv.append(ir.Comment('in chapel, a char is a string of length 1'))
    # we can't allocate a new string, this would leak memory
    conv.append(ir.Copy(dest, '(const char*)&chpl_char_lut[2*(unsigned char)%s]'%c_gen(src)))
    c_scope.optional.add(char_lut)
    return ir.pt_string, (dest, src, (ir.pt_char, dest, src, conv))

# COMPLEX - 32/64 Bit components
#------------------------------------------------------------------------
fcomplex_chpl_c      <-- fcomplex_chpl_chpl :cost(0)
fcomplex_chpl_chpl   <-- fcomplex_chpl_c    :cost(0)
fcomplex_ior_chpl    <-- fcomplex_ior_c     :cost(0)
xvalue_ior_c         <-- fcomplex_ior_c     :cost(0)
dcomplex_chpl_c      <-- dcomplex_chpl_chpl :cost(0)
dcomplex_chpl_chpl   <-- dcomplex_chpl_c    :cost(0)
dcomplex_ior_chpl    <-- dcomplex_ior_c     :cost(0)
xvalue_ior_c         <-- dcomplex_ior_c     :cost(0)

fcomplex_ior_c <-- fcomplex_chpl_c : cost(2)
    dest, src, conv = a0
    conv.append(ir.Copy(access(dest, 'real'),access(src, 're')))
    conv.append(ir.Copy(access(dest, 'imaginary'),access(src, 'im')))
    return ir.Typedef_type('_complex64'), (dest, src, (ir.pt_fcomplex, dest, src, conv))

dcomplex_ior_c <-- dcomplex_chpl_c : cost(2)
    dest, src, conv = a0
    conv.append(ir.Copy(access(dest, 'real'),access(src, 're')))
    conv.append(ir.Copy(access(dest, 'imaginary'),access(src, 'im')))
    return ir.Typedef_type('_complex128'), (dest, src, (ir.pt_dcomplex, dest, src, conv))

fcomplex_chpl_c <-- fcomplex_ior_c : cost(2)
    dest, src, conv = a0
    conv.append(ir.Copy(access(dest, 're'),access(src, 'real')))
    conv.append(ir.Copy(access(dest, 'im'),access(src, 'imaginary')))
    return ir.Typedef_type('_complex64'), (dest, src, (ir.pt_fcomplex, dest, src, conv))

dcomplex_chpl_c <-- dcomplex_ior_c : cost(2)
    dest, src, conv = a0
    conv.append(ir.Copy(access(dest, 're'),access(src, 'real')))
    conv.append(ir.Copy(access(dest, 'im'),access(src, 'imaginary')))
    return ir.Typedef_type('_complex128'), (dest, src, (ir.pt_dcomplex, dest, src, conv))

# ENUM
#------------------------------------------------------------------------
enum_chpl_c      <-- enum_chpl_chpl :cost(0)
enum_chpl_chpl   <-- enum_chpl_c    :cost(0)
xvalue_ior_c     <-- enum_ior_c     :cost(0)
enum_ior_c <-- enum_chpl_c : cost(1)
    t, (dest, src, orig) = a0
    # No special treatment for enums, rely on chpl runtime to set it
    return t, (dest, src, (t, dest, src, [ir.Copy(dest, ir.Sign_extend(64, src))]))

enum_chpl_c <-- enum_ior_c : cost(1)
    t, (dest, src, orig) = a0
    return t, (dest, src, (t, dest, src, [ir.Copy(dest, src)]))

# STRING
#------------------------------------------------------------------------
string_chpl_c      <-- string_chpl_chpl :cost(0)
string_chpl_chpl   <-- string_chpl_c    :cost(0)
xvalue_ior_c       <-- string_ior_c     :cost(0)
# DO NOT UNCOMMENT THE FOLLOWING LINE
#string_ior_chpl    <-- string_ior_c     :cost(0)
string_ior_c <-- string_chpl_c : cost(0)
    dest, src, conv = a0
    return ir.pt_string, (dest, src, (ir.pt_string, dest, src, [ir.Copy(dest, src)]))

string_chpl_c <-- string_ior_c : cost(1)
    dest, src, conv = a0
    # Convert null pointer into empty string
    conv.append(ir.Stmt(ir.If(src, [ir.Copy(src, '""')])))
    conv.append(ir.Copy(dest, src))
    return ir.pt_string, (dest, src, (ir.pt_string, dest, src, conv))

# INT
#------------------------------------------------------------------------
int_chpl_c      <-- int_chpl_chpl :cost(0)
int_chpl_chpl   <-- int_chpl_c    :cost(0)
int_ior_chpl    <-- int_ior_c     :cost(0)

int_ior_c <-- int_chpl_c : cost(0)
    return copy_over(ir.pt_int, a0)

int_chpl_c <-- int_ior_c : cost(0)
    return copy_over(ir.pt_int, a0)

# LONG
#------------------------------------------------------------------------
long_chpl_c      <-- long_chpl_chpl :cost(0)
long_chpl_chpl   <-- long_chpl_c    :cost(0)
long_ior_chpl    <-- long_ior_c     :cost(0)

long_ior_c <-- long_chpl_c : cost(0)
    return copy_over(ir.pt_long, a0)
long_chpl_c <-- long_ior_c : cost(0)
    return copy_over(ir.pt_long, a0)

# FLOAT
#------------------------------------------------------------------------
float_chpl_c      <-- float_chpl_chpl :cost(0)
float_chpl_chpl   <-- float_chpl_c    :cost(0)
float_ior_chpl    <-- float_ior_c     :cost(0)

float_ior_c <-- float_chpl_c : cost(0)
    return copy_over(ir.pt_float, a0)
float_chpl_c <-- float_ior_c : cost(0)
    return copy_over(ir.pt_float, a0)

# DOUBLE
#------------------------------------------------------------------------
double_chpl_c      <-- double_chpl_chpl :cost(0)
double_chpl_chpl   <-- double_chpl_c    :cost(0)
double_ior_chpl    <-- double_ior_c     :cost(0)
double_ior_c <-- double_chpl_c : cost(0)
    return copy_over(ir.pt_double, a0)
double_chpl_c <-- double_ior_c : cost(0)
    return copy_over(ir.pt_double, a0)


# VOID return type
#------------------------------------------------------------------------
void_chpl_c      <-- void_chpl_chpl :cost(0)
void_chpl_chpl   <-- void_chpl_c    :cost(0)
void_chpl_c <-- void_ior_c :cost(0)
    return copy_over(ir.pt_void, a0)
void_ior_c <-- void_chpl_c :cost(0)
    return copy_over(ir.pt_void, a0)

# OPAQUE
#------------------------------------------------------------------------
opaque_chpl_c    <-- opaque_chpl_chpl     :cost(0)
opaque_chpl_chpl <-- opaque_chpl_c        :cost(0)
opaque_chpl_c    <-- pointer_type_ior_c   :cost(0)
    #print 'opaque <-- pointer: ', a0
    return copy_over(ir.void_ptr, a0)
pointer_type_ior_c <-- opaque_chpl_c      :cost(0)
    #print 'opaque --> pointer: ', a0
    return copy_over(ir.void_ptr, a0)

# FIXME:
# pointer_type_AT_C_chpl_chpl <-- ior.*
#   a0 = ir.Pointer_expr(a0)

# SIDL ARRAY
#------------------------------------------------------------------------
# Conversion handled in Chapel

array_chpl_c     <-- array_chpl_chpl :cost(0)
array_chpl_chpl  <-- array_chpl_c    :cost(0)
array_ior_c      <-- array_ior_chpl  :cost(0)
array_ior_chpl   <-- array_ior_c     :cost(0)
xvalue_ior_c     <-- array_ior_c     :cost(0)

# for sidl arrays we invoke a chapel code fragment from the C stub
array_chpl_chpl <-- array_ior_chpl: cost(1)
    t, (dest, src, convs) = a0
    #print a0
    chpl_scalar_type, scalar_type = get_ior_array_type(t)
    if scalar_type == ir.void_ptr:
        # generic array
        #scope.gen(ir.Copy(dest, ir.Call("generic_ptr", [src])))
        scope.gen(ir.Copy(dest, src))
        return t, (dest, src, convs)

    #scope.gen(ir.Copy(dest, ir.Call('sidl.wrap_%s_array'%scalar_type, [src])))
    scope.gen(ir.Copy(dest, (ir.new, 'sidl.Array',
                             [chpl_scalar_type, t[1][1], src])))

    return array_ior_type(t), (dest, src, convs)
    #return t, (dest, src, None)

# now part of sidl.chpl:
#    skel.gen(ir.Fn_defn(
#            [], ir.pt_void, '%s_to_chpl'%fu_type, 
#            [ir.Arg([], ir.in_, full_type, 'ior')],
#            [ir.Stmt((ir.new, 'sidl.Array', [scalar_type, full_type, dest]))],
#            'argument conversion codelet'))


array_ior_chpl <-- array_chpl_chpl: cost(1)
    t, (dest, src, _) = a0
    _, scalar_type = get_ior_array_type(t)
    if scalar_type == ir.void_ptr:
        # generic array
        #scope.gen(ir.Copy(dest, ir.Call("ptr_generic", [src])))
        scope.gen(ir.Copy(dest, src))
        return t, (dest, src, None)

    scope.gen(ir.Copy(dest, access(src, 'ior')))
    #return t, (dest, src, None)
    return array_ior_type(t), (dest, src, None)

#array_ior_c <-- array_chpl_chpl : cost(1)
#    scalar_type = get_array_type(full_type)
#    conv.append((ir.stmt, '{dest} = ({typ}){n}.self'
#                  .format(dest=dest, n=a0, typ=scalar_type)))

    # wrap the C type in a native Chapel object
    #if mode == sidl.inout:
    #    pre_call.append(ir.Copy(iorname, name+'.self'))

                    
    # if name == '_retval':
    #     return_expr.append(conv)
    # else:
    #     post_call.append(ir.Copy(name, conv))

# RAW ARRAY
#------------------------------------------------------------------------
rarray_ior_chpl  <-- rarray_ior_c    :cost(0)
rarray_ior_c     <-- rarray_ior_chpl :cost(0)
rarray_chpl_c    <-- rarray_chpl_chpl:cost(0)

rarray_item_chpl_c  <-- rarray_item_chpl_chpl:cost(1)
    t, (dest, src, conv) = a0
    _, scalar_type = get_ior_array_type(t)
    scope.gen(ir.Copy(dest, access(src, 'ior')))
    return t, (dest, src, conv)

array_ior_c         <-- rarray_item_ior_c    :cost(1)
    t, (dest, src, _) = a0
    rarray, basetype, dim, exts = t
    pre = re.sub(r'[^a-zA-Z0-9]+', '_', c_gen(dest))+'_'
    
    conv = ([
        ir.Stmt(ir.Var_decl(ir.pt_int, pre+'lower[1]')),
        ir.Stmt(ir.Var_decl(ir.pt_int, pre+'upper[1]')),
        ir.Stmt(ir.Var_decl(ir.pt_int, pre+'stride[1]')),
        ir.Copy(pre+'lower[0]', 0)]+
        [ir.Copy(pre+'upper[%d]'%i, ir.simpleint_expr(c_gen(src[2])+'.', exts[i])) 
         for i in range(len(exts))]+
        [ir.Copy(pre+'stride[0]', 1),
        ir.Copy(dest, ir.Call('sidl_%s__array_borrow'%c_gen(basetype),
                              [src, dim, pre+'lower', pre+'upper', pre+'stride']))
        ])
    c_scope.optional.add(str(c_gen(ir.Import('sidlArray'))))
    at = get_raw_ior_array_type(t)[1]
    return at, (dest, src, (at, dest, src, conv))

xvalue_ior_c <-- rarray_item_chpl_c    :cost(1)
    t, (dest, src, conv) = a0
    rarray, basetype, dim, exts = t
    cbasetype = c_gen(basetype)
    p_src = ir.Call('sidlArrayAddr1', [src, 0])
    if sidl.fixed_rarray(exts):
        conv.append(ir.Comment('copy array data unless the sidl array '+
                               'happens to be borrowed from the original'))
        # build an expression for the size of the array
        basesize = ir.Call('sizeof', [cbasetype])
        n = reduce(lambda a, b: ir.Infix_expr(ir.times, a, b), exts, basesize)
        conv.append(ir.Stmt(ir.If(ir.Infix_expr(ir.ne, dest, p_src),
                                  [ir.Stmt(ir.Call('memcpy', [dest, p_src, n]))])))
        c_scope.optional.add(str(c_gen(ir.Import('string'))))

    else:
        conv.append(ir.Copy(dest, p_src))
    conv.append(ir.Stmt(ir.Call('sidl_%s__array_delete_ref'%cbasetype, [src])))
    c_scope.optional.add(str(c_gen(ir.Import('sidlArray'))))
    c_scope.optional.add(str(c_gen(ir.Import('sidl_%s_IOR'%cbasetype))))
    at = get_raw_ior_array_type(t)[1]
    return at, (dest, src, (at, dest, src, conv))


rarray_ior_chpl <-- rarray_chpl_chpl: cost(1)
    t, (dest, src, conv) = a0
    _, array_t = get_raw_ior_array_type(t)
    wrap_rarray(scope, strip_deref(src), t, dest)
    return array_t, (dest, src, conv)

rarray_chpl_chpl <-- rarray_ior_chpl :cost(1)
    t, (dest, src, conv) = a0
    _, array_t = get_raw_ior_array_type(t)

    # emit code to copy back elements into non-local array
    name = c_gen(src[1] if src[0] == ir.deref else src).replace('.', '_')
    sarray = "_braid_wrapped_local_%s_sarray"%name
    barray = "_babel_wrapped_local_%s_barray"%name
    sarr = (ir.call, "new Array", [access(dest, 'eltType'), array_t, src])
    barr = ir.Call("createBorrowedArray{dim}d".format(dim=t[2]), [sarray])
    scope.gen(ir.Copy('var ' + sarray, sarr))
    scope.gen(ir.Copy('var ' + barray, barr))
    scope.gen(ir.Stmt(ir.Call('syncNonLocalArray', [barray, dest])))
#    print array_t
#    import pdb; pdb.set_trace()
    return array_t, (dest, src, conv)

