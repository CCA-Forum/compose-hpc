# -*- python -*-
# Process this file with burg.py
## @package chapel.conversions
#
# BURG-style low-level type conversion rules for IOR <-> Chapel.
#
# Please report bugs to <adrian@llnl.gov>.
#
# Calls are modeled as follows:
# <pre>
# bool f(in a:int, inout b:char)
#
#              assign
#              /    \
#            cons   call
#            /  \    / \
#          ret  b   f  cons
#                      /  \
#                     a    b
#
# rules can be
# chpl <-- cons(chpl, chpl)
#
# </pre> 
#
# \authors <pre>
#
# Copyright (c) 2011, 2012 Lawrence Livermore National Security, LLC.
# Produced at the Lawrence Livermore National Laboratory
# Written by Adrian Prantl <adrian@llnl.gov>.
#
# LLNL-CODE-473891.
# All rights reserved.
#
# This file is part of BRAID. For details, see
# http://compose-hpc.sourceforge.net/.
# Please read the COPYRIGHT file for Our Notice and
# for the BSD License.
#
# </pre>


#------------------------------------------------------------------------
import babel, ior, ir, sidl
import chapel.chpl as chpl
from codegen import CCodeGenerator, CFile

def c_gen(ir, scope=None):
    if scope == None:
        scope = CFile()
    return CCodeGenerator().generate(ir, scope)

def ir_type_to_chpl(typ):
    """
    Convert only the datatype \c typ into its chapel equivalent
    TODO: could we also generate this from the spec below?
    """
    mapping = {
        ir.pt_void:     ir.pt_void,
        ir.pt_bool:     ir.Typedef_type('chpl_bool'),
        ir.pt_string:   ir.const_str,
        ir.pt_int:      ir.pt_int, #ir.Typedef_type('int32_t'),
        ir.pt_long:     ir.pt_long, #ir.Typedef_type('int64_t'),
        ir.pt_char:     ir.const_str,
        ir.pt_fcomplex: ir.Typedef_type('_complex64'), 
        ir.pt_dcomplex: ir.Typedef_type('_complex128'),
        ir.pt_float:    ir.pt_float,
        ir.pt_double:   ir.pt_double,
        sidl.pt_opaque: ir.Pointer_type(ir.pt_void)
        }
    try:
        return mapping[typ]
    except:
        if typ[0] == ir.enum: 
            # the types need to be dissimilar, even if they have the same name
            enum, name, items, comment = typ
            return enum, name, items, 'chpl '+comment
        if typ[0] == ir.typedef_type and typ[1] == 'sidl_bool': 
            import pdb; pdb.set_trace()
            return ir.Typedef_type('chpl_bool')
        if typ[0] == 'upcast':
            # part of the hack for self dereferencing
            return typ[1]
        if typ[0] == ir.pointer_type:
            return ir.Pointer_type(ir_type_to_chpl(typ[1]))

        if typ[0] == ir.struct:
            _, name, items, comment = typ
            items1 = map(ir_type_to_chpl, items)
            # User-defined structs are created in the IOR with an
            # '__data' suffix, so we can use the actual name for the
            # Chapel version of the struct.
            if name[-6:] == '__data': 
                name = name[:-6] # Wow, is this unelegant!

            return ir.Struct(name, items1, comment)

        if typ[0] == ir.struct_item:
            return ir.Struct_item(ir_type_to_chpl(typ[1]),typ[2])

        if typ[0] == sidl.array:
            return get_array_type(typ)[1]

        if typ[0] == sidl.rarray:
            return get_array_type(typ)[1]

        return typ


def strip(typ):
    if typ[0] == ir.pointer_type and typ[1][0] == ir.struct:
        return ir.struct
    # strip unnecessary details from aggregate types
    if (typ[0] == sidl.class_ or 
        typ[0] == sidl.interface):
        return ior.ext
    if (typ[0] == ir.enum or
        typ[0] == ir.rarray or
        typ[0] == ir.pointer_type or
        typ[0] == ir.struct):
        return typ[0]
    return typ

def copy_other_items(convs, items, a0, dest):
    """
    copy all struct items that need not to be converted
    """
    for _, typ, name in items:
        if typ[0] == ir.struct:
            copy_other_items(convs, ir.struct_struct_items(typ), a0+name+'.', dest+'.'+name)

        if ir_type_to_chpl(typ) == typ: # boy, is this inefficient!!
            convs.append(ir.Stmt(ir.Assignment(dest+'.'+name, a0+name)))

def get_struct_items(full_type):
    t = full_type[1] if full_type[0] == ir.pointer_type else full_type
    return ir.struct_struct_items(t) 


def elem_access(typ):
    if typ[0] == ir.struct:
        return '.'
    else: return ''

def get_array_type(full_type):
   if full_type[1] == []:
       t = ''
   elif full_type[1][0] == ir.scoped_id:
       t = '_BaseInterface'
   else:
       t = '_'+full_type[1][1]
   name = 'sidl%s__array'%t
   iortype = ir.Pointer_type(ir.Struct(name, (), ''))
   return name, iortype 

def get_ior_array_type(sidl_array):
    struct_name = sidl_array[1][1]
    m = babel.sidl_array_regex.match(struct_name)
    return m.group(1) if m else ir.void_ptr


def wrap_rarray(convs, a0, fulltype, dest):
    data  = '_braid_%s_data'  %a0
    dom   = '_braid_%s_dom'   %a0
    local = '_braid_%s_local' %a0
    scalar_type = fulltype[1][1]
    iortype = ir.Typedef_type('sidl_%s__array'%scalar_type)

    # sanity check on input array: ensure domain is rectangular
    convs.append(ir.Stmt(ir.Call('performSanityCheck', [dom, '"%s"'%a0])))

    # ensure we are working with a 'local' array
    # FIXME Hack to define a variable without explicitly specifying type
    # should we change the IR to support this?
    convs.append(ir.Stmt(ir.Assignment('var ' + data,
                                      ir.Call("getOpaqueData", [ir.Call(a0, [dom+'.low'])]))))
    convs.append(ir.Stmt(ir.Assignment('var ' + local,
                                      ir.Call("ensureLocalArray", [a0, data]))))

                    
    # Babel is strange when it comes to Rarrays. The convention is to
    # wrap Rarrays inside of a SIDL-Array in the Stub and to unpack it
    # in the Skeleton. However, in some languages (C, C++) we could
    # just directly call the Impl and save all that wrapper code.
    #
    # I found out the the reason behind this is that r-arrays were
    # never meant to be a performance enhancement, but syntactic sugar
    # around the SIDL array implementation to offer a more native
    # interface.
    #
    # TODO: Change the IOR in Babel to use the r-array calling
    # convention.  This will complicate the Python/Fortran/Java
    # backends but simplify the C/C++ ones.
    sidl_wrapping = (ir.stmt, """
var {a}rank = _braid_dom_{arg}.rank: int(32);

var {a}lus = computeLowerUpperAndStride(_braid_local_{arg});
var {a}lower = {a}lus(0): int(32);
var {a}upper = {a}lus(1): int(32);
var {a}stride = {a}lus(2): int(32);

{dest} = {iortype}_borrow(
    {stype}_ptr(_braid_local_{arg}(_braid_local_{arg}.domain.low)),
    //_braid_local_{arg}(_braid_local_{arg}.domain.low),
    {a}rank,
    {a}lower[1],
    {a}upper[1],
    {a}stride[1])""".format(a='_braid_%s_'%a0,
                            arg=a0,
                            dest=dest,
                            iortype=iortype[1],
                            stype=scalar_type))
    
    convs.append(sidl_wrapping)
    # post_call.append((ir.stmt, '//sidl__array_deleteRef((struct sidl__array*)a_tmp)'))


char_lut = '''
/* This burial ground of bytes is used for char [in]out arguments. */
static const unsigned char chpl_char_lut[512] = {
  '''+' '.join(['%d, 0,'%i for i in range(0, 256)])+'''
};
'''

def access(struct, item):
    '''
    shortcut for struct.item
    '''
    return (ir.get_struct_item, None, struct, (ir.struct_item, None, item))

def Cons(a, b):
    '''
    Treat a and b as lists and return a+b.
    None is treated as empty list.
    '''
    if a == None:                 a = []
    elif not isinstance(a, list): a = [a]
    if b == None:                 b = []
    elif not isinstance(b, list): b = [b]
    return a+b

def ir_to_burg(typ, language, *user_data):
    '''
    convert an IR datatype into its native chapel equivalent and
    return the corresponding BURG expression. Invoking codegen() on
    this expression as argument to one of the \c call rules will yield
    a conversion to the IOR.
    '''
    chpl_type_map={
        ir.pt_bool:     bool_chpl_chpl,
        ir.pt_char:     char_chpl_chpl,
        ir.pt_dcomplex: dcomplex_chpl_chpl,
        ir.pt_double:   double_chpl_chpl,
        ir.pt_float:    float_chpl_chpl,
        ir.pt_fcomplex: fcomplex_chpl_chpl,
        ir.pt_int:      int_chpl_chpl,
        ir.pt_long:     long_chpl_chpl,
        ir.pt_string:   string_chpl_chpl,
        ir.void_ptr:    opaque_chpl_chpl,

        ir.enum:        enum_chpl_chpl,
        'ext':          ext_chpl_chpl,
        'array':        array_chpl_chpl,
        ir.rarray:      array_chpl_chpl
        }

    ior_type_map={
        ir.pt_bool:     bool_ior_c,
        ir.pt_char:     char_ior_c,
        ir.pt_dcomplex: dcomplex_ior_c,
        ir.pt_double:   double_ior_c,
        ir.pt_float:    float_ior_c,
        ir.pt_fcomplex: fcomplex_ior_c,
        ir.pt_int:      int_ior_c,
        ir.pt_long:     long_ior_c,
        ir.pt_string:   string_ior_c,
        ir.void_ptr:    pointer_type_ior_c,

        ir.enum:        enum_ior_c,
        'ext':          ext_ior_c,
        'array':        array_ior_c,
        ir.rarray:      rarray_ior_c
        }

    if language == 'ior':
        type_map = ior_type_map
    else:
        type_map = chpl_type_map

    try:
        return type_map[typ], user_data
    except KeyError:  pass # not found
    except TypeError: pass # not hashable

    if typ[0] in [sidl.class_, sidl.interface]:
        return type_map['ext'], typ, user_data

    elif typ[0] == ir.pointer_type:
        if typ == ir.void_ptr:
            return type_map[ir.opaque], user_data

        elif typ[1][0] == ir.struct:
            if typ[1][1][0] == ir.scoped_id:
                return type_map['ext'], typ, user_data
            else:
                ptr, (struct, name, items, docstr) = typ
                hashable_typ = (ptr, (struct, name, tuple(items), docstr))
                return type_map['array'], hashable_typ, user_data
        else: raise Exception()

    elif typ[0] == ir.rarray:
        return type_map[ir.rarray], typ, user_data

    elif typ[0] == ir.enum:
        enum, name, items, docstr = typ
        hashable_typ = enum, name, tuple(items), docstr
        return type_map[ir.enum], hashable_typ, user_data

    raise Exception()

def array_ior_type(array):
    '''
    in case we actually _mean_ the raw IOR struct, obfuscate the type,
    so the code generator doesn't recognize it as an array
    '''
    (ptr, (struct, name, items, docs)) = array
    return (ptr, (struct, '/* IOR */'+name, items, docs))


def copy_over(typ, a0):
    '''
    merely copy over src into dest without any conversion
    '''
    dest, src, orig = a0
    return typ, (orig, orig, None)

def c_convs(a):
    'extract the postponed c conversions from an Xvalue_ior_c, if any'
    _, (_, _, c_xvalue) = a 
    if c_xvalue == None: 
        return []
    _t, _dest, _src, conv = c_xvalue
    return conv

def make_carg(name, allargs):
    # make a linear search through inoutargs to find the matching C type
    # [inout]args = typ, dest_name, src_name, (None | (ctype, cdest_name, csrc_name, conv))
    for mode, arg in allargs:
        typ, (name1, name2, conv) = arg
        if name == name1 or name == name2:
            if mode == ir.out: name = name1
            return ir.Arg([], mode, typ, name)
    import pdb; pdb.set_trace()
    raise

def get_c_tmp1(arg):
    typ, (_, name, conv) = arg # return src to signal 'no temp needed'
    if conv:
        typ, name, _, _ = conv # use c ior type if available
    return typ, name

def get_c_tmp2(arg):
    typ, (name, _, conv) = arg
    if conv:
        typ, _, name, _ = conv # use c ior type if available
    return typ, name

def ensure_list(a):
    if a == (): return []
    if not isinstance(a, list): return [a]
    return a

def assigns_retval(stmts):
    '''
    figure out if stmts assign _retval
    '''
    for stmt in stmts:
        if stmt[1][0] == ir.assignment:
            if stmt[1][1] == '_retval':
                return True
            if stmt[1][1][0] == ir.get_struct_item and stmt[1][1][2] == '_retval':
                return True
    return False

def strip_deref(a):
    if isinstance(a, tuple) and a[0] == ir.deref: 
        return a[1]
    return a

def deref_to_addr(arg, idx):
    _, (a1, a2, conv) = arg
    if conv: 
        _, a1, a2, _ = conv # use c ior type if available
        r = (a1, a2)[idx]
        deref = (a1, a2)[1-idx]

    else:
        # use src, because there is no ior conversion
        r = (a1, a2)[1-idx]
        deref = r

    if isinstance(deref, tuple) and deref[0] == ir.deref: 
        return ir.Pointer_expr(r)        
    return r

def c_tempvar(arg, idx):
    typ, (a1, a2, conv) = arg
    if conv: 
        _, a1, a2, _ = conv # use c ior name if available
    return typ, (a1, a2)[idx]

def strip_derefs(lvalue):
    t, (dest, src, data) = lvalue
    return t, (strip_deref(dest), strip_deref(src), data)

#------------------------------------------------------------------------
# Test harness
#------------------------------------------------------------------------
def test_harness():
    global debug
    debug = 1
    b = bool_chpl_chpl
    #codegen((b, 'a'), rvalue_ior_c, 0,0,0,0,0)
    #codegen((cons, (b, 'a'), (b, 'b')), rvalue_ior_c, 0,0,0,0,0)
    import chapel.chpl_code as cc
    scope = cc.ChapelFile()
    c_scope = scope.cstub
    codegen((call_assign, (call, (nonvirtual_method, ir.pt_int, 'f', None), 
             (cons, (ext_chpl_chpl, 
                     babel.ir_object_type([], 'name'),
                     ('self', '_f_ior_foo')), 
              (cons, (b, '_f_ior_a', 'a'), (b, '_f_ior_b', 'b')))), #incoming
             (cons, (b, 'retval', '_f_ior_retval'), (b, 'b', '_f_ior_b'))), #outgoing
            stmt, scope, c_scope)
    #codegen((chpl.char, 'test'), ior.char, [], set(), '*')
    #reducetree(label(('chpl.Char')), 'ior.str', ior.char, [], set())
    #print
    #reducetree(label('upcast(ior.object)'), 'ior.baseobject', ior.char, [], set())

#------------------------------------------------------------------------
# Declaration of additional arguments for the rule actions
#------------------------------------------------------------------------
%action arguments: (scope, c_scope)
#------------------------------------------------------------------------
%rules:
# Rule format
# -----------
#
# chpl.vcall @ chpl <-- ior.vcall @ C : cost(1)
#   actions
#------------------------------------------------------------------------

# Naming convention
# lvalue_ior_chpl
# {nodetype}_{representation}_{language the type was created in}

# How to read these rules:
#
#    rvalue_ior_c <-- call(any_method, rvalue_ior_c) :cost(2)
#
# This is a call to a function that expects ior_c arguments 
# (IOR format, call in the C language)

#
# CLIENT
#

# lhs and rhs are swapped, so the actions are executed
# in the correct order
stmt <-- ior_call_assign(rvalue_ior_c, lvalue_chpl_c)    :cost(1)
    ftype, name, args, call_args, ci = a0

    # merge in and outargs
    outargs = map(strip_derefs, ensure_list(a1))
    inargs = filter(lambda a: a[0] <> outgoing_arg, args)
    i = 0
    allargs = []
    for arg in args:
        if arg[0] == outgoing_arg:
            allargs.append((ir.out, outargs[i]))
            i += 1
        else:
            if (arg[1][1] == outargs[i][1][0] or 
                (arg[1][1][0] == ir.deref and 
                 arg[1][1][1] == outargs[i][1][0])):
                allargs.append((ir.inout, arg))
                i += 1
            else:
                allargs.append((ir.in_, arg))

    # generate the call to the C Stub
    cstub_params = map(lambda (_,a): strip_derefs(a)[1][0], allargs)
    arg_names    = map(lambda (_,a): strip_derefs(a)[1][1], allargs)

    cstub = '%s_%s_cStub'%('_'.join(ci.co.qualified_name), name)
    if ftype <> ir.pt_void:
        call = ir.Copy('_ior__retval', ir.Call(cstub, cstub_params))
    else:
        call = ir.Stmt(ir.Call(cstub, cstub_params))

    # now that we know all of them, declare temporary variables for
    # the CHAPEL stub
    unique_temps = set([(a[0], a[1][0]) for a in  inargs if a[1][0] <> a[1][1]]+
                       [(a[0], a[1][1]) for a in outargs if a[1][0] <> a[1][1]])
    for tmp in unique_temps:
        scope.genh(ir.Stmt(ir.Var_decl(*tmp)))

    # Stub in C:
    #
    # generate the remaining conversions (.?value_ior_c)
    #
    if len(outargs) > 0 and outargs[-1][1][0] == '_retval':
        ftype, (_, retval, convs) = outargs[-1]
        if convs: retval = convs[2]


        # always declare an _ior_retval because we will write to
        # it unconditionally
        if outargs[-1][1][0] == outargs[-1][1][1]:
            scope.genh(ir.Stmt(ir.Var_decl(outargs[-1][0], '_ior__retval')))

    else:
        ftype = ir.pt_void


    cstub_type = ftype
    cstub_args = map(lambda n: make_carg(n, allargs), arg_names)

    unique_temps = set(map(get_c_tmp1, inargs)+
                       map(get_c_tmp2, outargs))
    cstub_decls = [ir.Stmt(ir.Var_decl(*tmp)) for tmp in unique_temps 
                   if tmp[1][:5] == '_ior_'] # FIXME

    attrs = []
    join = lambda a, b: a+b
    pre_call =  reduce(join, map(c_convs,  inargs), [])
    post_call = reduce(join, map(c_convs, outargs), [])

    # generate the call to the real function implementation
    call_args1 = []
    for mode, arg in allargs:
        if mode == ir.out:
            call_args1.append(deref_to_addr(arg, 1))
        else: 
            call_args1.append(deref_to_addr(arg, 0))

    #if name in ['passeverywherefcomplex','passoutbool','removeReady']:
    #    print outargs[0][1]
    #    print outargs
    #    print call_args1
    #    #import pdb; pdb.set_trace()
    call = babel.vcall(name, call_args1, ci)

    if ftype <> ir.pt_void:
        if post_call:
            pre_call.append(ir.Stmt(ir.Var_decl(ftype, '_retval')))
            ior_call = [ir.Copy(retval, call)]
            if not assigns_retval(post_call):
                post_call.append(ir.Copy('_retval', retval))
            post_call.append(ir.Stmt(ir.Return('_retval')))
        else:
            ior_call = [ir.Stmt(ir.Return(call))]
    else:
        ior_call = [ir.Stmt(call)]

    cstub_body0 = cstub_decls+pre_call+ior_call+post_call
    cstub_body = [s for s in (cstub_body0) if s]
    scope.cstub.gen(ir.Fn_defn(attrs, cstub_type, cstub, cstub_args, cstub_body, 
                               'remaining Stub in C'))
    #scope.cstub.genh(ir.Fn_decl(attrs, cstub_type, cstub, cstub_args, 'remaining Stub in C'))
    scope.genh((ir.fn_decl, ['extern']+attrs, cstub_type, cstub, cstub_args, 'remaining Stub in C'))
    return None

# NONVIRTUAL CLIENT
# lhs and rhs are swapped, so the actions are executed
# in the correct order
stmt <-- ior_call_assign(rvalue_ior_chpl, lvalue_chpl_chpl) :cost(1)
    inargs = a0
    inargs = ensure_list(inargs)
    outargs = map(strip_derefs, ensure_list(a1))

    # now that we know all of them, declare temporary variables for
    # the Chapel stub
    unique_temps = set(map(lambda a: (a[0], a[1][0]), inargs)+
                       map(lambda a: (a[0], a[1][1]), outargs))
    for tmp in unique_temps:
        if tmp[1][:5] == '_ior_' or tmp[1] == '_ex': #FIXME
            scope.genh(ir.Stmt(ir.Var_decl(*tmp)))
    return None

any_method <-- virtual_method : cost(0)
any_method <-- nonvirtual_method : cost(0)

# When we reach this action, the decision for using a stub was already
# made by the instruction selector.
# Call nodes take a tuple (method name, ingoing arguments)
#
# Conversion rules are expected to return a tuple
# typ, dest_name, src_name, (None | (ctype, cdest_name, csrc_name, conv))
rvalue_ior_c <-- ior_call(any_method, rvalue_ior_c) :cost(2)
    ftype, name, ci = a0
    la1 = ensure_list(a1)
    args = map(strip_derefs, la1)

    return ftype, name, args, la1, ci

# nonvirtual methods
rvalue_ior_chpl <-- ior_call(nonvirtual_method, rvalue_ior_chpl) :cost(1)
    ftype, name, ci = a0
    la1 = ensure_list(a1)
    args = map(strip_derefs, la1)
    call_args = map(lambda a: deref_to_addr(a, 0), la1)
    #print 'IMPLEMENT ME'
    if ftype <> ir.pt_void:
        scope.gen(ir.Copy('_ior__retval', ir.Call(name, call_args)))
    else:
        scope.gen(ir.Stmt(ir.Call(name, call_args)))

    # the outgoing pseudo-args are only there to pass the expressions in the right order
    inargs = filter(lambda a: a[0] <> outgoing_arg, args)
    #call_args = map(lambda a: deref_to_addr(a), la1)
    #call = ir.Call(a0, call_args)
    return inargs

#
# SERVER
#

# skeleton -> implementation calls
stmt <-- chpl_call_assign(rvalue_chpl_chpl, lvalue_ior_c) :cost(1)
    ftype, name, ci, call_args, inargs = a0
    inargs = ensure_list(inargs)
    outargs = map(strip_derefs, ensure_list(a1))

    # now that we know all of them, declare temporary variables for
    # the Chapel stub
    unique_temps = set(map(lambda a: c_tempvar(a, 0), inargs)+
                       map(lambda a: c_tempvar(a, 1), outargs))
    for tmp in unique_temps:
        if tmp[1] == '_ex':
            scope.cstub.genh(ir.Stmt(ir.Var_decl(ir.Pointer_type(tmp[0]),tmp[1])))
        elif tmp[1][:6] == '_chpl_':
            scope.cstub.genh(ir.Stmt(ir.Var_decl(*tmp)))

    # merge incoming and outgoing args again
    impl_params = []
    impl_decl_args = []
    i = 0
    for arg in call_args:
        if arg[0] == outgoing_arg:
            impl_decl_args.append(ir.Arg([], ir.out, outargs[i][0], outargs[i][1][1]))
            impl_params.append(deref_to_addr(outargs[i], 1))
            i += 1
        else:
            #impl_args.append(arg)
            impl_params.append(deref_to_addr(arg, 0))
            if (arg[1][1] == outargs[i][1][0] or 
                (arg[1][1][0] == ir.deref and 
                 arg[1][1][1] == outargs[i][1][0])):
                i += 1 # mode.inout
                impl_decl_args.append(ir.Arg([], ir.inout, arg[0], arg[1][0]))
            else:
                impl_decl_args.append(ir.Arg([], ir.in_, arg[0], arg[1][0]))

    join = lambda a, b: a+b
    pre_call =  reduce(join, map(c_convs,  inargs), [])
    post_call = reduce(join, map(c_convs, outargs), [])
    # generate the call to the Chapel implementation
    #impl_params = map(lambda a: deref_to_addr(a, 0), args)
    #arg_names   = map(lambda a: strip_derefs(a)[1][1], args)

    if len(outargs) > 0 and outargs[-1][1][0] == '_retval':
        ftype, (_, retval, convs) = outargs[-1]
        if convs: ftype, _, retval, _ = convs
    else:
        ftype = ir.pt_void

    impl = '%s_%s_impl'%('_'.join(ci.co.qualified_name), name)
    call = ir.Call(impl, impl_params)

    if ftype <> ir.pt_void:
        impl_type = c_tempvar(outargs[-1], 1)[0]
        if post_call:
            pre_call.append(ir.Stmt(ir.Var_decl(ftype, '_retval')))
            impl_call = ir.Copy(retval, call)
            if not assigns_retval(post_call):
                post_call.append(ir.Copy('_retval', retval))
            post_call.append(ir.Stmt(ir.Return('_retval')))
        else:
            impl_call = ir.Stmt(ir.Return(call))
    else:
        impl_type = ir.void
        impl_call = ir.Stmt(call)

    map(scope.cstub.gen, pre_call)
    scope.cstub.gen(impl_call)
    map(scope.cstub.gen, post_call)

    impldecl = (ir.fn_decl, [], impl_type, impl, impl_decl_args, 'user-defined implementation')
    ci.chpl_skel.cstub.gen(impldecl)


    return None

# skeleton -> impl method calls
rvalue_chpl_chpl <-- chpl_call(any_method, rvalue_chpl_chpl) :cost(1)
    ftype, name, ci = a0
    la1 = ensure_list(a1)
    args = map(strip_derefs, la1)

    # the outgoing pseudo-args are only there to pass the expressions in the right order
    inargs = filter(lambda a: a[0] <> outgoing_arg, args)

    return ftype, name, ci, args, inargs


#
# FUSION
#

stmt <-- call(method, rvalue_native_fortran) :cost(1)
    gen_tmp_vardecls(scope, list(a1))
    scope.gen(ir.Call('%s_fuse'%a0, a1))

#
# MISCELLANEOUS
#

lvalue_ior_c            <-- none :cost(0)
lvalue_ior_c            <-- cons(lvalue_ior_c,     none)             : cost(0)
lvalue_ior_c            <-- cons(lvalue_ior_c,     lvalue_ior_c)     : cost(0)
    return Cons(a0, a1)                                              
                                                                     
lvalue_ior_chpl         <-- none :cost(0)                            
lvalue_ior_chpl         <-- cons(lvalue_ior_chpl,  none)             : cost(0)
lvalue_ior_chpl         <-- cons(lvalue_ior_chpl,  lvalue_ior_chpl)  : cost(0)
    return Cons(a0, a1)

lvalue_chpl_c           <-- none :cost(0)
lvalue_chpl_c           <-- cons(lvalue_chpl_c,    none)             : cost(0)
lvalue_chpl_c           <-- cons(lvalue_chpl_c,    lvalue_chpl_c)    : cost(0)
    return Cons(a0, a1)

rvalue_ior_c            <-- none :cost(0)
rvalue_ior_c            <-- cons(rvalue_ior_c,     none)             : cost(0)
rvalue_ior_c            <-- cons(rvalue_ior_c,     rvalue_ior_c)     : cost(0)
    return Cons(a0, a1)                                              
                                                                     
rvalue_ior_chpl         <-- none :cost(0)                            
rvalue_ior_chpl         <-- cons(rvalue_ior_chpl,  none)             : cost(0)
rvalue_ior_chpl         <-- cons(rvalue_ior_chpl,  rvalue_ior_chpl)  : cost(0)
    return Cons(a0, a1)

rvalue_chpl_chpl        <-- none :cost(0)
rvalue_chpl_chpl        <-- cons(rvalue_chpl_chpl, none)             : cost(0)
rvalue_chpl_chpl        <-- cons(rvalue_chpl_chpl, rvalue_chpl_chpl) : cost(0)
    return Cons(a0, a1)


# this is a pseudo-arg to have all arguments (including the outgoing
# ones) appear in the right order in the call rule
rvalue_ior_c     <-- outgoing_arg  :cost(0)
    return outgoing_arg, (a0, a0, None)

rvalue_chpl_chpl <-- outgoing_arg  :cost(0)
    return outgoing_arg, (a0, a0, None)

rvalue_ior_chpl  <-- outgoing_arg  :cost(0)
    return outgoing_arg, (a0, a0, None)

rvalue_chpl_c    <-- outgoing_arg  :cost(0)
    return outgoing_arg, (a0, a0, None)

# this conversion is essentially a no-op; it says that values
# converted at the chpl level are also compatible with a stub
# DO NOT UNCOMMENT THESE, cf. *assign*
#value_ior_c     <-- value_ior_chpl   :cost(0)
#value_ior_chpl  <-- value_ior_c      :cost(0)
#value_chpl_c    <-- value_chpl_chpl  :cost(0)
#value_chpl_chpl <-- value_chpl_c     :cost(0)

# rvalue and lvalue only serve to make the call rules more readable
lvalue_ior_c     <-- value_ior_c    :cost(0)
rvalue_ior_c     <-- value_ior_c    :cost(0)
lvalue_ior_chpl  <-- value_ior_chpl :cost(0)
rvalue_ior_chpl  <-- value_ior_chpl :cost(0)
lvalue_chpl_c    <-- value_chpl_c   :cost(0)
rvalue_chpl_c    <-- value_chpl_c   :cost(0)
lvalue_chpl_chpl <-- value_chpl_chpl:cost(0)
rvalue_chpl_chpl <-- value_chpl_chpl:cost(0)

value_chpl_c    <-- bool_chpl_c   :cost(0) 
value_ior_c     <-- bool_ior_c    :cost(0) 
value_chpl_chpl <-- bool_chpl_chpl:cost(0) 
value_ior_chpl  <-- bool_ior_chpl :cost(0) 

value_chpl_c    <-- char_chpl_c   :cost(0) 
value_ior_c     <-- char_ior_c    :cost(0) 
value_chpl_chpl <-- char_chpl_chpl:cost(0) 
value_ior_chpl  <-- char_ior_chpl :cost(0) 

value_chpl_c    <-- string_chpl_c   :cost(0) 
value_ior_c     <-- string_ior_c    :cost(0) 
value_chpl_chpl <-- string_chpl_chpl:cost(0) 
value_ior_chpl  <-- string_ior_chpl :cost(0) 

value_chpl_c    <-- int_chpl_c   :cost(0) 
value_ior_c     <-- int_ior_c    :cost(0) 
value_chpl_chpl <-- int_chpl_chpl:cost(0) 
value_ior_chpl  <-- int_ior_chpl :cost(0) 

value_chpl_c    <-- long_chpl_c   :cost(0) 
value_ior_c     <-- long_ior_c    :cost(0) 
value_chpl_chpl <-- long_chpl_chpl:cost(0) 
value_ior_chpl  <-- long_ior_chpl :cost(0) 

value_chpl_c    <-- float_chpl_c   :cost(0) 
value_ior_c     <-- float_ior_c    :cost(0) 
value_chpl_chpl <-- float_chpl_chpl:cost(0) 
value_ior_chpl  <-- float_ior_chpl :cost(0) 

value_chpl_c    <-- double_chpl_c   :cost(0) 
value_ior_c     <-- double_ior_c    :cost(0) 
value_chpl_chpl <-- double_chpl_chpl:cost(0) 
value_ior_chpl  <-- double_ior_chpl :cost(0) 

value_chpl_c    <-- fcomplex_chpl_c   :cost(0) 
value_ior_c     <-- fcomplex_ior_c    :cost(0) 
value_chpl_chpl <-- fcomplex_chpl_chpl:cost(0) 
value_ior_chpl  <-- fcomplex_ior_chpl :cost(0) 

value_chpl_c    <-- dcomplex_chpl_c   :cost(0) 
value_ior_c     <-- dcomplex_ior_c    :cost(0) 
value_chpl_chpl <-- dcomplex_chpl_chpl:cost(0) 
value_ior_chpl  <-- dcomplex_ior_chpl :cost(0) 

value_chpl_c   <-- opaque_chpl_c      :cost(0) 
value_ior_c    <-- pointer_type_ior_c :cost(0) 
value_chpl_chpl<-- opaque_chpl_chpl   :cost(0) 
value_ior_chpl <-- pointer_type_ior_chpl :cost(0) 

value_chpl_c   <-- enum_chpl_c :cost(0) 
value_ior_c    <-- enum_ior_c    :cost(0) 
value_chpl_chpl<-- enum_chpl_chpl :cost(0) 
value_ior_chpl <-- enum_ior_chpl :cost(0) 

value_chpl_c   <-- struct_chpl_c :cost(0) 
value_ior_c    <-- struct_ior_c    :cost(0) 
value_chpl_chpl<-- struct_chpl_chpl :cost(0) 
value_ior_chpl <-- struct_ior_chpl :cost(0) 

value_chpl_c   <-- array_chpl_c   :cost(0) 
value_ior_c    <-- array_ior_c    :cost(0) 
value_chpl_chpl<-- array_chpl_chpl:cost(0) 
value_ior_chpl <-- array_ior_chpl :cost(0) 

value_chpl_c    <-- ext_chpl_c    :cost(0) 
value_ior_c     <-- ext_ior_c     :cost(0)
value_chpl_chpl <-- ext_chpl_chpl :cost(0) 
value_ior_chpl  <-- ext_ior_chpl  :cost(0) 

# SELF
#------------------------------------------------------------------------
# baseobject_AT_C_ior_chpl <-- upcast(chpl.baseobject): cost(1)
#     # We should find a cleaner way of implementing this
#     #if src == 'self' and member_chk(ir.pure, attrs):
#     import pdb; pdb.set_trace()
#     c_scope.gen(ir.Copy(dest, '(({0})((struct sidl_BaseInterface__object*)self)<--d_object)'.format(c_gen(typ))))
#     return dest

# OBJECTS
#------------------------------------------------------------------------
# conversion is handled in Chapel, ior-chpl -> ior-c is identity
ext_ior_chpl    <-- ext_ior_c    :cost(0)
ext_ior_c       <-- ext_ior_chpl    :cost(0)
# 
ext_chpl_c      <-- ext_chpl_chpl :cost(0)
#ext_chpl_chpl   <-- ext_chpl_c    :cost(0)

ext_ior_chpl    <-- ext_chpl_chpl:cost(1)
    t, (dest, src, orig) = a0
    ptr, (struct, s_id, items, doc) = t
    h_t = ptr, (struct, sidl.hashable(s_id), (), doc)

    # hardcoded: Babel exception argument, SERVER-side
    if src == '_ex':
        scope.cstub.gen(ir.Copy(dest, src))
        return h_t, (dest, src, None)

    name = s_id[2]# +s_id[3] hijacked for '__object'
    scope.gen(ir.Copy(dest, '%s.self_%s'%(src, name)))
    return h_t, (dest, src, None)

ext_chpl_chpl <-- ext_ior_chpl :cost(1)
    t, (dest, src, orig) = a0
    ptr, (struct, s_id, items, doc) = t
    h_t = ptr, (struct, sidl.hashable(s_id), (), doc)

    # hardcoded: Babel exception argument, CLIENT-side
    if src == '_ior__ex':
        scope.gen(ir.Stmt(ir.If(
                    ir.Call("IS_NOT_NULL", ['_ior__ex']), 
                    [ir.Copy('_ex', ir.Call("new BaseInterface", ['_ior__ex']))])))
        return h_t, (dest, src, None)

    # hardcoded: self argument, SERVER-side
    if src == 'self':
        scope.cstub.gen(ir.Copy(dest, access(ir.Deref(src), 'd_data')))
        return ir.void_ptr, (dest, src, None)
 
    # regular object with unknown implementation language (interface/class)

    # drop the id's extension, which we hijacked for '__object'
    s_id1 = ir.Scoped_id(s_id[1], s_id[2], '')
    name = s_id[2]
    #mod_name = '.'.join(full_type[1]+[name])
    wrap = ir.Call('%s_static.wrap_%s' %(babel.qual_id(s_id1, '.'), name), [src, '_ex'])
    scope.gen(ir.Copy(dest, wrap))
    return h_t, (dest, src, None) #(h_t, [ir.Copy(dest, src)])

# BOOL
#------------------------------------------------------------------------
bool_chpl_c      <-- bool_chpl_chpl :cost(0)
bool_chpl_chpl   <-- bool_chpl_c    :cost(0)

bool_ior_c      <-- bool_chpl_c: cost(1)
    dest, src, orig = a0
    t = ir.Typedef_type('chpl_bool')
    conv = [ir.Comment('sidl_bool is an int, but chapel bool is a char/_Bool'),
            ir.Copy(dest,'(%s)%s'%(c_gen(ir.pt_int),c_gen(src)))]
    return t, (orig, orig, (ir.pt_int, dest, src, conv))

bool_chpl_c <-- bool_ior_c: cost(1)
    dest, src, orig = a0
    t = ir.Typedef_type('chpl_bool')
    conv = [ir.Comment('sidl_bool is an int, but chapel bool is a char/_Bool'),
            ir.Copy(dest,'(%s)%s'%(c_gen(t),c_gen(src)))]
    return t, (orig, orig, (ir.pt_int, dest, src, conv))

bool_ior_chpl   <-- bool_chpl_chpl: cost(3)
    dest, src, orig = a0
    import pdb; pdb.set_trace()
    t = ir.Typedef_type('chpl_bool')
    conv = ir.Copy(dest, ir.Call("convert_bool_chpl_to_ior", [src]))
    return t, (orig, orig, (ir.pt_int, dest, src, conv))


# CHAR
#------------------------------------------------------------------------
char_chpl_c      <-- char_chpl_chpl :cost(0)
char_chpl_chpl   <-- char_chpl_c    :cost(0)
#char_ior_c       <-- char_ior_chpl  :cost(0)
char_ior_chpl    <-- char_ior_c     :cost(0)

char_ior_c <-- char_chpl_c : cost(1)
    dest, src, orig = a0
    conv = [ir.Comment('in chapel, a char is a string of length 1'),
            ir.Copy(dest, ir.Deref(src))] # deref takes 1st char of string
    c_scope.optional.add(char_lut)
    return ir.pt_string, (orig, orig, (ir.pt_char, dest, src, conv))

char_chpl_c <-- char_ior_c : cost(1)
    dest, src, orig = a0
    conv = []
    conv.append(ir.Comment('in chapel, a char is a string of length 1'))
    # we can't allocate a new string, this would leak memory
    conv.append(ir.Copy(dest, '(const char*)&chpl_char_lut[2*(unsigned char)%s]'%c_gen(src)))
    c_scope.optional.add(char_lut)
    return ir.pt_string, (orig, orig, (ir.pt_char, dest, src, conv))

# COMPLEX - 32/64 Bit components
#------------------------------------------------------------------------
fcomplex_chpl_c      <-- fcomplex_chpl_chpl :cost(0)
fcomplex_chpl_chpl   <-- fcomplex_chpl_c    :cost(0)
fcomplex_ior_chpl    <-- fcomplex_ior_c     :cost(0)
dcomplex_chpl_c      <-- dcomplex_chpl_chpl :cost(0)
dcomplex_chpl_chpl   <-- dcomplex_chpl_c    :cost(0)
dcomplex_ior_chpl    <-- dcomplex_ior_c     :cost(0)

fcomplex_ior_c <-- fcomplex_chpl_c : cost(2)
    dest, src, orig = a0
    conv = []
    conv.append(ir.Copy(access(dest, 'real'),access(src, 're')))
    conv.append(ir.Copy(access(dest, 'imaginary'),access(src, 'im')))
    return ir.Typedef_type('_complex64'), (orig, orig, (ir.pt_fcomplex, dest, src, conv))

dcomplex_ior_c <-- dcomplex_chpl_c : cost(2)
    dest, src, orig = a0
    conv = []
    conv.append(ir.Copy(access(dest, 'real'),access(src, 're')))
    conv.append(ir.Copy(access(dest, 'imaginary'),access(src, 'im')))
    return ir.Typedef_type('_complex128'), (orig, orig, (ir.pt_dcomplex, dest, src, conv))

fcomplex_chpl_c <-- fcomplex_ior_c : cost(2)
    dest, src, orig = a0
    conv = []
    conv.append(ir.Copy(access(dest, 're'),access(src, 'real')))
    conv.append(ir.Copy(access(dest, 'im'),access(src, 'imaginary')))
    return ir.Typedef_type('_complex64'), (orig, orig, (ir.pt_fcomplex, dest, src, conv))

dcomplex_chpl_c <-- dcomplex_ior_c : cost(2)
    dest, src, orig = a0
    conv = []
    conv.append(ir.Copy(access(dest, 're'),access(src, 'real')))
    conv.append(ir.Copy(access(dest, 'im'),access(src, 'imaginary')))
    return ir.Typedef_type('_complex128'), (orig, orig, (ir.pt_dcomplex, dest, src, conv))

# ENUM
#------------------------------------------------------------------------
enum_chpl_c      <-- enum_chpl_chpl :cost(0)
enum_chpl_chpl   <-- enum_chpl_c    :cost(0)
enum_ior_c <-- enum_chpl_c : cost(1)
    t, (dest, src, orig) = a0
    # No special treatment for enums, rely on chpl runtime to set it
    return t, (orig, orig, (t, dest, src, [ir.Copy(dest, ir.Sign_extend(64, src))]))

enum_chpl_c <-- enum_ior_c : cost(1)
    t, (dest, src, orig) = a0
    return t, (orig, orig, (t, dest, src, [ir.Copy(dest, src)]))

# STRING
#------------------------------------------------------------------------
string_chpl_c      <-- string_chpl_chpl :cost(0)
string_chpl_chpl   <-- string_chpl_c    :cost(0)
# DO NOT UNCOMMENT THE FOLLOWING LINE
#string_ior_chpl    <-- string_ior_c     :cost(0)
string_ior_c <-- string_chpl_c : cost(0)
    dest, src, orig = a0
    return ir.pt_string, (orig, orig, (ir.pt_string, dest, src, [ir.Copy(dest, src)]))

string_chpl_c <-- string_ior_c : cost(1)
    dest, src, orig = a0
    # Convert null pointer into empty string
    conv = []
    conv.append((ir.stmt, 'if ({n} == NULL) {n} = ""'.format(n=src)))
    conv.append(ir.Copy(dest, src))
    return ir.pt_string, (orig, orig, (ir.pt_string, dest, src, conv))

# INT
#------------------------------------------------------------------------
int_chpl_c      <-- int_chpl_chpl :cost(0)
int_chpl_chpl   <-- int_chpl_c    :cost(0)
int_ior_chpl    <-- int_ior_c     :cost(0)

int_ior_c <-- int_chpl_c : cost(0)
    return copy_over(ir.pt_int, a0)

int_chpl_c <-- int_ior_c : cost(0)
    return copy_over(ir.pt_int, a0)

# LONG
#------------------------------------------------------------------------
long_chpl_c      <-- long_chpl_chpl :cost(0)
long_chpl_chpl   <-- long_chpl_c    :cost(0)
long_ior_chpl    <-- long_ior_c     :cost(0)

long_ior_c <-- long_chpl_c : cost(0)
    return copy_over(ir.pt_long, a0)
long_chpl_c <-- long_ior_c : cost(0)
    return copy_over(ir.pt_long, a0)

# FLOAT
#------------------------------------------------------------------------
float_chpl_c      <-- float_chpl_chpl :cost(0)
float_chpl_chpl   <-- float_chpl_c    :cost(0)
float_ior_chpl    <-- float_ior_c     :cost(0)

float_ior_c <-- float_chpl_c : cost(0)
    return copy_over(ir.pt_float, a0)
float_chpl_c <-- float_ior_c : cost(0)
    return copy_over(ir.pt_float, a0)

# DOUBLE
#------------------------------------------------------------------------
double_chpl_c      <-- double_chpl_chpl :cost(0)
double_chpl_chpl   <-- double_chpl_c    :cost(0)
double_ior_chpl    <-- double_ior_c     :cost(0)
double_ior_c <-- double_chpl_c : cost(0)
    return copy_over(ir.pt_double, a0)
double_chpl_c <-- double_ior_c : cost(0)
    return copy_over(ir.pt_double, a0)


# VOID return type
#------------------------------------------------------------------------
void_chpl_c      <-- void_chpl_chpl :cost(0)
void_chpl_chpl   <-- void_chpl_c    :cost(0)
void_chpl_c <-- void_ior_c :cost(0)
    return copy_over(ir.pt_void, a0)
void_ior_c <-- void_chpl_c :cost(0)
    return copy_over(ir.pt_void, a0)

# OPAQUE
#------------------------------------------------------------------------
opaque_chpl_c    <-- opaque_chpl_chpl     :cost(0)
opaque_chpl_chpl <-- opaque_chpl_c        :cost(0)
opaque_chpl_c    <-- pointer_type_ior_c   :cost(0)
    return copy_over(ir.void_ptr, a0)
pointer_type_ior_c <-- opaque_chpl_c      :cost(0)
    return copy_over(ir.void_ptr, a0)

# FIXME:
# pointer_type_AT_C_chpl_chpl <-- ior.*
#   a0 = ir.Pointer_expr(a0)

# STRUCT
#------------------------------------------------------------------------
# FIXME: we would actually need dynamic costs for this situation
struct_chpl_c      <-- struct_chpl_chpl :cost(0)
struct_chpl_chpl   <-- struct_chpl_c    :cost(0)
struct_ior_c <-- struct_chpl_c : cost(9)
    items = get_struct_items(full_type)

    #print name, typ, ir_type_to_chpl(typ)

    # recursively generate conversions for all items in the struct
    map(lambda (_, typ, name):
          codegen(type_conv(typ), a0+name+elem_access(typ), strip(typ),
                  convs, skel, dest+'.'+name, typ), items, type_conv)

    # if we need to convert one of the items, we need to convert all of them
    if convs: copy_other_items(convs, items, a0, '%s'%c_gen(dest))
    return a0

struct_chpl_c <-- struct_ior_c : cost(9)
    items = get_struct_items(full_type)
    map(lambda (_, typ, name):
          codegen((strip(typ), a0+'.'+name), type_conv(typ),
                  convs, skel, dest+'.'+name, typ), items, type_conv)
    if convs: copy_other_items(convs, items, '%s.'%a0, dest)
    return a0

# SIDL ARRAY
#------------------------------------------------------------------------
# Conversion handled in Chapel

array_chpl_c     <-- array_chpl_chpl :cost(0)
array_chpl_chpl  <-- array_chpl_c    :cost(0)
array_ior_c      <-- array_ior_chpl :cost(0)
array_ior_chpl   <-- array_ior_c    :cost(0)

# for sidl arrays we invoke a chapel code fragment from the C stub
array_chpl_chpl <-- array_ior_chpl: cost(1)
    t, (dest, src, _) = a0
    scalar_type = get_ior_array_type(t)
    if scalar_type == ir.void_ptr:
        # generic array
        #scope.gen(ir.Copy(dest, ir.Call("generic_ptr", [src])))
        scope.gen(ir.Copy(dest, src))
    else:
        scope.gen(ir.Copy(dest, ir.Call('sidl.wrap_%s_array'%scalar_type, [src])))
    #return array_ior_type(t), (dest, src, None)
    return t, (dest, src, None)

# now part of sidl.chpl:
#    skel.gen(ir.Fn_defn(
#            [], ir.pt_void, '%s_to_chpl'%fu_type, 
#            [ir.Arg([], ir.in_, full_type, 'ior')],
#            [ir.Stmt((ir.new, 'sidl.Array', [scalar_type, full_type, dest]))],
#            'argument conversion codelet'))


array_ior_chpl <-- array_chpl_chpl: cost(1)
    t, (dest, src, _) = a0
    scalar_type = get_ior_array_type(t)
    if scalar_type == ir.void_ptr:
        # generic array
        #scope.gen(ir.Copy(dest, ir.Call("ptr_generic", [src])))
        scope.gen(ir.Copy(dest, src))
    else:
        scope.gen(ir.Copy(dest, access(src, 'ior')))
    return t, (dest, src, None)
    #return array_ior_type(t), (dest, src, None)

#array_ior_c <-- array_chpl_chpl : cost(1)
#    scalar_type = get_array_type(full_type)
#    conv.append((ir.stmt, '{dest} = ({typ}){n}.self'
#                  .format(dest=dest, n=a0, typ=scalar_type)))

    # wrap the C type in a native Chapel object
    #if mode == sidl.inout:
    #    pre_call.append(ir.Copy(iorname, name+'.self'))

                    
    # if name == '_retval':
    #     return_expr.append(conv)
    # else:
    #     post_call.append(ir.Copy(name, conv))

# RAW ARRAY
#------------------------------------------------------------------------
rarray_ior_c    <-- rarray_ior_chpl :cost(0)
rarray_ior_chpl <-- rarray_ior_c    :cost(0)
array_chpl_chpl <-- rarray_ior_chpl :cost(4)
    t, (dest, src, orig) = a0
    _, array_t = get_array_type(t)
    wrap_rarray(convs, src, t, dest)
    return array_t, (dest, src, None)

rarray_ior_chpl <-- array_chpl_chpl: cost(4)
    t, (dest, src, orig) = a0
    _, array_t = get_array_type(t)
    # emit code to copy back elements into non-local array
    name = src[1] if src[0] == ir.deref else src
    sarray = "_braid_wrapped_local_%s_sarray"%name
    barray = "_babel_wrapped_local_%s_barray"%name
    sarr = (ir.call, "new Array", [access(src, 'eltType'), t[1], src])
    barr = ir.Call("createBorrowedArray{dim}d".format(dim=t[2]), [sarray])
    scope.gen(ir.Copy('var ' + sarray, sarr))
    scope.gen(ir.Copy('var ' + barray, barr))
    scope.gen(ir.Stmt(ir.Call('syncNonLocalArray', [barray, dest])))
    return array_t, (dest, src, None)
