# -*- python -*-
# Process this file with burg.py
## @package chapel.conversions
#
# BURG-style low-level type conversion rules for IOR <-> Chapel.
#
# Please report bugs to <adrian@llnl.gov>.
#
# \authors <pre>
#
# Copyright (c) 2011, 2012 Lawrence Livermore National Security, LLC.
# Produced at the Lawrence Livermore National Laboratory
# Written by Adrian Prantl <adrian@llnl.gov>.
#
# LLNL-CODE-473891.
# All rights reserved.
#
# This file is part of BRAID. For details, see
# http://compose-hpc.sourceforge.net/.
# Please read the COPYRIGHT file for Our Notice and
# for the BSD License.
#
# </pre>


#------------------------------------------------------------------------
# Declaration of additional arguments for the rule actions
#------------------------------------------------------------------------
%action arguments: (convs, skel, dest, full_type)

#------------------------------------------------------------------------
import ior, ir, sidl
import chapel.chpl as chpl
from codegen import CCodeGenerator, CFile

def c_gen(ir, scope=None):
    if scope == None:
        scope = CFile()
    return CCodeGenerator().generate(ir, scope)

def ir_arg_to_chpl((arg, attrs, mode, typ, name)):
    return arg, attrs, mode, ir_type_to_chpl(typ), name

def ir_type_to_chpl(typ):
    """
    Convert only the datatype \c typ into its chapel equivalent
    TODO: could we also generate this from the spec below?
    """
    mapping = {
        ir.pt_void:     ir.pt_void,
        ir.pt_bool:     ir.Typedef_type('chpl_bool'),
        ir.pt_string:   ir.const_str,
        ir.pt_int:      ir.pt_int, #ir.Typedef_type('int32_t'),
        ir.pt_long:     ir.pt_long, #ir.Typedef_type('int64_t'),
        ir.pt_char:     ir.const_str,
        ir.pt_fcomplex: ir.Typedef_type('_complex64'), 
        ir.pt_dcomplex: ir.Typedef_type('_complex128'),
        ir.pt_float:    ir.pt_float,
        ir.pt_double:   ir.pt_double,
        sidl.pt_opaque: ir.Pointer_type(ir.pt_void)
        }
    try:
        return mapping[typ]
    except:
        if typ[0] == ir.enum: 
            # the types need to be dissimilar, even if they have the same name
            enum, name, items, comment = typ
            return enum, name, items, 'chpl '+comment
        if typ[0] == ir.typedef_type and typ[1] == 'sidl_bool': 
            return ir.Typedef_type('chpl_bool')
        if typ[0] == 'upcast':
            # part of the hack for self dereferencing
            return typ[1]
        if typ[0] == ir.pointer_type:
             return ir.Pointer_type(ir_type_to_chpl(typ[1]))

        if typ[0] == ir.struct:
            _, name, items, comment = typ
            items1 = map(ir_type_to_chpl, items)
            # User-defined structs are created in the IOR with an
            # '__data' suffix, so we can use the actual name for the
            # Chapel version of the struct.
            if name[-6:] == '__data': 
                name = '__'+name[:-6] # Wow, is this unelegant!

            return ir.Struct(name, items1, comment)

        if typ[0] == ir.struct_item:
            return ir.Struct_item(ir_type_to_chpl(typ[1]),typ[2])

        if typ[0] == sidl.array:
            return get_array_type(typ)[1]

        return typ


def strip(typ):
    if typ[0] == ir.typedef_type and typ[1] == 'sidl_bool':
        return ior.bool
    # strip unnecessary details from aggregate types
    if (typ[0] == ir.enum or
        typ[0] == sidl.array or
        typ[0] == sidl.rarray or
        typ[0] == ir.pointer_type or
        typ[0] == ir.struct):
        return typ[0]
    return typ


def copy_other_items(convs, items, a0, dest):
    """
    copy all struct items that need not to be converted
    """
    for _, typ, name in items:
        if typ[0] == ir.struct:
            copy_other_items(convs, ir.struct_struct_items(typ), a0+name+'.', dest+'.'+name)

        if ir_type_to_chpl(typ) == typ: # boy, is this inefficient!!
            convs.append(ir.Stmt(ir.Assignment(dest+'.'+name, a0+name)))

def get_struct_items(full_type):
    t = full_type[1] if full_type[0] == ir.pointer_type else full_type
    return ir.struct_struct_items(t) 


def elem_access(typ):
    if typ[0] == ir.struct:
        return '.'
    else: return ''

def get_array_type(full_type):
    if full_type[1] == []:
        t = ''
    elif full_type[1][0] == ir.scoped_id:
        t = '_BaseInterface'
    else:
        t = '_'+full_type[1][1]
    name = 'sidl%s__array'%t
    iortype = ir.Pointer_type(ir.Struct(name, [], ''))
    return name, iortype 


char_lut = '''
/* This burial ground of bytes is used for char [in]out arguments. */
static const unsigned char chpl_char_lut[512] = {
  '''+' '.join(['%d, 0,'%i for i in range(0, 256)])+'''
};
'''

#------------------------------------------------------------------------
%rules:
# Rule format
# -----------
#
# chpl.vcall @ chpl <-- ior.vcall @ C : cost(1)
#   actions
#------------------------------------------------------------------------


# BOOL
#------------------------------------------------------------------------
ior.bool @ C <-- chpl.bool : cost(1)
    convs.append(ir.Comment('sidl_bool is an int, but chapel bool is a char/_Bool'))
    convs.append((ir.stmt, '{dest} = ({typ}){n}'
                  .format(dest=dest, n=a0, typ=c_gen(ir.pt_bool))))

chpl.bool @ C <-- ior.bool : cost(1)
    convs.append(ir.Comment('sidl_bool is an int, but chapel bool is a char/_Bool'))
    convs.append((ir.stmt, '{dest} = ({typ}){n}'
                  .format(dest=dest, n=a0, typ=c_gen(ir_type_to_chpl(ir.pt_bool)))))

# CHAR
#------------------------------------------------------------------------
ior.char @ C <-- chpl.char : cost(1)
    convs.append(ir.Comment('in chapel, a char is a string of length 1'))
    convs.append((ir.stmt, '{dest} = (int){n}[0]'.format(dest=dest, n=a0)))
    skel.cstub.optional.add(char_lut)

chpl.char @ C <-- ior.char : cost(1)
    convs.append(ir.Comment('in chapel, a char is a string of length 1'))
    # we can't allocate a new string, this would leak memory
    convs.append((ir.stmt, '{dest} = (const char*)&chpl_char_lut[2*(unsigned char){n}]'
                  .format(dest=dest, n=a0)))
    skel.cstub.optional.add(char_lut)

# COMPLEX - 32/64 Bit components
#------------------------------------------------------------------------
ior.fcomplex @ C <-- chpl.fcomplex : cost(2)
    fmt = {'dest':dest, 'n':a0}
    convs.append((ir.stmt, '{dest}.real = {n}.re'.format(**fmt)))
    convs.append((ir.stmt, '{dest}.imaginary = {n}.im'.format(**fmt)))

ior.dcomplex @ C <-- chpl.dcomplex : cost(2)
    fmt = {'dest':dest,'n':a0}
    convs.append((ir.stmt, '{dest}.real = {n}.re'.format(**fmt)))
    convs.append((ir.stmt, '{dest}.imaginary = {n}.im'.format(**fmt)))

chpl.fcomplex @ C <-- ior.fcomplex : cost(2)
    fmt = {'dest':dest,'n':a0}
    convs.append((ir.stmt, '{dest}.re = {n}.real'.format(**fmt)))
    convs.append((ir.stmt, '{dest}.im = {n}.imaginary'.format(**fmt)))

chpl.dcomplex @ C <-- ior.dcomplex : cost(2)
    fmt = {'dest':dest,'n':a0}
    convs.append((ir.stmt, '{dest}.re = {n}.real'.format(**fmt)))
    convs.append((ir.stmt, '{dest}.im = {n}.imaginary'.format(**fmt)))

# ENUM
#------------------------------------------------------------------------
ior.enum @ C <-- chpl.enum: cost(1)
    # No special treatment for enums, rely on chpl runtime to set it
    convs.append(ir.Stmt(ir.Assignment(dest, ir.Sign_extend(64, a0))))

chpl.enum @ C <-- ior.enum: cost(1)
    convs.append(ir.Stmt(ir.Assignment(dest, a0)))

# SELF
#------------------------------------------------------------------------
# ior.baseobject @ C <-- upcast(chpl.baseobject): cost(1)
#     # We should find a cleaner way of implementing this
#     #if a0 == 'self' and member_chk(ir.pure, attrs):
#     import pdb; pdb.set_trace()
#     convs.append(ir.Stmt(ir.Assignment(dest, '(({0})((struct sidl_BaseInterface__object*)self)<--d_object)'.format(c_gen(typ)))))
#     return dest

# STRING
#------------------------------------------------------------------------
ior.string @C <-- chpl.string: cost(0)
    convs.append(ir.Stmt(ir.Assignment(dest, a0)))

chpl.string @C <-- ior.string: cost(1)
    # Convert null pointer into empty string
    convs.append(ir.Stmt(ir.Assignment(dest, a0)))
    convs.append((ir.stmt, 'if ({n} == NULL) {n} = ""'.format(n=dest)))

# INT
#------------------------------------------------------------------------
ior.int @C <-- chpl.int: cost(0)
    pass
chpl.int @C <-- ior.int: cost(0)
    pass

# LONG
#------------------------------------------------------------------------
ior.long @C <-- chpl.long: cost(0)
    pass
chpl.long @C <-- ior.long: cost(0)
    pass

# VOID return type
#------------------------------------------------------------------------
chpl.void @C <-- ior.void:cost(0)
    pass

# FIXME:
# chpl.pointer_type @C <-- ior.*
#   a0 = ir.Pointer_expr(a0)

chpl.pointer_type @C <-- ior.pointer_type :cost(0)
    pass

ior.pointer_type @C <-- chpl.pointer_type :cost(0)
    pass

# STRUCT
#------------------------------------------------------------------------
# FIXME: we would actually need dynamic costs for this situation
ior.struct @C <-- chpl.struct: cost(3)
    items = get_struct_items(full_type)

    # recursively generate conversions for all items in the struct
    map(lambda (_, typ, name):
          codegen((('chpl', strip(typ)), a0+name+elem_access(typ)), strip(typ),
                  convs, skel, dest+'.'+name, typ), items)

    # if we need to convert one of the items, we need to convert all of them
    if convs: copy_other_items(convs, items, a0, '%s'%dest)

chpl.struct @C <-- ior.struct: cost(3)
    items = get_struct_items(full_type)
    map(lambda (_, typ, name):
          codegen((strip(typ), a0+'.'+name), ('chpl', strip(typ)),
                  convs, skel, dest+'.'+name, typ), items)
    if convs: copy_other_items(convs, items, '%s.'%a0, dest)

# SIDL ARRAY
#------------------------------------------------------------------------

# for sidl arrays we invoke a chapel code fragment from the C stub
chpl.array @chpl <-- chpl.new_array: cost(1)
    iorname, iortype = get_array_type(full_type)
    convs.append((ir.stmt, '{dest} = ({typ}){n}.self'
                  .format(dest=dest, n=a0, typ=iorname)))

chpl.new_array @chpl <-- ior.array @chpl: cost(2)
    iorname, iortype = get_array_type(full_type)
    skel.new_def(ir.Fn_defn([], ir.pt_void, '%s_to_chpl'%iorname, 
                            [ir.Arg([], ir.in_, iortype, 'ior')],
                            [ir.Stmt((ir.new, 'sidl.Array', [iorname, iortype, dest]))],
                            'argument conversion codelet'))


ior.array @chpl <-- chpl.array: cost(2)
    iorname, iortype = get_array_type(full_type)
    convs.append(ir.Assignment(dest, ir.Call('%s_to_chpl'%iorname, [a0])))

    # wrap the C type in a native Chapel object
    #if mode == sidl.inout:
    #    pre_call.append(ir.Stmt(ir.Assignment(iorname, name+'.self')))

                    
    # if name == '_retval':
    #     return_expr.append(conv)
    # else:
    #     post_call.append(ir.Stmt(ir.Assignment(name, conv)))
