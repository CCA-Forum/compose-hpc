# -*- python -*-
# Process this file with burg.py
%action arguments: (convs, optionals, deref, dest)
#------------------------------------------------------------------------
import ior, ir, sidl
import chapel.chpl as chpl
from codegen import CCodeGenerator, CFile

def c_gen(ir, scope=None):
    if scope == None:
        scope = CFile()
    return CCodeGenerator().generate(ir, scope)


def ir_type_to_chpl(typ):
    mapping = {
        ir.pt_void:     ir.pt_void,
        ir.pt_bool:     ir.Typedef_type('_Bool'),
        ir.pt_string:   ir.const_str,
        ir.pt_int:      ir.pt_int, #ir.Typedef_type('int32_t'),
        ir.pt_long:     ir.pt_long, #ir.Typedef_type('int64_t'),
        ir.pt_char:     ir.const_str,
        ir.pt_fcomplex: ir.Typedef_type('_complex64'), 
        ir.pt_dcomplex: ir.Typedef_type('_complex128'),
        ir.pt_float:    ir.pt_float,
        ir.pt_double:   ir.pt_double,
        sidl.pt_opaque: ir.Pointer_type(ir.pt_void)
        }
    try:
        return mapping[typ]
    except:
        if typ[0] == ir.enum: 
            return ir.Typedef_type('int64_t')
        if typ[0] == 'upcast': # part of the hack for self dereferencing
            return typ[1]
        return typ


char_lut = '''
/* This burial ground of bytes is used for char [in]out arguments. */
static const unsigned char chpl_char_lut[512] = {
  '''+' '.join(['%d, 0,'%i for i in range(0, 256)])+'''
};
'''
#------------------------------------------------------------------------
%rules:

#chpl.vcall @ chpl <-- ior.vcall @ C : cost(1)

# BOOL
ior.bool @ C <-- chpl.bool @ C : cost(0)
    convs.append(ir.Comment('sidl_bool is an int, but chapel bool is a char/_Bool'))
    convs.append((ir.stmt, '{dest} = ({typ}){p}{n}'
                  .format(dest=dest, n=a0, p=deref, typ=c_gen(ir.pt_bool))))

chpl.bool @ C <-- ior.bool @ C : cost(0)
    convs.append(ir.Comment('sidl_bool is an int, but chapel bool is a char/_Bool'))
    convs.append((ir.stmt, '{p}{dest} = ({typ}){n}'
                  .format(dest=dest, p=deref, n=a0, typ=c_gen(ir_type_to_chpl(ir.pt_bool)))))

# CHAR
ior.char @ C <-- chpl.char : cost(1)
    convs.append(ir.Comment('in chapel, a char is a string of length 1'))
    convs.append((ir.stmt, '{dest} = (int){p}{n}[0]'.format(dest=dest, n=a0, p=deref)))
    optionals.add(char_lut)

chpl.char @ C <-- ior.char : cost(1)
    convs.append(ir.Comment('in chapel, a char is a string of length 1'))
    # we can't allocate a new string, this would leak memory
    convs.append((ir.stmt, '{p}{dest} = (const char*)&chpl_char_lut[2*(unsigned char){n}]'
                  .format(dest=dest, p=deref, n=a0)))
    optionals.add(char_lut)

# COMPLEX - 32/64 Bit components
ior.fcomplex @ C <-- chpl.fcomplex : cost(1)
    fmt = {'dest':dest, 'n':a0, 'a': '->' if deref else '.' }
    convs.append((ir.stmt, '{dest}.real = {n}{a}re'.format(**fmt)))
    convs.append((ir.stmt, '{dest}.imaginary = {n}{a}im'.format(**fmt)))

ior.dcomplex @ C <-- chpl.dcomplex : cost(1)
    fmt = {'dest':dest,'n':a0, 'a': '->' if deref else '.' }
    convs.append((ir.stmt, '{dest}.real = {n}{a}re'.format(**fmt)))
    convs.append((ir.stmt, '{dest}.imaginary = {n}{a}im'.format(**fmt)))

chpl.fcomplex @ C <-- ior.fcomplex : cost(1)
    fmt = {'dest':dest,'n':a0, 'a': '->' if deref else '.' }
    convs.append((ir.stmt, '{dest}{a}re = {n}.real'.format(**fmt)))
    convs.append((ir.stmt, '{dest}{a}im = {n}.imaginary'.format(**fmt)))

chpl.dcomplex @ C <-- ior.dcomplex : cost(1)
    fmt = {'dest':dest,'n':a0, 'a': '->' if deref else '.' }
    convs.append((ir.stmt, '{dest}{a}re = {n}.real'.format(**fmt)))
    convs.append((ir.stmt, '{dest}{a}im = {n}.imaginary'.format(**fmt)))

# ENUM
ior.enum @ C <-- chpl.enum: cost(1)
    import pdb; pdb.set_trace()
    # No special treatment for enums, rely on chpl runtime to set it
    convs.append(ir.Stmt(ir.Assignment(dest, ir.Sign_extend(64, a0))))

chpl.enum @ C <-- ior.enum: cost(1)
    convs.append(ir.Stmt(ir.Assignment(dest, a0)))

# SELF
# ior.baseobject @ C <-- upcast(chpl.baseobject): cost(1)
#     # We should find a cleaner way of implementing this
#     #if a0 == 'self' and member_chk(ir.pure, attrs):
#     import pdb; pdb.set_trace()
#     convs.append(ir.Stmt(ir.Assignment(dest, '(({0})((struct sidl_BaseInterface__object*)self)<--d_object)'.format(c_gen(typ)))))
#     return dest

# STRING
ior.string @C <-- chpl.string: cost(0)
    convs.append(ir.Stmt(ir.Assignment(dest, deref+a0)))

chpl.string @C <-- ior.string: cost(1)
    # Convert null pointer into empty string
    convs.append(ir.Stmt(ir.Assignment(deref+dest, a0)))
    convs.append((ir.stmt, 'if ({p}{n} == NULL) {p}{n} = ""'.format(p=deref,n=dest)))

# INT
ior.int @C <-- chpl.int: cost(0)
    pass
chpl.int @C <-- ior.int: cost(0)
    pass

# LONG
ior.long @C <-- chpl.long: cost(0)
    pass
chpl.long @C <-- ior.long: cost(0)
    pass

# VOID return type
chpl.void @C <-- ior.void:cost(0)
    pass
