#!/usr/bin/env python
# -*- python -*-
## @package ir
# Convenience definitions for intermediate representation (IR) nodes.
#
# Please report bugs to <adrian@llnl.gov>.
#
# \authors <pre>
#
# Copyright (c) 2011, Lawrence Livermore National Security, LLC.
# Produced at the Lawrence Livermore National Laboratory
# Written by Adrian Prantl <adrian@llnl.gov>.
#  
# LLNL-CODE-473891.
# All rights reserved.
#  
# This file is part of BRAID. For details, see 
# http://compose-hpc.sourceforge.net/. 
# Please read the COPYRIGHT file for Our Notice and
# for the BSD License.
#
# </pre>
#
#
# <h2>Grammar definition</h2>
#
# Caveats: scoped IDs in IR must always be absolute.
#
#\verbatim
# [
#   _File = [ (Fn_decl | Fn_defn
# 	  | Var_decl
# 	  | Import
# 	  | type_decl(Type)
# 	  ) ],
#   Import = import(Id),
#   Stmt = (stmt(Do_while | While | break | Return | If | Goto | Expr) | Comment),
#   Return = return(Expr),
#   Goto = goto(Expr),
#   Do_while = do_while(Body, Expr),
#   While = while(Expr, Body),
#   If = if(Expr, Body),
#   Body = [Stmt],
#   Expr = ( Literal
# 	 | new(Type, [Arg])
#          | Var_decl
# 	 | VarRefExpr
# 	 | set_struct_item(Struct, Expr, Struct_item, Expr)
#          | assignment(VarRefExpr, Expr)
# 	 | infix_expr(Bin_op, Expr, Expr)
# 	 | prefix_expr(Un_op, Expr)
# 	 | sign_extend(Bits, Expr)
# 	 ),
#   Var_decl = ( var_decl(Type, Id)
# 	     | var_decl_init(Type, Id, Expr)
# 	     ),
#   Bin_op = (log_or|log_and|eq|ne|bit_or|bit_and|bit_xor|lt|gt|lshift|rshift
# 	   |plus|minus|times|divide|modulo|rem|pow),
#   Un_op = ( is|log_not|bit_not ),
#   Literal = ('STR' | 'FLOAT' | 'INT' | pure | result | Complex | true | false),
#   Complex = complex('FLOAT', 'FLOAT'),
#   Struct = struct((Scoped_id|Id), [Struct_item], DocComment),
#   Struct_item = struct_item(Type, Id),
#   Enum = enum(Id, [Enumerator], DocComment),
#   Enumerator = ( enumerator(Id) | enumerator(Id, 'INT')),
#   VarRefExpr = ( Id
# 	       | Pointer_expr
# 	       | Deref
# 	       | get_struct_item(Struct, Expr, Struct_item)
# 	       | call(Expr, [Expr])	 
# 	       ),
#   Pointer_expr = pointer_expr(VarRefExpr),
#   Deref = deref(VarRefExpr),
#   Fn_decl = fn_decl([Attr], Type, Id, [Arg], DocComment),
#   Fn_defn = fn_defn([Attr], Type, Id, [Arg], [Stmt], DocComment),
#   Arg = arg([Attr], Mode, Type, Id),
#   Attr = (static | pure),
#   Mode = (in | out | inout),
#   Type = ( Primitive_type
# 	 | Pointer_type
# 	 | typedef_type(Id)
# 	 | const(Type) 
# 	 | Struct
# 	 | Enum),
#   Primitive_type = primitive_type(
#       bool
#     | char
#     | int
#     | long
#     | float
#     | double
#     | fcomplex
#     | dcomplex
#     | string
#     | void ),
#   Pointer_type = pointer_type(Type|Fn_decl),
#   Scoped_id = scoped_id([Id], Extension),
#   Extension = 'STR',
#   Id = 'STR',
#   DocComment='STR',
#   Bits = 'INT',
#   Comment = comment('STR')
# ].
#\endverbatim


# Automatically generated by GRAMOLA.
#     ### ### #### ### ###
#     ### DO NOT EDIT! ###
#     ### ### #### ### ###
import types as PythonTypes


## Token definitions

arg = 'arg'
assignment = 'assignment'
bit_and = 'bit_and'
bit_not = 'bit_not'
bit_or = 'bit_or'
bit_xor = 'bit_xor'
bool = 'bool'
break_ = 'break'
call = 'call'
char = 'char'
comment = 'comment'
complex = 'complex'
const = 'const'
dcomplex = 'dcomplex'
deref = 'deref'
divide = 'divide'
do_while = 'do_while'
double = 'double'
enum = 'enum'
enumerator = 'enumerator'
eq = 'eq'
false = 'false'
fcomplex = 'fcomplex'
float = 'float'
fn_decl = 'fn_decl'
fn_defn = 'fn_defn'
get_struct_item = 'get_struct_item'
goto = 'goto'
gt = 'gt'
if_ = 'if'
import_ = 'import'
in_ = 'in'
infix_expr = 'infix_expr'
inout = 'inout'
int = 'int'
is_ = 'is'
log_and = 'log_and'
log_not = 'log_not'
log_or = 'log_or'
long = 'long'
lshift = 'lshift'
lt = 'lt'
minus = 'minus'
modulo = 'modulo'
ne = 'ne'
new = 'new'
out = 'out'
plus = 'plus'
pointer_expr = 'pointer_expr'
pointer_type = 'pointer_type'
pow = 'pow'
prefix_expr = 'prefix_expr'
primitive_type = 'primitive_type'
pure = 'pure'
rem = 'rem'
result = 'result'
return_ = 'return'
rshift = 'rshift'
scoped_id = 'scoped_id'
set_struct_item = 'set_struct_item'
sign_extend = 'sign_extend'
static = 'static'
stmt = 'stmt'
string = 'string'
struct = 'struct'
struct_item = 'struct_item'
times = 'times'
true = 'true'
type_decl = 'type_decl'
typedef_type = 'typedef_type'
var_decl = 'var_decl'
var_decl_init = 'var_decl_init'
void = 'void'
while_ = 'while'


## Constructor definitions

# skipping \c Type= (\c Primitive_type|\c Pointer_type|\c Typedef_type|\c Const|\c Struct|\c Enum)
def Import(*args):
    """
    Construct a "import" node. Valid arguments are 
    (\c Id())
    \return (\c "Import", \c Id())
    """
    f = Import
    if len(args) <> 1:
        print "**GRAMMAR ERROR: expected 1 arguments for a", f.__name__
        print "Most likely you want to enter \"up<enter>l<enter>\" now to see what happened."
        raise Exception("Grammar Error")
    if isinstance(args[0], PythonTypes.StringType):
        pass
    else:
        print f.__name__+"():\n    \"\"\"%s\"\"\"\n" %f.__doc__.replace("\\n","\n").replace("\return","Returns").replace("\\c ","")
        print "**GRAMMAR ERROR in argument args[0] = %s"%repr(args[0])
        print "  Most likely you now want to enter \"up<enter>l<enter>\"\n into the debugger to see what happened.\n"
        raise Exception("Grammar Error")
    return tuple(['import']+list(args))

# skipping \c Var_decl= (\c Var_decl|\c Var_decl_init)
def Fn_defn(*args):
    """
    Construct a "fn_defn" node. Valid arguments are 
    ([\c Attr()], \c Type(), \c Id(), [\c Arg()], [\c Stmt()], \c DocComment())
    \return (\c "Fn_defn", [\c Attr()], \c Type(), \c Id(), [\c Arg()], [\c Stmt()], \c DocComment())
    """
    f = Fn_defn
    if len(args) <> 6:
        print "**GRAMMAR ERROR: expected 6 arguments for a", f.__name__
        print "Most likely you want to enter \"up<enter>l<enter>\" now to see what happened."
        raise Exception("Grammar Error")
    if isinstance(args[0], list):
        for a in args[0]:
            if a == static:
                pass
            elif a == pure:
                pass
            else:
                print f.__name__+"():\n    \"\"\"%s\"\"\"\n" %f.__doc__.replace("\\n","\n").replace("\return","Returns").replace("\\c ","")
                print "**GRAMMAR ERROR in argument a = %s"%repr(a)
                print "  Most likely you now want to enter \"up<enter>l<enter>\"\n into the debugger to see what happened.\n"
                raise Exception("Grammar Error")
    else:
        print f.__name__+"():\n    \"\"\"%s\"\"\"\n" %f.__doc__.replace("\\n","\n").replace("\return","Returns").replace("\\c ","")
        print "**GRAMMAR ERROR in argument args[0] = %s"%repr(args[0])
        print "  Most likely you now want to enter \"up<enter>l<enter>\"\n into the debugger to see what happened.\n"
        raise Exception("Grammar Error")
    if isinstance(args[1], tuple) and args[1][0] == primitive_type:
        pass
    elif isinstance(args[1], tuple) and args[1][0] == pointer_type:
        pass
    elif isinstance(args[1], tuple) and args[1][0] == typedef_type:
        pass
    elif isinstance(args[1], tuple) and args[1][0] == const:
        pass
    elif isinstance(args[1], tuple) and args[1][0] == struct:
        pass
    elif isinstance(args[1], tuple) and args[1][0] == enum:
        pass
    else:
        print f.__name__+"():\n    \"\"\"%s\"\"\"\n" %f.__doc__.replace("\\n","\n").replace("\return","Returns").replace("\\c ","")
        print "**GRAMMAR ERROR in argument args[1] = %s"%repr(args[1])
        print "  Most likely you now want to enter \"up<enter>l<enter>\"\n into the debugger to see what happened.\n"
        raise Exception("Grammar Error")
    if isinstance(args[2], PythonTypes.StringType):
        pass
    else:
        print f.__name__+"():\n    \"\"\"%s\"\"\"\n" %f.__doc__.replace("\\n","\n").replace("\return","Returns").replace("\\c ","")
        print "**GRAMMAR ERROR in argument args[2] = %s"%repr(args[2])
        print "  Most likely you now want to enter \"up<enter>l<enter>\"\n into the debugger to see what happened.\n"
        raise Exception("Grammar Error")
    if isinstance(args[3], list):
        for a in args[3]:
            if isinstance(a, tuple) and a[0] == arg:
                pass
            else:
                print f.__name__+"():\n    \"\"\"%s\"\"\"\n" %f.__doc__.replace("\\n","\n").replace("\return","Returns").replace("\\c ","")
                print "**GRAMMAR ERROR in argument a = %s"%repr(a)
                print "  Most likely you now want to enter \"up<enter>l<enter>\"\n into the debugger to see what happened.\n"
                raise Exception("Grammar Error")
    else:
        print f.__name__+"():\n    \"\"\"%s\"\"\"\n" %f.__doc__.replace("\\n","\n").replace("\return","Returns").replace("\\c ","")
        print "**GRAMMAR ERROR in argument args[3] = %s"%repr(args[3])
        print "  Most likely you now want to enter \"up<enter>l<enter>\"\n into the debugger to see what happened.\n"
        raise Exception("Grammar Error")
    if isinstance(args[4], list):
        for a in args[4]:
            if isinstance(a, tuple) and a[0] == stmt:
                pass
            elif isinstance(a, tuple) and a[0] == comment:
                pass
            else:
                print f.__name__+"():\n    \"\"\"%s\"\"\"\n" %f.__doc__.replace("\\n","\n").replace("\return","Returns").replace("\\c ","")
                print "**GRAMMAR ERROR in argument a = %s"%repr(a)
                print "  Most likely you now want to enter \"up<enter>l<enter>\"\n into the debugger to see what happened.\n"
                raise Exception("Grammar Error")
    else:
        print f.__name__+"():\n    \"\"\"%s\"\"\"\n" %f.__doc__.replace("\\n","\n").replace("\return","Returns").replace("\\c ","")
        print "**GRAMMAR ERROR in argument args[4] = %s"%repr(args[4])
        print "  Most likely you now want to enter \"up<enter>l<enter>\"\n into the debugger to see what happened.\n"
        raise Exception("Grammar Error")
    if isinstance(args[5], PythonTypes.StringType):
        pass
    else:
        print f.__name__+"():\n    \"\"\"%s\"\"\"\n" %f.__doc__.replace("\\n","\n").replace("\return","Returns").replace("\\c ","")
        print "**GRAMMAR ERROR in argument args[5] = %s"%repr(args[5])
        print "  Most likely you now want to enter \"up<enter>l<enter>\"\n into the debugger to see what happened.\n"
        raise Exception("Grammar Error")
    return tuple(['fn_defn']+list(args))

def Fn_decl(*args):
    """
    Construct a "fn_decl" node. Valid arguments are 
    ([\c Attr()], \c Type(), \c Id(), [\c Arg()], \c DocComment())
    \return (\c "Fn_decl", [\c Attr()], \c Type(), \c Id(), [\c Arg()], \c DocComment())
    """
    f = Fn_decl
    if len(args) <> 5:
        print "**GRAMMAR ERROR: expected 5 arguments for a", f.__name__
        print "Most likely you want to enter \"up<enter>l<enter>\" now to see what happened."
        raise Exception("Grammar Error")
    if isinstance(args[0], list):
        for a in args[0]:
            if a == static:
                pass
            elif a == pure:
                pass
            else:
                print f.__name__+"():\n    \"\"\"%s\"\"\"\n" %f.__doc__.replace("\\n","\n").replace("\return","Returns").replace("\\c ","")
                print "**GRAMMAR ERROR in argument a = %s"%repr(a)
                print "  Most likely you now want to enter \"up<enter>l<enter>\"\n into the debugger to see what happened.\n"
                raise Exception("Grammar Error")
    else:
        print f.__name__+"():\n    \"\"\"%s\"\"\"\n" %f.__doc__.replace("\\n","\n").replace("\return","Returns").replace("\\c ","")
        print "**GRAMMAR ERROR in argument args[0] = %s"%repr(args[0])
        print "  Most likely you now want to enter \"up<enter>l<enter>\"\n into the debugger to see what happened.\n"
        raise Exception("Grammar Error")
    if isinstance(args[1], tuple) and args[1][0] == primitive_type:
        pass
    elif isinstance(args[1], tuple) and args[1][0] == pointer_type:
        pass
    elif isinstance(args[1], tuple) and args[1][0] == typedef_type:
        pass
    elif isinstance(args[1], tuple) and args[1][0] == const:
        pass
    elif isinstance(args[1], tuple) and args[1][0] == struct:
        pass
    elif isinstance(args[1], tuple) and args[1][0] == enum:
        pass
    else:
        print f.__name__+"():\n    \"\"\"%s\"\"\"\n" %f.__doc__.replace("\\n","\n").replace("\return","Returns").replace("\\c ","")
        print "**GRAMMAR ERROR in argument args[1] = %s"%repr(args[1])
        print "  Most likely you now want to enter \"up<enter>l<enter>\"\n into the debugger to see what happened.\n"
        raise Exception("Grammar Error")
    if isinstance(args[2], PythonTypes.StringType):
        pass
    else:
        print f.__name__+"():\n    \"\"\"%s\"\"\"\n" %f.__doc__.replace("\\n","\n").replace("\return","Returns").replace("\\c ","")
        print "**GRAMMAR ERROR in argument args[2] = %s"%repr(args[2])
        print "  Most likely you now want to enter \"up<enter>l<enter>\"\n into the debugger to see what happened.\n"
        raise Exception("Grammar Error")
    if isinstance(args[3], list):
        for a in args[3]:
            if isinstance(a, tuple) and a[0] == arg:
                pass
            else:
                print f.__name__+"():\n    \"\"\"%s\"\"\"\n" %f.__doc__.replace("\\n","\n").replace("\return","Returns").replace("\\c ","")
                print "**GRAMMAR ERROR in argument a = %s"%repr(a)
                print "  Most likely you now want to enter \"up<enter>l<enter>\"\n into the debugger to see what happened.\n"
                raise Exception("Grammar Error")
    else:
        print f.__name__+"():\n    \"\"\"%s\"\"\"\n" %f.__doc__.replace("\\n","\n").replace("\return","Returns").replace("\\c ","")
        print "**GRAMMAR ERROR in argument args[3] = %s"%repr(args[3])
        print "  Most likely you now want to enter \"up<enter>l<enter>\"\n into the debugger to see what happened.\n"
        raise Exception("Grammar Error")
    if isinstance(args[4], PythonTypes.StringType):
        pass
    else:
        print f.__name__+"():\n    \"\"\"%s\"\"\"\n" %f.__doc__.replace("\\n","\n").replace("\return","Returns").replace("\\c ","")
        print "**GRAMMAR ERROR in argument args[4] = %s"%repr(args[4])
        print "  Most likely you now want to enter \"up<enter>l<enter>\"\n into the debugger to see what happened.\n"
        raise Exception("Grammar Error")
    return tuple(['fn_decl']+list(args))

# skipping \c _File=[ (\c Fn_decl|\c Fn_defn|\c Var_decl|\c Import|\c Type_decl)]
def STR():
    return STR
def Goto(*args):
    """
    Construct a "goto" node. Valid arguments are 
    (\c Expr())
    \return (\c "Goto", \c Expr())
    """
    f = Goto
    if len(args) <> 1:
        print "**GRAMMAR ERROR: expected 1 arguments for a", f.__name__
        print "Most likely you want to enter \"up<enter>l<enter>\" now to see what happened."
        raise Exception("Grammar Error")
    if isinstance(args[0], PythonTypes.StringType):
        pass
    elif isinstance(args[0], PythonTypes.FloatType):
        pass
    elif isinstance(args[0], PythonTypes.IntType):
        pass
    elif args[0] == pure:
        pass
    elif args[0] == result:
        pass
    elif isinstance(args[0], tuple) and args[0][0] == complex:
        pass
    elif args[0] == true:
        pass
    elif args[0] == false:
        pass
    elif isinstance(args[0], tuple) and args[0][0] == new:
        pass
    elif isinstance(args[0], tuple) and args[0][0] == var_decl:
        pass
    elif isinstance(args[0], tuple) and args[0][0] == var_decl_init:
        pass
    elif isinstance(args[0], PythonTypes.StringType):
        pass
    elif isinstance(args[0], tuple) and args[0][0] == pointer_expr:
        pass
    elif isinstance(args[0], tuple) and args[0][0] == deref:
        pass
    elif isinstance(args[0], tuple) and args[0][0] == get_struct_item:
        pass
    elif isinstance(args[0], tuple) and args[0][0] == call:
        pass
    elif isinstance(args[0], tuple) and args[0][0] == set_struct_item:
        pass
    elif isinstance(args[0], tuple) and args[0][0] == assignment:
        pass
    elif isinstance(args[0], tuple) and args[0][0] == infix_expr:
        pass
    elif isinstance(args[0], tuple) and args[0][0] == prefix_expr:
        pass
    elif isinstance(args[0], tuple) and args[0][0] == sign_extend:
        pass
    else:
        print f.__name__+"():\n    \"\"\"%s\"\"\"\n" %f.__doc__.replace("\\n","\n").replace("\return","Returns").replace("\\c ","")
        print "**GRAMMAR ERROR in argument args[0] = %s"%repr(args[0])
        print "  Most likely you now want to enter \"up<enter>l<enter>\"\n into the debugger to see what happened.\n"
        raise Exception("Grammar Error")
    return tuple(['goto']+list(args))

# skipping \c Expr= (\c Literal|\c New|\c Var_decl|\c VarRefExpr|\c Set_struct_item|\c Assignment|\c Infix_expr|\c Prefix_expr|\c Sign_extend)
def If(*args):
    """
    Construct a "if" node. Valid arguments are 
    (\c Expr(), \c Body())
    \return (\c "If", \c Expr(), \c Body())
    """
    f = If
    if len(args) <> 2:
        print "**GRAMMAR ERROR: expected 2 arguments for a", f.__name__
        print "Most likely you want to enter \"up<enter>l<enter>\" now to see what happened."
        raise Exception("Grammar Error")
    if isinstance(args[0], PythonTypes.StringType):
        pass
    elif isinstance(args[0], PythonTypes.FloatType):
        pass
    elif isinstance(args[0], PythonTypes.IntType):
        pass
    elif args[0] == pure:
        pass
    elif args[0] == result:
        pass
    elif isinstance(args[0], tuple) and args[0][0] == complex:
        pass
    elif args[0] == true:
        pass
    elif args[0] == false:
        pass
    elif isinstance(args[0], tuple) and args[0][0] == new:
        pass
    elif isinstance(args[0], tuple) and args[0][0] == var_decl:
        pass
    elif isinstance(args[0], tuple) and args[0][0] == var_decl_init:
        pass
    elif isinstance(args[0], PythonTypes.StringType):
        pass
    elif isinstance(args[0], tuple) and args[0][0] == pointer_expr:
        pass
    elif isinstance(args[0], tuple) and args[0][0] == deref:
        pass
    elif isinstance(args[0], tuple) and args[0][0] == get_struct_item:
        pass
    elif isinstance(args[0], tuple) and args[0][0] == call:
        pass
    elif isinstance(args[0], tuple) and args[0][0] == set_struct_item:
        pass
    elif isinstance(args[0], tuple) and args[0][0] == assignment:
        pass
    elif isinstance(args[0], tuple) and args[0][0] == infix_expr:
        pass
    elif isinstance(args[0], tuple) and args[0][0] == prefix_expr:
        pass
    elif isinstance(args[0], tuple) and args[0][0] == sign_extend:
        pass
    else:
        print f.__name__+"():\n    \"\"\"%s\"\"\"\n" %f.__doc__.replace("\\n","\n").replace("\return","Returns").replace("\\c ","")
        print "**GRAMMAR ERROR in argument args[0] = %s"%repr(args[0])
        print "  Most likely you now want to enter \"up<enter>l<enter>\"\n into the debugger to see what happened.\n"
        raise Exception("Grammar Error")
    if isinstance(args[1], list):
        for a in args[1]:
            if isinstance(a, tuple) and a[0] == stmt:
                pass
            elif isinstance(a, tuple) and a[0] == comment:
                pass
            else:
                print f.__name__+"():\n    \"\"\"%s\"\"\"\n" %f.__doc__.replace("\\n","\n").replace("\return","Returns").replace("\\c ","")
                print "**GRAMMAR ERROR in argument a = %s"%repr(a)
                print "  Most likely you now want to enter \"up<enter>l<enter>\"\n into the debugger to see what happened.\n"
                raise Exception("Grammar Error")
    else:
        print f.__name__+"():\n    \"\"\"%s\"\"\"\n" %f.__doc__.replace("\\n","\n").replace("\return","Returns").replace("\\c ","")
        print "**GRAMMAR ERROR in argument args[1] = %s"%repr(args[1])
        print "  Most likely you now want to enter \"up<enter>l<enter>\"\n into the debugger to see what happened.\n"
        raise Exception("Grammar Error")
    return tuple(['if']+list(args))

def Return(*args):
    """
    Construct a "return" node. Valid arguments are 
    (\c Expr())
    \return (\c "Return", \c Expr())
    """
    f = Return
    if len(args) <> 1:
        print "**GRAMMAR ERROR: expected 1 arguments for a", f.__name__
        print "Most likely you want to enter \"up<enter>l<enter>\" now to see what happened."
        raise Exception("Grammar Error")
    if isinstance(args[0], PythonTypes.StringType):
        pass
    elif isinstance(args[0], PythonTypes.FloatType):
        pass
    elif isinstance(args[0], PythonTypes.IntType):
        pass
    elif args[0] == pure:
        pass
    elif args[0] == result:
        pass
    elif isinstance(args[0], tuple) and args[0][0] == complex:
        pass
    elif args[0] == true:
        pass
    elif args[0] == false:
        pass
    elif isinstance(args[0], tuple) and args[0][0] == new:
        pass
    elif isinstance(args[0], tuple) and args[0][0] == var_decl:
        pass
    elif isinstance(args[0], tuple) and args[0][0] == var_decl_init:
        pass
    elif isinstance(args[0], PythonTypes.StringType):
        pass
    elif isinstance(args[0], tuple) and args[0][0] == pointer_expr:
        pass
    elif isinstance(args[0], tuple) and args[0][0] == deref:
        pass
    elif isinstance(args[0], tuple) and args[0][0] == get_struct_item:
        pass
    elif isinstance(args[0], tuple) and args[0][0] == call:
        pass
    elif isinstance(args[0], tuple) and args[0][0] == set_struct_item:
        pass
    elif isinstance(args[0], tuple) and args[0][0] == assignment:
        pass
    elif isinstance(args[0], tuple) and args[0][0] == infix_expr:
        pass
    elif isinstance(args[0], tuple) and args[0][0] == prefix_expr:
        pass
    elif isinstance(args[0], tuple) and args[0][0] == sign_extend:
        pass
    else:
        print f.__name__+"():\n    \"\"\"%s\"\"\"\n" %f.__doc__.replace("\\n","\n").replace("\return","Returns").replace("\\c ","")
        print "**GRAMMAR ERROR in argument args[0] = %s"%repr(args[0])
        print "  Most likely you now want to enter \"up<enter>l<enter>\"\n into the debugger to see what happened.\n"
        raise Exception("Grammar Error")
    return tuple(['return']+list(args))

def While(*args):
    """
    Construct a "while" node. Valid arguments are 
    (\c Expr(), \c Body())
    \return (\c "While", \c Expr(), \c Body())
    """
    f = While
    if len(args) <> 2:
        print "**GRAMMAR ERROR: expected 2 arguments for a", f.__name__
        print "Most likely you want to enter \"up<enter>l<enter>\" now to see what happened."
        raise Exception("Grammar Error")
    if isinstance(args[0], PythonTypes.StringType):
        pass
    elif isinstance(args[0], PythonTypes.FloatType):
        pass
    elif isinstance(args[0], PythonTypes.IntType):
        pass
    elif args[0] == pure:
        pass
    elif args[0] == result:
        pass
    elif isinstance(args[0], tuple) and args[0][0] == complex:
        pass
    elif args[0] == true:
        pass
    elif args[0] == false:
        pass
    elif isinstance(args[0], tuple) and args[0][0] == new:
        pass
    elif isinstance(args[0], tuple) and args[0][0] == var_decl:
        pass
    elif isinstance(args[0], tuple) and args[0][0] == var_decl_init:
        pass
    elif isinstance(args[0], PythonTypes.StringType):
        pass
    elif isinstance(args[0], tuple) and args[0][0] == pointer_expr:
        pass
    elif isinstance(args[0], tuple) and args[0][0] == deref:
        pass
    elif isinstance(args[0], tuple) and args[0][0] == get_struct_item:
        pass
    elif isinstance(args[0], tuple) and args[0][0] == call:
        pass
    elif isinstance(args[0], tuple) and args[0][0] == set_struct_item:
        pass
    elif isinstance(args[0], tuple) and args[0][0] == assignment:
        pass
    elif isinstance(args[0], tuple) and args[0][0] == infix_expr:
        pass
    elif isinstance(args[0], tuple) and args[0][0] == prefix_expr:
        pass
    elif isinstance(args[0], tuple) and args[0][0] == sign_extend:
        pass
    else:
        print f.__name__+"():\n    \"\"\"%s\"\"\"\n" %f.__doc__.replace("\\n","\n").replace("\return","Returns").replace("\\c ","")
        print "**GRAMMAR ERROR in argument args[0] = %s"%repr(args[0])
        print "  Most likely you now want to enter \"up<enter>l<enter>\"\n into the debugger to see what happened.\n"
        raise Exception("Grammar Error")
    if isinstance(args[1], list):
        for a in args[1]:
            if isinstance(a, tuple) and a[0] == stmt:
                pass
            elif isinstance(a, tuple) and a[0] == comment:
                pass
            else:
                print f.__name__+"():\n    \"\"\"%s\"\"\"\n" %f.__doc__.replace("\\n","\n").replace("\return","Returns").replace("\\c ","")
                print "**GRAMMAR ERROR in argument a = %s"%repr(a)
                print "  Most likely you now want to enter \"up<enter>l<enter>\"\n into the debugger to see what happened.\n"
                raise Exception("Grammar Error")
    else:
        print f.__name__+"():\n    \"\"\"%s\"\"\"\n" %f.__doc__.replace("\\n","\n").replace("\return","Returns").replace("\\c ","")
        print "**GRAMMAR ERROR in argument args[1] = %s"%repr(args[1])
        print "  Most likely you now want to enter \"up<enter>l<enter>\"\n into the debugger to see what happened.\n"
        raise Exception("Grammar Error")
    return tuple(['while']+list(args))

def Do_while(*args):
    """
    Construct a "do_while" node. Valid arguments are 
    (\c Body(), \c Expr())
    \return (\c "Do_while", \c Body(), \c Expr())
    """
    f = Do_while
    if len(args) <> 2:
        print "**GRAMMAR ERROR: expected 2 arguments for a", f.__name__
        print "Most likely you want to enter \"up<enter>l<enter>\" now to see what happened."
        raise Exception("Grammar Error")
    if isinstance(args[0], list):
        for a in args[0]:
            if isinstance(a, tuple) and a[0] == stmt:
                pass
            elif isinstance(a, tuple) and a[0] == comment:
                pass
            else:
                print f.__name__+"():\n    \"\"\"%s\"\"\"\n" %f.__doc__.replace("\\n","\n").replace("\return","Returns").replace("\\c ","")
                print "**GRAMMAR ERROR in argument a = %s"%repr(a)
                print "  Most likely you now want to enter \"up<enter>l<enter>\"\n into the debugger to see what happened.\n"
                raise Exception("Grammar Error")
    else:
        print f.__name__+"():\n    \"\"\"%s\"\"\"\n" %f.__doc__.replace("\\n","\n").replace("\return","Returns").replace("\\c ","")
        print "**GRAMMAR ERROR in argument args[0] = %s"%repr(args[0])
        print "  Most likely you now want to enter \"up<enter>l<enter>\"\n into the debugger to see what happened.\n"
        raise Exception("Grammar Error")
    if isinstance(args[1], PythonTypes.StringType):
        pass
    elif isinstance(args[1], PythonTypes.FloatType):
        pass
    elif isinstance(args[1], PythonTypes.IntType):
        pass
    elif args[1] == pure:
        pass
    elif args[1] == result:
        pass
    elif isinstance(args[1], tuple) and args[1][0] == complex:
        pass
    elif args[1] == true:
        pass
    elif args[1] == false:
        pass
    elif isinstance(args[1], tuple) and args[1][0] == new:
        pass
    elif isinstance(args[1], tuple) and args[1][0] == var_decl:
        pass
    elif isinstance(args[1], tuple) and args[1][0] == var_decl_init:
        pass
    elif isinstance(args[1], PythonTypes.StringType):
        pass
    elif isinstance(args[1], tuple) and args[1][0] == pointer_expr:
        pass
    elif isinstance(args[1], tuple) and args[1][0] == deref:
        pass
    elif isinstance(args[1], tuple) and args[1][0] == get_struct_item:
        pass
    elif isinstance(args[1], tuple) and args[1][0] == call:
        pass
    elif isinstance(args[1], tuple) and args[1][0] == set_struct_item:
        pass
    elif isinstance(args[1], tuple) and args[1][0] == assignment:
        pass
    elif isinstance(args[1], tuple) and args[1][0] == infix_expr:
        pass
    elif isinstance(args[1], tuple) and args[1][0] == prefix_expr:
        pass
    elif isinstance(args[1], tuple) and args[1][0] == sign_extend:
        pass
    else:
        print f.__name__+"():\n    \"\"\"%s\"\"\"\n" %f.__doc__.replace("\\n","\n").replace("\return","Returns").replace("\\c ","")
        print "**GRAMMAR ERROR in argument args[1] = %s"%repr(args[1])
        print "  Most likely you now want to enter \"up<enter>l<enter>\"\n into the debugger to see what happened.\n"
        raise Exception("Grammar Error")
    return tuple(['do_while']+list(args))

def Comment(*args):
    """
    Construct a "comment" node. Valid arguments are 
    (STR())
    \return (\c "Comment", STR())
    """
    f = Comment
    if len(args) <> 1:
        print "**GRAMMAR ERROR: expected 1 arguments for a", f.__name__
        print "Most likely you want to enter \"up<enter>l<enter>\" now to see what happened."
        raise Exception("Grammar Error")
    if isinstance(args[0], PythonTypes.StringType):
        pass
    else:
        print f.__name__+"():\n    \"\"\"%s\"\"\"\n" %f.__doc__.replace("\\n","\n").replace("\return","Returns").replace("\\c ","")
        print "**GRAMMAR ERROR in argument args[0] = %s"%repr(args[0])
        print "  Most likely you now want to enter \"up<enter>l<enter>\"\n into the debugger to see what happened.\n"
        raise Exception("Grammar Error")
    return tuple(['comment']+list(args))

# skipping \c Stmt= (\c Stmt|\c Comment)
# skipping \c Body=[\c Stmt]
def Arg(*args):
    """
    Construct a "arg" node. Valid arguments are 
    ([\c Attr()], \c Mode(), \c Type(), \c Id())
    \return (\c "Arg", [\c Attr()], \c Mode(), \c Type(), \c Id())
    """
    f = Arg
    if len(args) <> 4:
        print "**GRAMMAR ERROR: expected 4 arguments for a", f.__name__
        print "Most likely you want to enter \"up<enter>l<enter>\" now to see what happened."
        raise Exception("Grammar Error")
    if isinstance(args[0], list):
        for a in args[0]:
            if a == static:
                pass
            elif a == pure:
                pass
            else:
                print f.__name__+"():\n    \"\"\"%s\"\"\"\n" %f.__doc__.replace("\\n","\n").replace("\return","Returns").replace("\\c ","")
                print "**GRAMMAR ERROR in argument a = %s"%repr(a)
                print "  Most likely you now want to enter \"up<enter>l<enter>\"\n into the debugger to see what happened.\n"
                raise Exception("Grammar Error")
    else:
        print f.__name__+"():\n    \"\"\"%s\"\"\"\n" %f.__doc__.replace("\\n","\n").replace("\return","Returns").replace("\\c ","")
        print "**GRAMMAR ERROR in argument args[0] = %s"%repr(args[0])
        print "  Most likely you now want to enter \"up<enter>l<enter>\"\n into the debugger to see what happened.\n"
        raise Exception("Grammar Error")
    if args[1] == in_:
        pass
    elif args[1] == out:
        pass
    elif args[1] == inout:
        pass
    else:
        print f.__name__+"():\n    \"\"\"%s\"\"\"\n" %f.__doc__.replace("\\n","\n").replace("\return","Returns").replace("\\c ","")
        print "**GRAMMAR ERROR in argument args[1] = %s"%repr(args[1])
        print "  Most likely you now want to enter \"up<enter>l<enter>\"\n into the debugger to see what happened.\n"
        raise Exception("Grammar Error")
    if isinstance(args[2], tuple) and args[2][0] == primitive_type:
        pass
    elif isinstance(args[2], tuple) and args[2][0] == pointer_type:
        pass
    elif isinstance(args[2], tuple) and args[2][0] == typedef_type:
        pass
    elif isinstance(args[2], tuple) and args[2][0] == const:
        pass
    elif isinstance(args[2], tuple) and args[2][0] == struct:
        pass
    elif isinstance(args[2], tuple) and args[2][0] == enum:
        pass
    else:
        print f.__name__+"():\n    \"\"\"%s\"\"\"\n" %f.__doc__.replace("\\n","\n").replace("\return","Returns").replace("\\c ","")
        print "**GRAMMAR ERROR in argument args[2] = %s"%repr(args[2])
        print "  Most likely you now want to enter \"up<enter>l<enter>\"\n into the debugger to see what happened.\n"
        raise Exception("Grammar Error")
    if isinstance(args[3], PythonTypes.StringType):
        pass
    else:
        print f.__name__+"():\n    \"\"\"%s\"\"\"\n" %f.__doc__.replace("\\n","\n").replace("\return","Returns").replace("\\c ","")
        print "**GRAMMAR ERROR in argument args[3] = %s"%repr(args[3])
        print "  Most likely you now want to enter \"up<enter>l<enter>\"\n into the debugger to see what happened.\n"
        raise Exception("Grammar Error")
    return tuple(['arg']+list(args))

def Struct(*args):
    """
    Construct a "struct" node. Valid arguments are 
    (\c Scoped_id()
    |\c Id(), [\c Struct_item()], \c DocComment())
    \return (\c "Struct", \c Scoped_id()
    |\c Id(), [\c Struct_item()], \c DocComment())
    """
    f = Struct
    if len(args) <> 3:
        print "**GRAMMAR ERROR: expected 3 arguments for a", f.__name__
        print "Most likely you want to enter \"up<enter>l<enter>\" now to see what happened."
        raise Exception("Grammar Error")
    if isinstance(args[0], tuple) and args[0][0] == scoped_id:
        pass
    elif isinstance(args[0], PythonTypes.StringType):
        pass
    else:
        print f.__name__+"():\n    \"\"\"%s\"\"\"\n" %f.__doc__.replace("\\n","\n").replace("\return","Returns").replace("\\c ","")
        print "**GRAMMAR ERROR in argument args[0] = %s"%repr(args[0])
        print "  Most likely you now want to enter \"up<enter>l<enter>\"\n into the debugger to see what happened.\n"
        raise Exception("Grammar Error")
    if isinstance(args[1], list):
        for a in args[1]:
            if isinstance(a, tuple) and a[0] == struct_item:
                pass
            else:
                print f.__name__+"():\n    \"\"\"%s\"\"\"\n" %f.__doc__.replace("\\n","\n").replace("\return","Returns").replace("\\c ","")
                print "**GRAMMAR ERROR in argument a = %s"%repr(a)
                print "  Most likely you now want to enter \"up<enter>l<enter>\"\n into the debugger to see what happened.\n"
                raise Exception("Grammar Error")
    else:
        print f.__name__+"():\n    \"\"\"%s\"\"\"\n" %f.__doc__.replace("\\n","\n").replace("\return","Returns").replace("\\c ","")
        print "**GRAMMAR ERROR in argument args[1] = %s"%repr(args[1])
        print "  Most likely you now want to enter \"up<enter>l<enter>\"\n into the debugger to see what happened.\n"
        raise Exception("Grammar Error")
    if isinstance(args[2], PythonTypes.StringType):
        pass
    else:
        print f.__name__+"():\n    \"\"\"%s\"\"\"\n" %f.__doc__.replace("\\n","\n").replace("\return","Returns").replace("\\c ","")
        print "**GRAMMAR ERROR in argument args[2] = %s"%repr(args[2])
        print "  Most likely you now want to enter \"up<enter>l<enter>\"\n into the debugger to see what happened.\n"
        raise Exception("Grammar Error")
    return tuple(['struct']+list(args))

def Struct_item(*args):
    """
    Construct a "struct_item" node. Valid arguments are 
    (\c Type(), \c Id())
    \return (\c "Struct_item", \c Type(), \c Id())
    """
    f = Struct_item
    if len(args) <> 2:
        print "**GRAMMAR ERROR: expected 2 arguments for a", f.__name__
        print "Most likely you want to enter \"up<enter>l<enter>\" now to see what happened."
        raise Exception("Grammar Error")
    if isinstance(args[0], tuple) and args[0][0] == primitive_type:
        pass
    elif isinstance(args[0], tuple) and args[0][0] == pointer_type:
        pass
    elif isinstance(args[0], tuple) and args[0][0] == typedef_type:
        pass
    elif isinstance(args[0], tuple) and args[0][0] == const:
        pass
    elif isinstance(args[0], tuple) and args[0][0] == struct:
        pass
    elif isinstance(args[0], tuple) and args[0][0] == enum:
        pass
    else:
        print f.__name__+"():\n    \"\"\"%s\"\"\"\n" %f.__doc__.replace("\\n","\n").replace("\return","Returns").replace("\\c ","")
        print "**GRAMMAR ERROR in argument args[0] = %s"%repr(args[0])
        print "  Most likely you now want to enter \"up<enter>l<enter>\"\n into the debugger to see what happened.\n"
        raise Exception("Grammar Error")
    if isinstance(args[1], PythonTypes.StringType):
        pass
    else:
        print f.__name__+"():\n    \"\"\"%s\"\"\"\n" %f.__doc__.replace("\\n","\n").replace("\return","Returns").replace("\\c ","")
        print "**GRAMMAR ERROR in argument args[1] = %s"%repr(args[1])
        print "  Most likely you now want to enter \"up<enter>l<enter>\"\n into the debugger to see what happened.\n"
        raise Exception("Grammar Error")
    return tuple(['struct_item']+list(args))

# skipping \c VarRefExpr= (\c Id|\c Pointer_expr|\c Deref|\c Get_struct_item|\c Call)
# skipping \c Bin_op= (log_or|log_and|eq|ne|bit_or|bit_and|bit_xor|lt|gt|lshift|rshift|plus|minus|times|divide|modulo|rem|pow)
# skipping \c Un_op= (is|log_not|bit_not)
def INT():
    return INT
# skipping \c Literal= (STR|FLOAT|INT|pure|result|\c Complex|true|false)
def Complex(*args):
    """
    Construct a "complex" node. Valid arguments are 
    (FLOAT(), FLOAT())
    \return (\c "Complex", FLOAT(), FLOAT())
    """
    f = Complex
    if len(args) <> 2:
        print "**GRAMMAR ERROR: expected 2 arguments for a", f.__name__
        print "Most likely you want to enter \"up<enter>l<enter>\" now to see what happened."
        raise Exception("Grammar Error")
    if isinstance(args[0], PythonTypes.FloatType):
        pass
    else:
        print f.__name__+"():\n    \"\"\"%s\"\"\"\n" %f.__doc__.replace("\\n","\n").replace("\return","Returns").replace("\\c ","")
        print "**GRAMMAR ERROR in argument args[0] = %s"%repr(args[0])
        print "  Most likely you now want to enter \"up<enter>l<enter>\"\n into the debugger to see what happened.\n"
        raise Exception("Grammar Error")
    if isinstance(args[1], PythonTypes.FloatType):
        pass
    else:
        print f.__name__+"():\n    \"\"\"%s\"\"\"\n" %f.__doc__.replace("\\n","\n").replace("\return","Returns").replace("\\c ","")
        print "**GRAMMAR ERROR in argument args[1] = %s"%repr(args[1])
        print "  Most likely you now want to enter \"up<enter>l<enter>\"\n into the debugger to see what happened.\n"
        raise Exception("Grammar Error")
    return tuple(['complex']+list(args))

def Scoped_id(*args):
    """
    Construct a "scoped_id" node. Valid arguments are 
    ([\c Id()], \c Extension())
    \return (\c "Scoped_id", [\c Id()], \c Extension())
    """
    f = Scoped_id
    if len(args) <> 2:
        print "**GRAMMAR ERROR: expected 2 arguments for a", f.__name__
        print "Most likely you want to enter \"up<enter>l<enter>\" now to see what happened."
        raise Exception("Grammar Error")
    if isinstance(args[0], list):
        for a in args[0]:
            if isinstance(a, PythonTypes.StringType):
                pass
            else:
                print f.__name__+"():\n    \"\"\"%s\"\"\"\n" %f.__doc__.replace("\\n","\n").replace("\return","Returns").replace("\\c ","")
                print "**GRAMMAR ERROR in argument a = %s"%repr(a)
                print "  Most likely you now want to enter \"up<enter>l<enter>\"\n into the debugger to see what happened.\n"
                raise Exception("Grammar Error")
    else:
        print f.__name__+"():\n    \"\"\"%s\"\"\"\n" %f.__doc__.replace("\\n","\n").replace("\return","Returns").replace("\\c ","")
        print "**GRAMMAR ERROR in argument args[0] = %s"%repr(args[0])
        print "  Most likely you now want to enter \"up<enter>l<enter>\"\n into the debugger to see what happened.\n"
        raise Exception("Grammar Error")
    if isinstance(args[1], PythonTypes.StringType):
        pass
    else:
        print f.__name__+"():\n    \"\"\"%s\"\"\"\n" %f.__doc__.replace("\\n","\n").replace("\return","Returns").replace("\\c ","")
        print "**GRAMMAR ERROR in argument args[1] = %s"%repr(args[1])
        print "  Most likely you now want to enter \"up<enter>l<enter>\"\n into the debugger to see what happened.\n"
        raise Exception("Grammar Error")
    return tuple(['scoped_id']+list(args))

def STR():
    return STR
# skipping \c Enumerator= (\c Enumerator|\c Enumerator)
def Enum(*args):
    """
    Construct a "enum" node. Valid arguments are 
    (\c Id(), [\c Enumerator()], \c DocComment())
    \return (\c "Enum", \c Id(), [\c Enumerator()], \c DocComment())
    """
    f = Enum
    if len(args) <> 3:
        print "**GRAMMAR ERROR: expected 3 arguments for a", f.__name__
        print "Most likely you want to enter \"up<enter>l<enter>\" now to see what happened."
        raise Exception("Grammar Error")
    if isinstance(args[0], PythonTypes.StringType):
        pass
    else:
        print f.__name__+"():\n    \"\"\"%s\"\"\"\n" %f.__doc__.replace("\\n","\n").replace("\return","Returns").replace("\\c ","")
        print "**GRAMMAR ERROR in argument args[0] = %s"%repr(args[0])
        print "  Most likely you now want to enter \"up<enter>l<enter>\"\n into the debugger to see what happened.\n"
        raise Exception("Grammar Error")
    if isinstance(args[1], list):
        for a in args[1]:
            if isinstance(a, tuple) and a[0] == enumerator:
                pass
            elif isinstance(a, tuple) and a[0] == enumerator:
                pass
            else:
                print f.__name__+"():\n    \"\"\"%s\"\"\"\n" %f.__doc__.replace("\\n","\n").replace("\return","Returns").replace("\\c ","")
                print "**GRAMMAR ERROR in argument a = %s"%repr(a)
                print "  Most likely you now want to enter \"up<enter>l<enter>\"\n into the debugger to see what happened.\n"
                raise Exception("Grammar Error")
    else:
        print f.__name__+"():\n    \"\"\"%s\"\"\"\n" %f.__doc__.replace("\\n","\n").replace("\return","Returns").replace("\\c ","")
        print "**GRAMMAR ERROR in argument args[1] = %s"%repr(args[1])
        print "  Most likely you now want to enter \"up<enter>l<enter>\"\n into the debugger to see what happened.\n"
        raise Exception("Grammar Error")
    if isinstance(args[2], PythonTypes.StringType):
        pass
    else:
        print f.__name__+"():\n    \"\"\"%s\"\"\"\n" %f.__doc__.replace("\\n","\n").replace("\return","Returns").replace("\\c ","")
        print "**GRAMMAR ERROR in argument args[2] = %s"%repr(args[2])
        print "  Most likely you now want to enter \"up<enter>l<enter>\"\n into the debugger to see what happened.\n"
        raise Exception("Grammar Error")
    return tuple(['enum']+list(args))

def Deref(*args):
    """
    Construct a "deref" node. Valid arguments are 
    (\c VarRefExpr())
    \return (\c "Deref", \c VarRefExpr())
    """
    f = Deref
    if len(args) <> 1:
        print "**GRAMMAR ERROR: expected 1 arguments for a", f.__name__
        print "Most likely you want to enter \"up<enter>l<enter>\" now to see what happened."
        raise Exception("Grammar Error")
    if isinstance(args[0], PythonTypes.StringType):
        pass
    elif isinstance(args[0], tuple) and args[0][0] == pointer_expr:
        pass
    elif isinstance(args[0], tuple) and args[0][0] == deref:
        pass
    elif isinstance(args[0], tuple) and args[0][0] == get_struct_item:
        pass
    elif isinstance(args[0], tuple) and args[0][0] == call:
        pass
    else:
        print f.__name__+"():\n    \"\"\"%s\"\"\"\n" %f.__doc__.replace("\\n","\n").replace("\return","Returns").replace("\\c ","")
        print "**GRAMMAR ERROR in argument args[0] = %s"%repr(args[0])
        print "  Most likely you now want to enter \"up<enter>l<enter>\"\n into the debugger to see what happened.\n"
        raise Exception("Grammar Error")
    return tuple(['deref']+list(args))

def Pointer_expr(*args):
    """
    Construct a "pointer_expr" node. Valid arguments are 
    (\c VarRefExpr())
    \return (\c "Pointer_expr", \c VarRefExpr())
    """
    f = Pointer_expr
    if len(args) <> 1:
        print "**GRAMMAR ERROR: expected 1 arguments for a", f.__name__
        print "Most likely you want to enter \"up<enter>l<enter>\" now to see what happened."
        raise Exception("Grammar Error")
    if isinstance(args[0], PythonTypes.StringType):
        pass
    elif isinstance(args[0], tuple) and args[0][0] == pointer_expr:
        pass
    elif isinstance(args[0], tuple) and args[0][0] == deref:
        pass
    elif isinstance(args[0], tuple) and args[0][0] == get_struct_item:
        pass
    elif isinstance(args[0], tuple) and args[0][0] == call:
        pass
    else:
        print f.__name__+"():\n    \"\"\"%s\"\"\"\n" %f.__doc__.replace("\\n","\n").replace("\return","Returns").replace("\\c ","")
        print "**GRAMMAR ERROR in argument args[0] = %s"%repr(args[0])
        print "  Most likely you now want to enter \"up<enter>l<enter>\"\n into the debugger to see what happened.\n"
        raise Exception("Grammar Error")
    return tuple(['pointer_expr']+list(args))

# skipping \c Attr= (static|pure)
# skipping \c Mode= (in|out|inout)
def Pointer_type(*args):
    """
    Construct a "pointer_type" node. Valid arguments are 
    (\c Type()
    |\c Fn_decl())
    \return (\c "Pointer_type", \c Type()
    |\c Fn_decl())
    """
    f = Pointer_type
    if len(args) <> 1:
        print "**GRAMMAR ERROR: expected 1 arguments for a", f.__name__
        print "Most likely you want to enter \"up<enter>l<enter>\" now to see what happened."
        raise Exception("Grammar Error")
    if isinstance(args[0], tuple) and args[0][0] == primitive_type:
        pass
    elif isinstance(args[0], tuple) and args[0][0] == pointer_type:
        pass
    elif isinstance(args[0], tuple) and args[0][0] == typedef_type:
        pass
    elif isinstance(args[0], tuple) and args[0][0] == const:
        pass
    elif isinstance(args[0], tuple) and args[0][0] == struct:
        pass
    elif isinstance(args[0], tuple) and args[0][0] == enum:
        pass
    elif isinstance(args[0], tuple) and args[0][0] == fn_decl:
        pass
    else:
        print f.__name__+"():\n    \"\"\"%s\"\"\"\n" %f.__doc__.replace("\\n","\n").replace("\return","Returns").replace("\\c ","")
        print "**GRAMMAR ERROR in argument args[0] = %s"%repr(args[0])
        print "  Most likely you now want to enter \"up<enter>l<enter>\"\n into the debugger to see what happened.\n"
        raise Exception("Grammar Error")
    return tuple(['pointer_type']+list(args))

def Primitive_type(*args):
    """
    Construct a "primitive_type" node. Valid arguments are 
    (Bool()
    |Char()
    |Int()
    |Long()
    |Float()
    |Double()
    |Fcomplex()
    |Dcomplex()
    |String()
    |Void())
    \return (\c "Primitive_type", Bool()
    |Char()
    |Int()
    |Long()
    |Float()
    |Double()
    |Fcomplex()
    |Dcomplex()
    |String()
    |Void())
    """
    f = Primitive_type
    if len(args) <> 1:
        print "**GRAMMAR ERROR: expected 1 arguments for a", f.__name__
        print "Most likely you want to enter \"up<enter>l<enter>\" now to see what happened."
        raise Exception("Grammar Error")
    if args[0] == bool:
        pass
    elif args[0] == char:
        pass
    elif args[0] == int:
        pass
    elif args[0] == long:
        pass
    elif args[0] == float:
        pass
    elif args[0] == double:
        pass
    elif args[0] == fcomplex:
        pass
    elif args[0] == dcomplex:
        pass
    elif args[0] == string:
        pass
    elif args[0] == void:
        pass
    else:
        print f.__name__+"():\n    \"\"\"%s\"\"\"\n" %f.__doc__.replace("\\n","\n").replace("\return","Returns").replace("\\c ","")
        print "**GRAMMAR ERROR in argument args[0] = %s"%repr(args[0])
        print "  Most likely you now want to enter \"up<enter>l<enter>\"\n into the debugger to see what happened.\n"
        raise Exception("Grammar Error")
    return tuple(['primitive_type']+list(args))

def STR():
    return STR
def Type_decl(*args):
    """
    Construct a "type_decl" node. Valid arguments are 
    (\c Type())
    \return (\c "Type_decl", \c Type())
    """
    f = Type_decl
    if len(args) <> 1:
        print "**GRAMMAR ERROR: expected 1 arguments for a", f.__name__
        print "Most likely you want to enter \"up<enter>l<enter>\" now to see what happened."
        raise Exception("Grammar Error")
    if isinstance(args[0], tuple) and args[0][0] == primitive_type:
        pass
    elif isinstance(args[0], tuple) and args[0][0] == pointer_type:
        pass
    elif isinstance(args[0], tuple) and args[0][0] == typedef_type:
        pass
    elif isinstance(args[0], tuple) and args[0][0] == const:
        pass
    elif isinstance(args[0], tuple) and args[0][0] == struct:
        pass
    elif isinstance(args[0], tuple) and args[0][0] == enum:
        pass
    else:
        print f.__name__+"():\n    \"\"\"%s\"\"\"\n" %f.__doc__.replace("\\n","\n").replace("\return","Returns").replace("\\c ","")
        print "**GRAMMAR ERROR in argument args[0] = %s"%repr(args[0])
        print "  Most likely you now want to enter \"up<enter>l<enter>\"\n into the debugger to see what happened.\n"
        raise Exception("Grammar Error")
    return tuple(['type_decl']+list(args))

def Stmt(*args):
    """
    Construct a "stmt" node. Valid arguments are 
    (\c Do_while()
    |\c While()
    |Break()
    |\c Return()
    |\c If()
    |\c Goto()
    |\c Expr())
    \return (\c "Stmt", \c Do_while()
    |\c While()
    |Break()
    |\c Return()
    |\c If()
    |\c Goto()
    |\c Expr())
    """
    f = Stmt
    if len(args) <> 1:
        print "**GRAMMAR ERROR: expected 1 arguments for a", f.__name__
        print "Most likely you want to enter \"up<enter>l<enter>\" now to see what happened."
        raise Exception("Grammar Error")
    if isinstance(args[0], tuple) and args[0][0] == do_while:
        pass
    elif isinstance(args[0], tuple) and args[0][0] == while_:
        pass
    elif args[0] == break_:
        pass
    elif isinstance(args[0], tuple) and args[0][0] == return_:
        pass
    elif isinstance(args[0], tuple) and args[0][0] == if_:
        pass
    elif isinstance(args[0], tuple) and args[0][0] == goto:
        pass
    elif isinstance(args[0], PythonTypes.StringType):
        pass
    elif isinstance(args[0], PythonTypes.FloatType):
        pass
    elif isinstance(args[0], PythonTypes.IntType):
        pass
    elif args[0] == pure:
        pass
    elif args[0] == result:
        pass
    elif isinstance(args[0], tuple) and args[0][0] == complex:
        pass
    elif args[0] == true:
        pass
    elif args[0] == false:
        pass
    elif isinstance(args[0], tuple) and args[0][0] == new:
        pass
    elif isinstance(args[0], tuple) and args[0][0] == var_decl:
        pass
    elif isinstance(args[0], tuple) and args[0][0] == var_decl_init:
        pass
    elif isinstance(args[0], PythonTypes.StringType):
        pass
    elif isinstance(args[0], tuple) and args[0][0] == pointer_expr:
        pass
    elif isinstance(args[0], tuple) and args[0][0] == deref:
        pass
    elif isinstance(args[0], tuple) and args[0][0] == get_struct_item:
        pass
    elif isinstance(args[0], tuple) and args[0][0] == call:
        pass
    elif isinstance(args[0], tuple) and args[0][0] == set_struct_item:
        pass
    elif isinstance(args[0], tuple) and args[0][0] == assignment:
        pass
    elif isinstance(args[0], tuple) and args[0][0] == infix_expr:
        pass
    elif isinstance(args[0], tuple) and args[0][0] == prefix_expr:
        pass
    elif isinstance(args[0], tuple) and args[0][0] == sign_extend:
        pass
    else:
        print f.__name__+"():\n    \"\"\"%s\"\"\"\n" %f.__doc__.replace("\\n","\n").replace("\return","Returns").replace("\\c ","")
        print "**GRAMMAR ERROR in argument args[0] = %s"%repr(args[0])
        print "  Most likely you now want to enter \"up<enter>l<enter>\"\n into the debugger to see what happened.\n"
        raise Exception("Grammar Error")
    return tuple(['stmt']+list(args))

def New(*args):
    """
    Construct a "new" node. Valid arguments are 
    (\c Type(), [\c Arg()])
    \return (\c "New", \c Type(), [\c Arg()])
    """
    f = New
    if len(args) <> 2:
        print "**GRAMMAR ERROR: expected 2 arguments for a", f.__name__
        print "Most likely you want to enter \"up<enter>l<enter>\" now to see what happened."
        raise Exception("Grammar Error")
    if isinstance(args[0], tuple) and args[0][0] == primitive_type:
        pass
    elif isinstance(args[0], tuple) and args[0][0] == pointer_type:
        pass
    elif isinstance(args[0], tuple) and args[0][0] == typedef_type:
        pass
    elif isinstance(args[0], tuple) and args[0][0] == const:
        pass
    elif isinstance(args[0], tuple) and args[0][0] == struct:
        pass
    elif isinstance(args[0], tuple) and args[0][0] == enum:
        pass
    else:
        print f.__name__+"():\n    \"\"\"%s\"\"\"\n" %f.__doc__.replace("\\n","\n").replace("\return","Returns").replace("\\c ","")
        print "**GRAMMAR ERROR in argument args[0] = %s"%repr(args[0])
        print "  Most likely you now want to enter \"up<enter>l<enter>\"\n into the debugger to see what happened.\n"
        raise Exception("Grammar Error")
    if isinstance(args[1], list):
        for a in args[1]:
            if isinstance(a, tuple) and a[0] == arg:
                pass
            else:
                print f.__name__+"():\n    \"\"\"%s\"\"\"\n" %f.__doc__.replace("\\n","\n").replace("\return","Returns").replace("\\c ","")
                print "**GRAMMAR ERROR in argument a = %s"%repr(a)
                print "  Most likely you now want to enter \"up<enter>l<enter>\"\n into the debugger to see what happened.\n"
                raise Exception("Grammar Error")
    else:
        print f.__name__+"():\n    \"\"\"%s\"\"\"\n" %f.__doc__.replace("\\n","\n").replace("\return","Returns").replace("\\c ","")
        print "**GRAMMAR ERROR in argument args[1] = %s"%repr(args[1])
        print "  Most likely you now want to enter \"up<enter>l<enter>\"\n into the debugger to see what happened.\n"
        raise Exception("Grammar Error")
    return tuple(['new']+list(args))

def Set_struct_item(*args):
    """
    Construct a "set_struct_item" node. Valid arguments are 
    (\c Struct(), \c Expr(), \c Struct_item(), \c Expr())
    \return (\c "Set_struct_item", \c Struct(), \c Expr(), \c Struct_item(), \c Expr())
    """
    f = Set_struct_item
    if len(args) <> 4:
        print "**GRAMMAR ERROR: expected 4 arguments for a", f.__name__
        print "Most likely you want to enter \"up<enter>l<enter>\" now to see what happened."
        raise Exception("Grammar Error")
    if isinstance(args[0], tuple) and args[0][0] == struct:
        pass
    else:
        print f.__name__+"():\n    \"\"\"%s\"\"\"\n" %f.__doc__.replace("\\n","\n").replace("\return","Returns").replace("\\c ","")
        print "**GRAMMAR ERROR in argument args[0] = %s"%repr(args[0])
        print "  Most likely you now want to enter \"up<enter>l<enter>\"\n into the debugger to see what happened.\n"
        raise Exception("Grammar Error")
    if isinstance(args[1], PythonTypes.StringType):
        pass
    elif isinstance(args[1], PythonTypes.FloatType):
        pass
    elif isinstance(args[1], PythonTypes.IntType):
        pass
    elif args[1] == pure:
        pass
    elif args[1] == result:
        pass
    elif isinstance(args[1], tuple) and args[1][0] == complex:
        pass
    elif args[1] == true:
        pass
    elif args[1] == false:
        pass
    elif isinstance(args[1], tuple) and args[1][0] == new:
        pass
    elif isinstance(args[1], tuple) and args[1][0] == var_decl:
        pass
    elif isinstance(args[1], tuple) and args[1][0] == var_decl_init:
        pass
    elif isinstance(args[1], PythonTypes.StringType):
        pass
    elif isinstance(args[1], tuple) and args[1][0] == pointer_expr:
        pass
    elif isinstance(args[1], tuple) and args[1][0] == deref:
        pass
    elif isinstance(args[1], tuple) and args[1][0] == get_struct_item:
        pass
    elif isinstance(args[1], tuple) and args[1][0] == call:
        pass
    elif isinstance(args[1], tuple) and args[1][0] == set_struct_item:
        pass
    elif isinstance(args[1], tuple) and args[1][0] == assignment:
        pass
    elif isinstance(args[1], tuple) and args[1][0] == infix_expr:
        pass
    elif isinstance(args[1], tuple) and args[1][0] == prefix_expr:
        pass
    elif isinstance(args[1], tuple) and args[1][0] == sign_extend:
        pass
    else:
        print f.__name__+"():\n    \"\"\"%s\"\"\"\n" %f.__doc__.replace("\\n","\n").replace("\return","Returns").replace("\\c ","")
        print "**GRAMMAR ERROR in argument args[1] = %s"%repr(args[1])
        print "  Most likely you now want to enter \"up<enter>l<enter>\"\n into the debugger to see what happened.\n"
        raise Exception("Grammar Error")
    if isinstance(args[2], tuple) and args[2][0] == struct_item:
        pass
    else:
        print f.__name__+"():\n    \"\"\"%s\"\"\"\n" %f.__doc__.replace("\\n","\n").replace("\return","Returns").replace("\\c ","")
        print "**GRAMMAR ERROR in argument args[2] = %s"%repr(args[2])
        print "  Most likely you now want to enter \"up<enter>l<enter>\"\n into the debugger to see what happened.\n"
        raise Exception("Grammar Error")
    if isinstance(args[3], PythonTypes.StringType):
        pass
    elif isinstance(args[3], PythonTypes.FloatType):
        pass
    elif isinstance(args[3], PythonTypes.IntType):
        pass
    elif args[3] == pure:
        pass
    elif args[3] == result:
        pass
    elif isinstance(args[3], tuple) and args[3][0] == complex:
        pass
    elif args[3] == true:
        pass
    elif args[3] == false:
        pass
    elif isinstance(args[3], tuple) and args[3][0] == new:
        pass
    elif isinstance(args[3], tuple) and args[3][0] == var_decl:
        pass
    elif isinstance(args[3], tuple) and args[3][0] == var_decl_init:
        pass
    elif isinstance(args[3], PythonTypes.StringType):
        pass
    elif isinstance(args[3], tuple) and args[3][0] == pointer_expr:
        pass
    elif isinstance(args[3], tuple) and args[3][0] == deref:
        pass
    elif isinstance(args[3], tuple) and args[3][0] == get_struct_item:
        pass
    elif isinstance(args[3], tuple) and args[3][0] == call:
        pass
    elif isinstance(args[3], tuple) and args[3][0] == set_struct_item:
        pass
    elif isinstance(args[3], tuple) and args[3][0] == assignment:
        pass
    elif isinstance(args[3], tuple) and args[3][0] == infix_expr:
        pass
    elif isinstance(args[3], tuple) and args[3][0] == prefix_expr:
        pass
    elif isinstance(args[3], tuple) and args[3][0] == sign_extend:
        pass
    else:
        print f.__name__+"():\n    \"\"\"%s\"\"\"\n" %f.__doc__.replace("\\n","\n").replace("\return","Returns").replace("\\c ","")
        print "**GRAMMAR ERROR in argument args[3] = %s"%repr(args[3])
        print "  Most likely you now want to enter \"up<enter>l<enter>\"\n into the debugger to see what happened.\n"
        raise Exception("Grammar Error")
    return tuple(['set_struct_item']+list(args))

def Assignment(*args):
    """
    Construct a "assignment" node. Valid arguments are 
    (\c VarRefExpr(), \c Expr())
    \return (\c "Assignment", \c VarRefExpr(), \c Expr())
    """
    f = Assignment
    if len(args) <> 2:
        print "**GRAMMAR ERROR: expected 2 arguments for a", f.__name__
        print "Most likely you want to enter \"up<enter>l<enter>\" now to see what happened."
        raise Exception("Grammar Error")
    if isinstance(args[0], PythonTypes.StringType):
        pass
    elif isinstance(args[0], tuple) and args[0][0] == pointer_expr:
        pass
    elif isinstance(args[0], tuple) and args[0][0] == deref:
        pass
    elif isinstance(args[0], tuple) and args[0][0] == get_struct_item:
        pass
    elif isinstance(args[0], tuple) and args[0][0] == call:
        pass
    else:
        print f.__name__+"():\n    \"\"\"%s\"\"\"\n" %f.__doc__.replace("\\n","\n").replace("\return","Returns").replace("\\c ","")
        print "**GRAMMAR ERROR in argument args[0] = %s"%repr(args[0])
        print "  Most likely you now want to enter \"up<enter>l<enter>\"\n into the debugger to see what happened.\n"
        raise Exception("Grammar Error")
    if isinstance(args[1], PythonTypes.StringType):
        pass
    elif isinstance(args[1], PythonTypes.FloatType):
        pass
    elif isinstance(args[1], PythonTypes.IntType):
        pass
    elif args[1] == pure:
        pass
    elif args[1] == result:
        pass
    elif isinstance(args[1], tuple) and args[1][0] == complex:
        pass
    elif args[1] == true:
        pass
    elif args[1] == false:
        pass
    elif isinstance(args[1], tuple) and args[1][0] == new:
        pass
    elif isinstance(args[1], tuple) and args[1][0] == var_decl:
        pass
    elif isinstance(args[1], tuple) and args[1][0] == var_decl_init:
        pass
    elif isinstance(args[1], PythonTypes.StringType):
        pass
    elif isinstance(args[1], tuple) and args[1][0] == pointer_expr:
        pass
    elif isinstance(args[1], tuple) and args[1][0] == deref:
        pass
    elif isinstance(args[1], tuple) and args[1][0] == get_struct_item:
        pass
    elif isinstance(args[1], tuple) and args[1][0] == call:
        pass
    elif isinstance(args[1], tuple) and args[1][0] == set_struct_item:
        pass
    elif isinstance(args[1], tuple) and args[1][0] == assignment:
        pass
    elif isinstance(args[1], tuple) and args[1][0] == infix_expr:
        pass
    elif isinstance(args[1], tuple) and args[1][0] == prefix_expr:
        pass
    elif isinstance(args[1], tuple) and args[1][0] == sign_extend:
        pass
    else:
        print f.__name__+"():\n    \"\"\"%s\"\"\"\n" %f.__doc__.replace("\\n","\n").replace("\return","Returns").replace("\\c ","")
        print "**GRAMMAR ERROR in argument args[1] = %s"%repr(args[1])
        print "  Most likely you now want to enter \"up<enter>l<enter>\"\n into the debugger to see what happened.\n"
        raise Exception("Grammar Error")
    return tuple(['assignment']+list(args))

def Infix_expr(*args):
    """
    Construct a "infix_expr" node. Valid arguments are 
    (\c Bin_op(), \c Expr(), \c Expr())
    \return (\c "Infix_expr", \c Bin_op(), \c Expr(), \c Expr())
    """
    f = Infix_expr
    if len(args) <> 3:
        print "**GRAMMAR ERROR: expected 3 arguments for a", f.__name__
        print "Most likely you want to enter \"up<enter>l<enter>\" now to see what happened."
        raise Exception("Grammar Error")
    if args[0] == log_or:
        pass
    elif args[0] == log_and:
        pass
    elif args[0] == eq:
        pass
    elif args[0] == ne:
        pass
    elif args[0] == bit_or:
        pass
    elif args[0] == bit_and:
        pass
    elif args[0] == bit_xor:
        pass
    elif args[0] == lt:
        pass
    elif args[0] == gt:
        pass
    elif args[0] == lshift:
        pass
    elif args[0] == rshift:
        pass
    elif args[0] == plus:
        pass
    elif args[0] == minus:
        pass
    elif args[0] == times:
        pass
    elif args[0] == divide:
        pass
    elif args[0] == modulo:
        pass
    elif args[0] == rem:
        pass
    elif args[0] == pow:
        pass
    else:
        print f.__name__+"():\n    \"\"\"%s\"\"\"\n" %f.__doc__.replace("\\n","\n").replace("\return","Returns").replace("\\c ","")
        print "**GRAMMAR ERROR in argument args[0] = %s"%repr(args[0])
        print "  Most likely you now want to enter \"up<enter>l<enter>\"\n into the debugger to see what happened.\n"
        raise Exception("Grammar Error")
    if isinstance(args[1], PythonTypes.StringType):
        pass
    elif isinstance(args[1], PythonTypes.FloatType):
        pass
    elif isinstance(args[1], PythonTypes.IntType):
        pass
    elif args[1] == pure:
        pass
    elif args[1] == result:
        pass
    elif isinstance(args[1], tuple) and args[1][0] == complex:
        pass
    elif args[1] == true:
        pass
    elif args[1] == false:
        pass
    elif isinstance(args[1], tuple) and args[1][0] == new:
        pass
    elif isinstance(args[1], tuple) and args[1][0] == var_decl:
        pass
    elif isinstance(args[1], tuple) and args[1][0] == var_decl_init:
        pass
    elif isinstance(args[1], PythonTypes.StringType):
        pass
    elif isinstance(args[1], tuple) and args[1][0] == pointer_expr:
        pass
    elif isinstance(args[1], tuple) and args[1][0] == deref:
        pass
    elif isinstance(args[1], tuple) and args[1][0] == get_struct_item:
        pass
    elif isinstance(args[1], tuple) and args[1][0] == call:
        pass
    elif isinstance(args[1], tuple) and args[1][0] == set_struct_item:
        pass
    elif isinstance(args[1], tuple) and args[1][0] == assignment:
        pass
    elif isinstance(args[1], tuple) and args[1][0] == infix_expr:
        pass
    elif isinstance(args[1], tuple) and args[1][0] == prefix_expr:
        pass
    elif isinstance(args[1], tuple) and args[1][0] == sign_extend:
        pass
    else:
        print f.__name__+"():\n    \"\"\"%s\"\"\"\n" %f.__doc__.replace("\\n","\n").replace("\return","Returns").replace("\\c ","")
        print "**GRAMMAR ERROR in argument args[1] = %s"%repr(args[1])
        print "  Most likely you now want to enter \"up<enter>l<enter>\"\n into the debugger to see what happened.\n"
        raise Exception("Grammar Error")
    if isinstance(args[2], PythonTypes.StringType):
        pass
    elif isinstance(args[2], PythonTypes.FloatType):
        pass
    elif isinstance(args[2], PythonTypes.IntType):
        pass
    elif args[2] == pure:
        pass
    elif args[2] == result:
        pass
    elif isinstance(args[2], tuple) and args[2][0] == complex:
        pass
    elif args[2] == true:
        pass
    elif args[2] == false:
        pass
    elif isinstance(args[2], tuple) and args[2][0] == new:
        pass
    elif isinstance(args[2], tuple) and args[2][0] == var_decl:
        pass
    elif isinstance(args[2], tuple) and args[2][0] == var_decl_init:
        pass
    elif isinstance(args[2], PythonTypes.StringType):
        pass
    elif isinstance(args[2], tuple) and args[2][0] == pointer_expr:
        pass
    elif isinstance(args[2], tuple) and args[2][0] == deref:
        pass
    elif isinstance(args[2], tuple) and args[2][0] == get_struct_item:
        pass
    elif isinstance(args[2], tuple) and args[2][0] == call:
        pass
    elif isinstance(args[2], tuple) and args[2][0] == set_struct_item:
        pass
    elif isinstance(args[2], tuple) and args[2][0] == assignment:
        pass
    elif isinstance(args[2], tuple) and args[2][0] == infix_expr:
        pass
    elif isinstance(args[2], tuple) and args[2][0] == prefix_expr:
        pass
    elif isinstance(args[2], tuple) and args[2][0] == sign_extend:
        pass
    else:
        print f.__name__+"():\n    \"\"\"%s\"\"\"\n" %f.__doc__.replace("\\n","\n").replace("\return","Returns").replace("\\c ","")
        print "**GRAMMAR ERROR in argument args[2] = %s"%repr(args[2])
        print "  Most likely you now want to enter \"up<enter>l<enter>\"\n into the debugger to see what happened.\n"
        raise Exception("Grammar Error")
    return tuple(['infix_expr']+list(args))

def Prefix_expr(*args):
    """
    Construct a "prefix_expr" node. Valid arguments are 
    (\c Un_op(), \c Expr())
    \return (\c "Prefix_expr", \c Un_op(), \c Expr())
    """
    f = Prefix_expr
    if len(args) <> 2:
        print "**GRAMMAR ERROR: expected 2 arguments for a", f.__name__
        print "Most likely you want to enter \"up<enter>l<enter>\" now to see what happened."
        raise Exception("Grammar Error")
    if args[0] == is_:
        pass
    elif args[0] == log_not:
        pass
    elif args[0] == bit_not:
        pass
    else:
        print f.__name__+"():\n    \"\"\"%s\"\"\"\n" %f.__doc__.replace("\\n","\n").replace("\return","Returns").replace("\\c ","")
        print "**GRAMMAR ERROR in argument args[0] = %s"%repr(args[0])
        print "  Most likely you now want to enter \"up<enter>l<enter>\"\n into the debugger to see what happened.\n"
        raise Exception("Grammar Error")
    if isinstance(args[1], PythonTypes.StringType):
        pass
    elif isinstance(args[1], PythonTypes.FloatType):
        pass
    elif isinstance(args[1], PythonTypes.IntType):
        pass
    elif args[1] == pure:
        pass
    elif args[1] == result:
        pass
    elif isinstance(args[1], tuple) and args[1][0] == complex:
        pass
    elif args[1] == true:
        pass
    elif args[1] == false:
        pass
    elif isinstance(args[1], tuple) and args[1][0] == new:
        pass
    elif isinstance(args[1], tuple) and args[1][0] == var_decl:
        pass
    elif isinstance(args[1], tuple) and args[1][0] == var_decl_init:
        pass
    elif isinstance(args[1], PythonTypes.StringType):
        pass
    elif isinstance(args[1], tuple) and args[1][0] == pointer_expr:
        pass
    elif isinstance(args[1], tuple) and args[1][0] == deref:
        pass
    elif isinstance(args[1], tuple) and args[1][0] == get_struct_item:
        pass
    elif isinstance(args[1], tuple) and args[1][0] == call:
        pass
    elif isinstance(args[1], tuple) and args[1][0] == set_struct_item:
        pass
    elif isinstance(args[1], tuple) and args[1][0] == assignment:
        pass
    elif isinstance(args[1], tuple) and args[1][0] == infix_expr:
        pass
    elif isinstance(args[1], tuple) and args[1][0] == prefix_expr:
        pass
    elif isinstance(args[1], tuple) and args[1][0] == sign_extend:
        pass
    else:
        print f.__name__+"():\n    \"\"\"%s\"\"\"\n" %f.__doc__.replace("\\n","\n").replace("\return","Returns").replace("\\c ","")
        print "**GRAMMAR ERROR in argument args[1] = %s"%repr(args[1])
        print "  Most likely you now want to enter \"up<enter>l<enter>\"\n into the debugger to see what happened.\n"
        raise Exception("Grammar Error")
    return tuple(['prefix_expr']+list(args))

def Sign_extend(*args):
    """
    Construct a "sign_extend" node. Valid arguments are 
    (\c Bits(), \c Expr())
    \return (\c "Sign_extend", \c Bits(), \c Expr())
    """
    f = Sign_extend
    if len(args) <> 2:
        print "**GRAMMAR ERROR: expected 2 arguments for a", f.__name__
        print "Most likely you want to enter \"up<enter>l<enter>\" now to see what happened."
        raise Exception("Grammar Error")
    if isinstance(args[0], PythonTypes.IntType):
        pass
    else:
        print f.__name__+"():\n    \"\"\"%s\"\"\"\n" %f.__doc__.replace("\\n","\n").replace("\return","Returns").replace("\\c ","")
        print "**GRAMMAR ERROR in argument args[0] = %s"%repr(args[0])
        print "  Most likely you now want to enter \"up<enter>l<enter>\"\n into the debugger to see what happened.\n"
        raise Exception("Grammar Error")
    if isinstance(args[1], PythonTypes.StringType):
        pass
    elif isinstance(args[1], PythonTypes.FloatType):
        pass
    elif isinstance(args[1], PythonTypes.IntType):
        pass
    elif args[1] == pure:
        pass
    elif args[1] == result:
        pass
    elif isinstance(args[1], tuple) and args[1][0] == complex:
        pass
    elif args[1] == true:
        pass
    elif args[1] == false:
        pass
    elif isinstance(args[1], tuple) and args[1][0] == new:
        pass
    elif isinstance(args[1], tuple) and args[1][0] == var_decl:
        pass
    elif isinstance(args[1], tuple) and args[1][0] == var_decl_init:
        pass
    elif isinstance(args[1], PythonTypes.StringType):
        pass
    elif isinstance(args[1], tuple) and args[1][0] == pointer_expr:
        pass
    elif isinstance(args[1], tuple) and args[1][0] == deref:
        pass
    elif isinstance(args[1], tuple) and args[1][0] == get_struct_item:
        pass
    elif isinstance(args[1], tuple) and args[1][0] == call:
        pass
    elif isinstance(args[1], tuple) and args[1][0] == set_struct_item:
        pass
    elif isinstance(args[1], tuple) and args[1][0] == assignment:
        pass
    elif isinstance(args[1], tuple) and args[1][0] == infix_expr:
        pass
    elif isinstance(args[1], tuple) and args[1][0] == prefix_expr:
        pass
    elif isinstance(args[1], tuple) and args[1][0] == sign_extend:
        pass
    else:
        print f.__name__+"():\n    \"\"\"%s\"\"\"\n" %f.__doc__.replace("\\n","\n").replace("\return","Returns").replace("\\c ","")
        print "**GRAMMAR ERROR in argument args[1] = %s"%repr(args[1])
        print "  Most likely you now want to enter \"up<enter>l<enter>\"\n into the debugger to see what happened.\n"
        raise Exception("Grammar Error")
    return tuple(['sign_extend']+list(args))

def Var_decl(*args):
    """
    Construct a "var_decl" node. Valid arguments are 
    (\c Type(), \c Id())
    \return (\c "Var_decl", \c Type(), \c Id())
    """
    f = Var_decl
    if len(args) <> 2:
        print "**GRAMMAR ERROR: expected 2 arguments for a", f.__name__
        print "Most likely you want to enter \"up<enter>l<enter>\" now to see what happened."
        raise Exception("Grammar Error")
    if isinstance(args[0], tuple) and args[0][0] == primitive_type:
        pass
    elif isinstance(args[0], tuple) and args[0][0] == pointer_type:
        pass
    elif isinstance(args[0], tuple) and args[0][0] == typedef_type:
        pass
    elif isinstance(args[0], tuple) and args[0][0] == const:
        pass
    elif isinstance(args[0], tuple) and args[0][0] == struct:
        pass
    elif isinstance(args[0], tuple) and args[0][0] == enum:
        pass
    else:
        print f.__name__+"():\n    \"\"\"%s\"\"\"\n" %f.__doc__.replace("\\n","\n").replace("\return","Returns").replace("\\c ","")
        print "**GRAMMAR ERROR in argument args[0] = %s"%repr(args[0])
        print "  Most likely you now want to enter \"up<enter>l<enter>\"\n into the debugger to see what happened.\n"
        raise Exception("Grammar Error")
    if isinstance(args[1], PythonTypes.StringType):
        pass
    else:
        print f.__name__+"():\n    \"\"\"%s\"\"\"\n" %f.__doc__.replace("\\n","\n").replace("\return","Returns").replace("\\c ","")
        print "**GRAMMAR ERROR in argument args[1] = %s"%repr(args[1])
        print "  Most likely you now want to enter \"up<enter>l<enter>\"\n into the debugger to see what happened.\n"
        raise Exception("Grammar Error")
    return tuple(['var_decl']+list(args))

def Var_decl_init(*args):
    """
    Construct a "var_decl_init" node. Valid arguments are 
    (\c Type(), \c Id(), \c Expr())
    \return (\c "Var_decl_init", \c Type(), \c Id(), \c Expr())
    """
    f = Var_decl_init
    if len(args) <> 3:
        print "**GRAMMAR ERROR: expected 3 arguments for a", f.__name__
        print "Most likely you want to enter \"up<enter>l<enter>\" now to see what happened."
        raise Exception("Grammar Error")
    if isinstance(args[0], tuple) and args[0][0] == primitive_type:
        pass
    elif isinstance(args[0], tuple) and args[0][0] == pointer_type:
        pass
    elif isinstance(args[0], tuple) and args[0][0] == typedef_type:
        pass
    elif isinstance(args[0], tuple) and args[0][0] == const:
        pass
    elif isinstance(args[0], tuple) and args[0][0] == struct:
        pass
    elif isinstance(args[0], tuple) and args[0][0] == enum:
        pass
    else:
        print f.__name__+"():\n    \"\"\"%s\"\"\"\n" %f.__doc__.replace("\\n","\n").replace("\return","Returns").replace("\\c ","")
        print "**GRAMMAR ERROR in argument args[0] = %s"%repr(args[0])
        print "  Most likely you now want to enter \"up<enter>l<enter>\"\n into the debugger to see what happened.\n"
        raise Exception("Grammar Error")
    if isinstance(args[1], PythonTypes.StringType):
        pass
    else:
        print f.__name__+"():\n    \"\"\"%s\"\"\"\n" %f.__doc__.replace("\\n","\n").replace("\return","Returns").replace("\\c ","")
        print "**GRAMMAR ERROR in argument args[1] = %s"%repr(args[1])
        print "  Most likely you now want to enter \"up<enter>l<enter>\"\n into the debugger to see what happened.\n"
        raise Exception("Grammar Error")
    if isinstance(args[2], PythonTypes.StringType):
        pass
    elif isinstance(args[2], PythonTypes.FloatType):
        pass
    elif isinstance(args[2], PythonTypes.IntType):
        pass
    elif args[2] == pure:
        pass
    elif args[2] == result:
        pass
    elif isinstance(args[2], tuple) and args[2][0] == complex:
        pass
    elif args[2] == true:
        pass
    elif args[2] == false:
        pass
    elif isinstance(args[2], tuple) and args[2][0] == new:
        pass
    elif isinstance(args[2], tuple) and args[2][0] == var_decl:
        pass
    elif isinstance(args[2], tuple) and args[2][0] == var_decl_init:
        pass
    elif isinstance(args[2], PythonTypes.StringType):
        pass
    elif isinstance(args[2], tuple) and args[2][0] == pointer_expr:
        pass
    elif isinstance(args[2], tuple) and args[2][0] == deref:
        pass
    elif isinstance(args[2], tuple) and args[2][0] == get_struct_item:
        pass
    elif isinstance(args[2], tuple) and args[2][0] == call:
        pass
    elif isinstance(args[2], tuple) and args[2][0] == set_struct_item:
        pass
    elif isinstance(args[2], tuple) and args[2][0] == assignment:
        pass
    elif isinstance(args[2], tuple) and args[2][0] == infix_expr:
        pass
    elif isinstance(args[2], tuple) and args[2][0] == prefix_expr:
        pass
    elif isinstance(args[2], tuple) and args[2][0] == sign_extend:
        pass
    else:
        print f.__name__+"():\n    \"\"\"%s\"\"\"\n" %f.__doc__.replace("\\n","\n").replace("\return","Returns").replace("\\c ","")
        print "**GRAMMAR ERROR in argument args[2] = %s"%repr(args[2])
        print "  Most likely you now want to enter \"up<enter>l<enter>\"\n into the debugger to see what happened.\n"
        raise Exception("Grammar Error")
    return tuple(['var_decl_init']+list(args))

def Enumerator(*args):
    """
    Construct a "enumerator" node. Valid arguments are 
    (\c Id())
    \return (\c "Enumerator", \c Id())
    """
    f = Enumerator
    if len(args) <> 1:
        print "**GRAMMAR ERROR: expected 1 arguments for a", f.__name__
        print "Most likely you want to enter \"up<enter>l<enter>\" now to see what happened."
        raise Exception("Grammar Error")
    if isinstance(args[0], PythonTypes.StringType):
        pass
    else:
        print f.__name__+"():\n    \"\"\"%s\"\"\"\n" %f.__doc__.replace("\\n","\n").replace("\return","Returns").replace("\\c ","")
        print "**GRAMMAR ERROR in argument args[0] = %s"%repr(args[0])
        print "  Most likely you now want to enter \"up<enter>l<enter>\"\n into the debugger to see what happened.\n"
        raise Exception("Grammar Error")
    return tuple(['enumerator']+list(args))

def Enumerator(*args):
    """
    Construct a "enumerator" node. Valid arguments are 
    (\c Id(), INT())
    \return (\c "Enumerator", \c Id(), INT())
    """
    f = Enumerator
    if len(args) <> 2:
        print "**GRAMMAR ERROR: expected 2 arguments for a", f.__name__
        print "Most likely you want to enter \"up<enter>l<enter>\" now to see what happened."
        raise Exception("Grammar Error")
    if isinstance(args[0], PythonTypes.StringType):
        pass
    else:
        print f.__name__+"():\n    \"\"\"%s\"\"\"\n" %f.__doc__.replace("\\n","\n").replace("\return","Returns").replace("\\c ","")
        print "**GRAMMAR ERROR in argument args[0] = %s"%repr(args[0])
        print "  Most likely you now want to enter \"up<enter>l<enter>\"\n into the debugger to see what happened.\n"
        raise Exception("Grammar Error")
    if isinstance(args[1], PythonTypes.IntType):
        pass
    else:
        print f.__name__+"():\n    \"\"\"%s\"\"\"\n" %f.__doc__.replace("\\n","\n").replace("\return","Returns").replace("\\c ","")
        print "**GRAMMAR ERROR in argument args[1] = %s"%repr(args[1])
        print "  Most likely you now want to enter \"up<enter>l<enter>\"\n into the debugger to see what happened.\n"
        raise Exception("Grammar Error")
    return tuple(['enumerator']+list(args))

def Get_struct_item(*args):
    """
    Construct a "get_struct_item" node. Valid arguments are 
    (\c Struct(), \c Expr(), \c Struct_item())
    \return (\c "Get_struct_item", \c Struct(), \c Expr(), \c Struct_item())
    """
    f = Get_struct_item
    if len(args) <> 3:
        print "**GRAMMAR ERROR: expected 3 arguments for a", f.__name__
        print "Most likely you want to enter \"up<enter>l<enter>\" now to see what happened."
        raise Exception("Grammar Error")
    if isinstance(args[0], tuple) and args[0][0] == struct:
        pass
    else:
        print f.__name__+"():\n    \"\"\"%s\"\"\"\n" %f.__doc__.replace("\\n","\n").replace("\return","Returns").replace("\\c ","")
        print "**GRAMMAR ERROR in argument args[0] = %s"%repr(args[0])
        print "  Most likely you now want to enter \"up<enter>l<enter>\"\n into the debugger to see what happened.\n"
        raise Exception("Grammar Error")
    if isinstance(args[1], PythonTypes.StringType):
        pass
    elif isinstance(args[1], PythonTypes.FloatType):
        pass
    elif isinstance(args[1], PythonTypes.IntType):
        pass
    elif args[1] == pure:
        pass
    elif args[1] == result:
        pass
    elif isinstance(args[1], tuple) and args[1][0] == complex:
        pass
    elif args[1] == true:
        pass
    elif args[1] == false:
        pass
    elif isinstance(args[1], tuple) and args[1][0] == new:
        pass
    elif isinstance(args[1], tuple) and args[1][0] == var_decl:
        pass
    elif isinstance(args[1], tuple) and args[1][0] == var_decl_init:
        pass
    elif isinstance(args[1], PythonTypes.StringType):
        pass
    elif isinstance(args[1], tuple) and args[1][0] == pointer_expr:
        pass
    elif isinstance(args[1], tuple) and args[1][0] == deref:
        pass
    elif isinstance(args[1], tuple) and args[1][0] == get_struct_item:
        pass
    elif isinstance(args[1], tuple) and args[1][0] == call:
        pass
    elif isinstance(args[1], tuple) and args[1][0] == set_struct_item:
        pass
    elif isinstance(args[1], tuple) and args[1][0] == assignment:
        pass
    elif isinstance(args[1], tuple) and args[1][0] == infix_expr:
        pass
    elif isinstance(args[1], tuple) and args[1][0] == prefix_expr:
        pass
    elif isinstance(args[1], tuple) and args[1][0] == sign_extend:
        pass
    else:
        print f.__name__+"():\n    \"\"\"%s\"\"\"\n" %f.__doc__.replace("\\n","\n").replace("\return","Returns").replace("\\c ","")
        print "**GRAMMAR ERROR in argument args[1] = %s"%repr(args[1])
        print "  Most likely you now want to enter \"up<enter>l<enter>\"\n into the debugger to see what happened.\n"
        raise Exception("Grammar Error")
    if isinstance(args[2], tuple) and args[2][0] == struct_item:
        pass
    else:
        print f.__name__+"():\n    \"\"\"%s\"\"\"\n" %f.__doc__.replace("\\n","\n").replace("\return","Returns").replace("\\c ","")
        print "**GRAMMAR ERROR in argument args[2] = %s"%repr(args[2])
        print "  Most likely you now want to enter \"up<enter>l<enter>\"\n into the debugger to see what happened.\n"
        raise Exception("Grammar Error")
    return tuple(['get_struct_item']+list(args))

def Call(*args):
    """
    Construct a "call" node. Valid arguments are 
    (\c Expr(), [\c Expr()])
    \return (\c "Call", \c Expr(), [\c Expr()])
    """
    f = Call
    if len(args) <> 2:
        print "**GRAMMAR ERROR: expected 2 arguments for a", f.__name__
        print "Most likely you want to enter \"up<enter>l<enter>\" now to see what happened."
        raise Exception("Grammar Error")
    if isinstance(args[0], PythonTypes.StringType):
        pass
    elif isinstance(args[0], PythonTypes.FloatType):
        pass
    elif isinstance(args[0], PythonTypes.IntType):
        pass
    elif args[0] == pure:
        pass
    elif args[0] == result:
        pass
    elif isinstance(args[0], tuple) and args[0][0] == complex:
        pass
    elif args[0] == true:
        pass
    elif args[0] == false:
        pass
    elif isinstance(args[0], tuple) and args[0][0] == new:
        pass
    elif isinstance(args[0], tuple) and args[0][0] == var_decl:
        pass
    elif isinstance(args[0], tuple) and args[0][0] == var_decl_init:
        pass
    elif isinstance(args[0], PythonTypes.StringType):
        pass
    elif isinstance(args[0], tuple) and args[0][0] == pointer_expr:
        pass
    elif isinstance(args[0], tuple) and args[0][0] == deref:
        pass
    elif isinstance(args[0], tuple) and args[0][0] == get_struct_item:
        pass
    elif isinstance(args[0], tuple) and args[0][0] == call:
        pass
    elif isinstance(args[0], tuple) and args[0][0] == set_struct_item:
        pass
    elif isinstance(args[0], tuple) and args[0][0] == assignment:
        pass
    elif isinstance(args[0], tuple) and args[0][0] == infix_expr:
        pass
    elif isinstance(args[0], tuple) and args[0][0] == prefix_expr:
        pass
    elif isinstance(args[0], tuple) and args[0][0] == sign_extend:
        pass
    else:
        print f.__name__+"():\n    \"\"\"%s\"\"\"\n" %f.__doc__.replace("\\n","\n").replace("\return","Returns").replace("\\c ","")
        print "**GRAMMAR ERROR in argument args[0] = %s"%repr(args[0])
        print "  Most likely you now want to enter \"up<enter>l<enter>\"\n into the debugger to see what happened.\n"
        raise Exception("Grammar Error")
    if isinstance(args[1], list):
        for a in args[1]:
            if isinstance(a, PythonTypes.StringType):
                pass
            elif isinstance(a, PythonTypes.FloatType):
                pass
            elif isinstance(a, PythonTypes.IntType):
                pass
            elif a == pure:
                pass
            elif a == result:
                pass
            elif isinstance(a, tuple) and a[0] == complex:
                pass
            elif a == true:
                pass
            elif a == false:
                pass
            elif isinstance(a, tuple) and a[0] == new:
                pass
            elif isinstance(a, tuple) and a[0] == var_decl:
                pass
            elif isinstance(a, tuple) and a[0] == var_decl_init:
                pass
            elif isinstance(a, PythonTypes.StringType):
                pass
            elif isinstance(a, tuple) and a[0] == pointer_expr:
                pass
            elif isinstance(a, tuple) and a[0] == deref:
                pass
            elif isinstance(a, tuple) and a[0] == get_struct_item:
                pass
            elif isinstance(a, tuple) and a[0] == call:
                pass
            elif isinstance(a, tuple) and a[0] == set_struct_item:
                pass
            elif isinstance(a, tuple) and a[0] == assignment:
                pass
            elif isinstance(a, tuple) and a[0] == infix_expr:
                pass
            elif isinstance(a, tuple) and a[0] == prefix_expr:
                pass
            elif isinstance(a, tuple) and a[0] == sign_extend:
                pass
            else:
                print f.__name__+"():\n    \"\"\"%s\"\"\"\n" %f.__doc__.replace("\\n","\n").replace("\return","Returns").replace("\\c ","")
                print "**GRAMMAR ERROR in argument a = %s"%repr(a)
                print "  Most likely you now want to enter \"up<enter>l<enter>\"\n into the debugger to see what happened.\n"
                raise Exception("Grammar Error")
    else:
        print f.__name__+"():\n    \"\"\"%s\"\"\"\n" %f.__doc__.replace("\\n","\n").replace("\return","Returns").replace("\\c ","")
        print "**GRAMMAR ERROR in argument args[1] = %s"%repr(args[1])
        print "  Most likely you now want to enter \"up<enter>l<enter>\"\n into the debugger to see what happened.\n"
        raise Exception("Grammar Error")
    return tuple(['call']+list(args))

def Typedef_type(*args):
    """
    Construct a "typedef_type" node. Valid arguments are 
    (\c Id())
    \return (\c "Typedef_type", \c Id())
    """
    f = Typedef_type
    if len(args) <> 1:
        print "**GRAMMAR ERROR: expected 1 arguments for a", f.__name__
        print "Most likely you want to enter \"up<enter>l<enter>\" now to see what happened."
        raise Exception("Grammar Error")
    if isinstance(args[0], PythonTypes.StringType):
        pass
    else:
        print f.__name__+"():\n    \"\"\"%s\"\"\"\n" %f.__doc__.replace("\\n","\n").replace("\return","Returns").replace("\\c ","")
        print "**GRAMMAR ERROR in argument args[0] = %s"%repr(args[0])
        print "  Most likely you now want to enter \"up<enter>l<enter>\"\n into the debugger to see what happened.\n"
        raise Exception("Grammar Error")
    return tuple(['typedef_type']+list(args))

def Const(*args):
    """
    Construct a "const" node. Valid arguments are 
    (\c Type())
    \return (\c "Const", \c Type())
    """
    f = Const
    if len(args) <> 1:
        print "**GRAMMAR ERROR: expected 1 arguments for a", f.__name__
        print "Most likely you want to enter \"up<enter>l<enter>\" now to see what happened."
        raise Exception("Grammar Error")
    if isinstance(args[0], tuple) and args[0][0] == primitive_type:
        pass
    elif isinstance(args[0], tuple) and args[0][0] == pointer_type:
        pass
    elif isinstance(args[0], tuple) and args[0][0] == typedef_type:
        pass
    elif isinstance(args[0], tuple) and args[0][0] == const:
        pass
    elif isinstance(args[0], tuple) and args[0][0] == struct:
        pass
    elif isinstance(args[0], tuple) and args[0][0] == enum:
        pass
    else:
        print f.__name__+"():\n    \"\"\"%s\"\"\"\n" %f.__doc__.replace("\\n","\n").replace("\return","Returns").replace("\\c ","")
        print "**GRAMMAR ERROR in argument args[0] = %s"%repr(args[0])
        print "  Most likely you now want to enter \"up<enter>l<enter>\"\n into the debugger to see what happened.\n"
        raise Exception("Grammar Error")
    return tuple(['const']+list(args))

 ## ir primitive types
pt_bool = Primitive_type(bool)
pt_bool     = Primitive_type(bool)
pt_char     = Primitive_type(char)
pt_int      = Primitive_type(int)
pt_long     = Primitive_type(long)
pt_float    = Primitive_type(float)
pt_double   = Primitive_type(double)
pt_fcomplex = Primitive_type(fcomplex)
pt_dcomplex = Primitive_type(dcomplex)
pt_string   = Primitive_type(string)
pt_void     = Primitive_type(void)
 ## const char*
const_str = Pointer_type(Const(Primitive_type(char)))
 
def Plus(A, B):
    """
    same as Infix_expr(ir.plus, A, B)
    """
    return Infix_expr(plus, A, B)
