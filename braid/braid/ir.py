#!/usr/bin/env python
# -*- python -*-
## @package ir
# Convenience definitions for intermediate representation (IR) nodes.
#
# Please report bugs to <adrian@llnl.gov>.
#
# \authors <pre>
#
# Copyright (c) 2011, Lawrence Livermore National Security, LLC.
# Produced at the Lawrence Livermore National Laboratory
# Written by Adrian Prantl <adrian@llnl.gov>.
#  
# LLNL-CODE-473891.
# All rights reserved.
#  
# This file is part of BRAID. For details, see 
# http://compose-hpc.sourceforge.net/. 
# Please read the COPYRIGHT file for Our Notice and
# for the BSD License.
#
# </pre>
#
#
# <h2>Grammar definition</h2>
#
# Caveats: scoped IDs in IR must always be absolute.
#
#\verbatim
# [
#   _File = [ (Fn_decl | Fn_defn
# 	  | Var_decl
# 	  | Import
# 	  | type_decl(Type)
# 	  ) ],
#   Import = import(Id),
#   Stmt = (stmt(Do_while | While | break | Return | If | Goto | Expr) | Comment),
#   Return = return(Expr),
#   Goto = goto(Expr),
#   Do_while = do_while(Body, Expr),
#   While = while(Expr, Body),
#   If = if(Expr, Body),
#   Body = [Stmt],
#   Expr = ( Literal
# 	 | new(Type, [Arg])
#          | Var_decl
# 	 | VarRefExpr
# 	 | cast(Type, Expr)
# 	 | set_struct_item(Struct, Expr, Struct_item, Expr)
#          | assignment(VarRefExpr, Expr)
#          | set_arg(VarRefExpr, Expr)	 
# 	 | infix_expr(Bin_op, Expr, Expr)
# 	 | prefix_expr(Un_op, Expr)
# 	 | sign_extend(Bits, Expr)
# 	 ),
#   Var_decl = ( var_decl(Type, Id)
# 	     | var_decl_init(Type, Id, Expr)
# 	     ),
#   Bin_op = (log_or|log_and|eq|ne|bit_or|bit_and|bit_xor|lt|gt|le|ge|lshift|rshift
# 	   |plus|minus|times|divide|modulo|pow),
#   Un_op = ( is|log_not|bit_not ),
#   Literal = (StringLiteral | FloatLiteral | DoubleLiteral | 'INT' | pure | result | Complex | Bool),
#   FloatLiteral = float( 'FLOAT' ),
#   DoubleLiteral = double( 'FLOAT' ),
#   StringLiteral = str('STR'),
#   Bool = bool(true | false), % Python otherwise would treat ints and bools as the same thing
#   Complex = complex('FLOAT', 'FLOAT'),
#   Struct = struct((Scoped_id|Id), [Struct_item], DocComment),
#   Struct_item = struct_item(Type, Id),
#   Enum = enum(Id, [Enumerator], DocComment),
#   Enumerator = ( enumerator(Id) | enumerator_value(Id, 'INT')),
#   %Class = class(Scoped_id, [Fn_defn], Doc_comment),
#   VarRefExpr = ( Id
# 	       | Pointer_expr
# 	       | Deref
# 	       | get_struct_item(Struct, Expr, Struct_item)
# 	       | call(Expr, [Expr])	 
# 	       ),
#   Pointer_expr = pointer_expr(VarRefExpr),
#   Deref = deref(VarRefExpr),
#   Fn_decl = fn_decl([Attr], Type, Id, [Arg], DocComment),
#   Fn_defn = fn_defn([Attr], Type, Id, [Arg], [Stmt], DocComment),
#   Arg = arg([Attr], Mode, Type, Id),
#   Attr = (static | pure | hooks),
#   Mode = (in | out | inout),
#   Type = ( Primitive_type
# 	 | Pointer_type
# 	 | typedef_type(Id)
# 	 | const(Type) 
# 	 | Struct
# 	 | Enum
# 	 | Rarray
# 	 % | Class
# 	 ),
#   Primitive_type = primitive_type(
#       bool
#     | char
#     | int
#     | long
#     | long_long
#     | float
#     | double
#     | long_double
#     | fcomplex
#     | dcomplex
#     | string
#     | void ),
#   Rarray = rarray(Primitive_type, Dimension, [Extents]),
#   Dimension = 'INT',
#   Extents = SimpleIntExpr,
#   SimpleIntExpr = ( simple_int_infix_expr(Bin_op, SimpleIntExpr, SimpleIntExpr)
#                | simple_int_prefix_expr(Un_op, SimpleIntExpr)
#                | simple_int_fn_eval(Id, [SimpleIntExpr])
#                | var_ref(Id)
#                | 'INT'
#                ),
#   Pointer_type = pointer_type(Type|Fn_decl),
#   Scoped_id = scoped_id([Module], Id, Extension),
#   Module = 'STR',
#   Extension = 'STR',
#   Id = 'STR',
#   DocComment='STR',
#   Bits = 'INT',
#   Comment = comment('STR')
# ].
#\endverbatim


# Automatically generated by GRAMOLA.
#     ### ### #### ### ###
#     ### DO NOT EDIT! ###
#     ### ### #### ### ###
import types as PythonTypes


## Token definitions

arg = 'arg'
assignment = 'assignment'
bit_and = 'bit_and'
bit_not = 'bit_not'
bit_or = 'bit_or'
bit_xor = 'bit_xor'
bool = 'bool'
break_ = 'break'
call = 'call'
cast = 'cast'
char = 'char'
comment = 'comment'
complex = 'complex'
const = 'const'
dcomplex = 'dcomplex'
deref = 'deref'
divide = 'divide'
do_while = 'do_while'
double = 'double'
enum = 'enum'
enumerator = 'enumerator'
enumerator_value = 'enumerator_value'
eq = 'eq'
false = 'false'
fcomplex = 'fcomplex'
float = 'float'
fn_decl = 'fn_decl'
fn_defn = 'fn_defn'
ge = 'ge'
get_struct_item = 'get_struct_item'
goto = 'goto'
gt = 'gt'
hooks = 'hooks'
if_ = 'if'
import_ = 'import'
in_ = 'in'
infix_expr = 'infix_expr'
inout = 'inout'
int = 'int'
is_ = 'is'
le = 'le'
log_and = 'log_and'
log_not = 'log_not'
log_or = 'log_or'
long = 'long'
long_double = 'long_double'
long_long = 'long_long'
lshift = 'lshift'
lt = 'lt'
minus = 'minus'
modulo = 'modulo'
ne = 'ne'
new = 'new'
out = 'out'
plus = 'plus'
pointer_expr = 'pointer_expr'
pointer_type = 'pointer_type'
pow = 'pow'
prefix_expr = 'prefix_expr'
primitive_type = 'primitive_type'
pure = 'pure'
rarray = 'rarray'
result = 'result'
return_ = 'return'
rshift = 'rshift'
scoped_id = 'scoped_id'
set_arg = 'set_arg'
set_struct_item = 'set_struct_item'
sign_extend = 'sign_extend'
simple_int_fn_eval = 'simple_int_fn_eval'
simple_int_infix_expr = 'simple_int_infix_expr'
simple_int_prefix_expr = 'simple_int_prefix_expr'
static = 'static'
stmt = 'stmt'
str = 'str'
string = 'string'
struct = 'struct'
struct_item = 'struct_item'
times = 'times'
true = 'true'
type_decl = 'type_decl'
typedef_type = 'typedef_type'
var_decl = 'var_decl'
var_decl_init = 'var_decl_init'
var_ref = 'var_ref'
void = 'void'
while_ = 'while'


## Constructor definitions

# skipping \c Type= (\c Primitive_type|\c Pointer_type|\c Typedef_type|\c Const|\c Struct|\c Enum|\c Rarray)
def Import(*args):
    """
    Construct a "import" node. Valid arguments are 
    (\c Id())
    \return (\c "Import", \c Id())
    """
    f = Import
    if len(args) <> 1:
        print "**GRAMMAR ERROR: expected 1 arguments for a", f.__name__
        print "Most likely you want to enter \"up<enter>l<enter>\" now to see what happened."
        raise Exception("Grammar Error")
    if isinstance(args[0], PythonTypes.StringType):
        pass
    else:
        print "\n","*"*72, "\n** GRAMMAR ERROR in argument args[0] = %s"%repr(args[0]),"\n", "*"*72
        print f.__name__+"():\n    \"\"\"%s\"\"\"\n" %f.__doc__.replace("\\n","\n").replace("\return","Returns").replace("\\c ","")
        print "\n  Most likely you now want to enter \"up<enter>l<enter>\"\n into the debugger to see what happened.\n"
        raise Exception("Grammar Error")
    return tuple(['import']+list(args))

# skipping \c Var_decl= (\c Var_decl|\c Var_decl_init)
def Fn_defn(*args):
    """
    Construct a "fn_defn" node. Valid arguments are 
    ([\c Attr()], \c Type(), \c Id(), [\c Arg()], [\c Stmt()], \c DocComment())
    \return (\c "Fn_defn", [\c Attr()], \c Type(), \c Id(), [\c Arg()], [\c Stmt()], \c DocComment())
    """
    f = Fn_defn
    if len(args) <> 6:
        print "**GRAMMAR ERROR: expected 6 arguments for a", f.__name__
        print "Most likely you want to enter \"up<enter>l<enter>\" now to see what happened."
        raise Exception("Grammar Error")
    if isinstance(args[0], list) or isinstance(args[0], tuple):
        for a in args[0]:
            if a == static:
                pass
            elif a == pure:
                pass
            elif a == hooks:
                pass
            else:
                print "\n","*"*72, "\n** GRAMMAR ERROR in argument a = %s"%repr(a),"\n", "*"*72
                print f.__name__+"():\n    \"\"\"%s\"\"\"\n" %f.__doc__.replace("\\n","\n").replace("\return","Returns").replace("\\c ","")
                print "\n  Most likely you now want to enter \"up<enter>l<enter>\"\n into the debugger to see what happened.\n"
                raise Exception("Grammar Error")
    else:
        print "\n","*"*72, "\n** GRAMMAR ERROR in argument args[0] = %s"%repr(args[0]),"\n", "*"*72
        print f.__name__+"():\n    \"\"\"%s\"\"\"\n" %f.__doc__.replace("\\n","\n").replace("\return","Returns").replace("\\c ","")
        print "\n  Most likely you now want to enter \"up<enter>l<enter>\"\n into the debugger to see what happened.\n"
        raise Exception("Grammar Error")
    if isinstance(args[1], tuple) and args[1][0] == primitive_type:
        pass
    elif isinstance(args[1], tuple) and args[1][0] == pointer_type:
        pass
    elif isinstance(args[1], tuple) and args[1][0] == typedef_type:
        pass
    elif isinstance(args[1], tuple) and args[1][0] == const:
        pass
    elif isinstance(args[1], tuple) and args[1][0] == struct:
        pass
    elif isinstance(args[1], tuple) and args[1][0] == enum:
        pass
    elif isinstance(args[1], tuple) and args[1][0] == rarray:
        pass
    else:
        print "\n","*"*72, "\n** GRAMMAR ERROR in argument args[1] = %s"%repr(args[1]),"\n", "*"*72
        print f.__name__+"():\n    \"\"\"%s\"\"\"\n" %f.__doc__.replace("\\n","\n").replace("\return","Returns").replace("\\c ","")
        print "\n  Most likely you now want to enter \"up<enter>l<enter>\"\n into the debugger to see what happened.\n"
        raise Exception("Grammar Error")
    if isinstance(args[2], PythonTypes.StringType):
        pass
    else:
        print "\n","*"*72, "\n** GRAMMAR ERROR in argument args[2] = %s"%repr(args[2]),"\n", "*"*72
        print f.__name__+"():\n    \"\"\"%s\"\"\"\n" %f.__doc__.replace("\\n","\n").replace("\return","Returns").replace("\\c ","")
        print "\n  Most likely you now want to enter \"up<enter>l<enter>\"\n into the debugger to see what happened.\n"
        raise Exception("Grammar Error")
    if isinstance(args[3], list) or isinstance(args[3], tuple):
        for a in args[3]:
            if isinstance(a, tuple) and a[0] == arg:
                pass
            else:
                print "\n","*"*72, "\n** GRAMMAR ERROR in argument a = %s"%repr(a),"\n", "*"*72
                print f.__name__+"():\n    \"\"\"%s\"\"\"\n" %f.__doc__.replace("\\n","\n").replace("\return","Returns").replace("\\c ","")
                print "\n  Most likely you now want to enter \"up<enter>l<enter>\"\n into the debugger to see what happened.\n"
                raise Exception("Grammar Error")
    else:
        print "\n","*"*72, "\n** GRAMMAR ERROR in argument args[3] = %s"%repr(args[3]),"\n", "*"*72
        print f.__name__+"():\n    \"\"\"%s\"\"\"\n" %f.__doc__.replace("\\n","\n").replace("\return","Returns").replace("\\c ","")
        print "\n  Most likely you now want to enter \"up<enter>l<enter>\"\n into the debugger to see what happened.\n"
        raise Exception("Grammar Error")
    if isinstance(args[4], list) or isinstance(args[4], tuple):
        for a in args[4]:
            if isinstance(a, tuple) and a[0] == stmt:
                pass
            elif isinstance(a, tuple) and a[0] == comment:
                pass
            else:
                print "\n","*"*72, "\n** GRAMMAR ERROR in argument a = %s"%repr(a),"\n", "*"*72
                print f.__name__+"():\n    \"\"\"%s\"\"\"\n" %f.__doc__.replace("\\n","\n").replace("\return","Returns").replace("\\c ","")
                print "\n  Most likely you now want to enter \"up<enter>l<enter>\"\n into the debugger to see what happened.\n"
                raise Exception("Grammar Error")
    else:
        print "\n","*"*72, "\n** GRAMMAR ERROR in argument args[4] = %s"%repr(args[4]),"\n", "*"*72
        print f.__name__+"():\n    \"\"\"%s\"\"\"\n" %f.__doc__.replace("\\n","\n").replace("\return","Returns").replace("\\c ","")
        print "\n  Most likely you now want to enter \"up<enter>l<enter>\"\n into the debugger to see what happened.\n"
        raise Exception("Grammar Error")
    if isinstance(args[5], PythonTypes.StringType):
        pass
    else:
        print "\n","*"*72, "\n** GRAMMAR ERROR in argument args[5] = %s"%repr(args[5]),"\n", "*"*72
        print f.__name__+"():\n    \"\"\"%s\"\"\"\n" %f.__doc__.replace("\\n","\n").replace("\return","Returns").replace("\\c ","")
        print "\n  Most likely you now want to enter \"up<enter>l<enter>\"\n into the debugger to see what happened.\n"
        raise Exception("Grammar Error")
    return tuple(['fn_defn']+list(args))

def Fn_decl(*args):
    """
    Construct a "fn_decl" node. Valid arguments are 
    ([\c Attr()], \c Type(), \c Id(), [\c Arg()], \c DocComment())
    \return (\c "Fn_decl", [\c Attr()], \c Type(), \c Id(), [\c Arg()], \c DocComment())
    """
    f = Fn_decl
    if len(args) <> 5:
        print "**GRAMMAR ERROR: expected 5 arguments for a", f.__name__
        print "Most likely you want to enter \"up<enter>l<enter>\" now to see what happened."
        raise Exception("Grammar Error")
    if isinstance(args[0], list) or isinstance(args[0], tuple):
        for a in args[0]:
            if a == static:
                pass
            elif a == pure:
                pass
            elif a == hooks:
                pass
            else:
                print "\n","*"*72, "\n** GRAMMAR ERROR in argument a = %s"%repr(a),"\n", "*"*72
                print f.__name__+"():\n    \"\"\"%s\"\"\"\n" %f.__doc__.replace("\\n","\n").replace("\return","Returns").replace("\\c ","")
                print "\n  Most likely you now want to enter \"up<enter>l<enter>\"\n into the debugger to see what happened.\n"
                raise Exception("Grammar Error")
    else:
        print "\n","*"*72, "\n** GRAMMAR ERROR in argument args[0] = %s"%repr(args[0]),"\n", "*"*72
        print f.__name__+"():\n    \"\"\"%s\"\"\"\n" %f.__doc__.replace("\\n","\n").replace("\return","Returns").replace("\\c ","")
        print "\n  Most likely you now want to enter \"up<enter>l<enter>\"\n into the debugger to see what happened.\n"
        raise Exception("Grammar Error")
    if isinstance(args[1], tuple) and args[1][0] == primitive_type:
        pass
    elif isinstance(args[1], tuple) and args[1][0] == pointer_type:
        pass
    elif isinstance(args[1], tuple) and args[1][0] == typedef_type:
        pass
    elif isinstance(args[1], tuple) and args[1][0] == const:
        pass
    elif isinstance(args[1], tuple) and args[1][0] == struct:
        pass
    elif isinstance(args[1], tuple) and args[1][0] == enum:
        pass
    elif isinstance(args[1], tuple) and args[1][0] == rarray:
        pass
    else:
        print "\n","*"*72, "\n** GRAMMAR ERROR in argument args[1] = %s"%repr(args[1]),"\n", "*"*72
        print f.__name__+"():\n    \"\"\"%s\"\"\"\n" %f.__doc__.replace("\\n","\n").replace("\return","Returns").replace("\\c ","")
        print "\n  Most likely you now want to enter \"up<enter>l<enter>\"\n into the debugger to see what happened.\n"
        raise Exception("Grammar Error")
    if isinstance(args[2], PythonTypes.StringType):
        pass
    else:
        print "\n","*"*72, "\n** GRAMMAR ERROR in argument args[2] = %s"%repr(args[2]),"\n", "*"*72
        print f.__name__+"():\n    \"\"\"%s\"\"\"\n" %f.__doc__.replace("\\n","\n").replace("\return","Returns").replace("\\c ","")
        print "\n  Most likely you now want to enter \"up<enter>l<enter>\"\n into the debugger to see what happened.\n"
        raise Exception("Grammar Error")
    if isinstance(args[3], list) or isinstance(args[3], tuple):
        for a in args[3]:
            if isinstance(a, tuple) and a[0] == arg:
                pass
            else:
                print "\n","*"*72, "\n** GRAMMAR ERROR in argument a = %s"%repr(a),"\n", "*"*72
                print f.__name__+"():\n    \"\"\"%s\"\"\"\n" %f.__doc__.replace("\\n","\n").replace("\return","Returns").replace("\\c ","")
                print "\n  Most likely you now want to enter \"up<enter>l<enter>\"\n into the debugger to see what happened.\n"
                raise Exception("Grammar Error")
    else:
        print "\n","*"*72, "\n** GRAMMAR ERROR in argument args[3] = %s"%repr(args[3]),"\n", "*"*72
        print f.__name__+"():\n    \"\"\"%s\"\"\"\n" %f.__doc__.replace("\\n","\n").replace("\return","Returns").replace("\\c ","")
        print "\n  Most likely you now want to enter \"up<enter>l<enter>\"\n into the debugger to see what happened.\n"
        raise Exception("Grammar Error")
    if isinstance(args[4], PythonTypes.StringType):
        pass
    else:
        print "\n","*"*72, "\n** GRAMMAR ERROR in argument args[4] = %s"%repr(args[4]),"\n", "*"*72
        print f.__name__+"():\n    \"\"\"%s\"\"\"\n" %f.__doc__.replace("\\n","\n").replace("\return","Returns").replace("\\c ","")
        print "\n  Most likely you now want to enter \"up<enter>l<enter>\"\n into the debugger to see what happened.\n"
        raise Exception("Grammar Error")
    return tuple(['fn_decl']+list(args))

# skipping \c _File=[ (\c Fn_decl|\c Fn_defn|\c Var_decl|\c Import|\c Type_decl)]
def STR():
    return STR
def Goto(*args):
    """
    Construct a "goto" node. Valid arguments are 
    (\c Expr())
    \return (\c "Goto", \c Expr())
    """
    f = Goto
    if len(args) <> 1:
        print "**GRAMMAR ERROR: expected 1 arguments for a", f.__name__
        print "Most likely you want to enter \"up<enter>l<enter>\" now to see what happened."
        raise Exception("Grammar Error")
    if isinstance(args[0], tuple) and args[0][0] == str:
        pass
    elif isinstance(args[0], tuple) and args[0][0] == float:
        pass
    elif isinstance(args[0], tuple) and args[0][0] == double:
        pass
    elif isinstance(args[0], PythonTypes.IntType):
        pass
    elif args[0] == pure:
        pass
    elif args[0] == result:
        pass
    elif isinstance(args[0], tuple) and args[0][0] == complex:
        pass
    elif isinstance(args[0], tuple) and args[0][0] == bool:
        pass
    elif isinstance(args[0], tuple) and args[0][0] == new:
        pass
    elif isinstance(args[0], tuple) and args[0][0] == var_decl:
        pass
    elif isinstance(args[0], tuple) and args[0][0] == var_decl_init:
        pass
    elif isinstance(args[0], PythonTypes.StringType):
        pass
    elif isinstance(args[0], tuple) and args[0][0] == pointer_expr:
        pass
    elif isinstance(args[0], tuple) and args[0][0] == deref:
        pass
    elif isinstance(args[0], tuple) and args[0][0] == get_struct_item:
        pass
    elif isinstance(args[0], tuple) and args[0][0] == call:
        pass
    elif isinstance(args[0], tuple) and args[0][0] == cast:
        pass
    elif isinstance(args[0], tuple) and args[0][0] == set_struct_item:
        pass
    elif isinstance(args[0], tuple) and args[0][0] == assignment:
        pass
    elif isinstance(args[0], tuple) and args[0][0] == set_arg:
        pass
    elif isinstance(args[0], tuple) and args[0][0] == infix_expr:
        pass
    elif isinstance(args[0], tuple) and args[0][0] == prefix_expr:
        pass
    elif isinstance(args[0], tuple) and args[0][0] == sign_extend:
        pass
    else:
        print "\n","*"*72, "\n** GRAMMAR ERROR in argument args[0] = %s"%repr(args[0]),"\n", "*"*72
        print f.__name__+"():\n    \"\"\"%s\"\"\"\n" %f.__doc__.replace("\\n","\n").replace("\return","Returns").replace("\\c ","")
        print "\n  Most likely you now want to enter \"up<enter>l<enter>\"\n into the debugger to see what happened.\n"
        raise Exception("Grammar Error")
    return tuple(['goto']+list(args))

# skipping \c Expr= (\c Literal|\c New|\c Var_decl|\c VarRefExpr|\c Cast|\c Set_struct_item|\c Assignment|\c Set_arg|\c Infix_expr|\c Prefix_expr|\c Sign_extend)
def If(*args):
    """
    Construct a "if" node. Valid arguments are 
    (\c Expr(), \c Body())
    \return (\c "If", \c Expr(), \c Body())
    """
    f = If
    if len(args) <> 2:
        print "**GRAMMAR ERROR: expected 2 arguments for a", f.__name__
        print "Most likely you want to enter \"up<enter>l<enter>\" now to see what happened."
        raise Exception("Grammar Error")
    if isinstance(args[0], tuple) and args[0][0] == str:
        pass
    elif isinstance(args[0], tuple) and args[0][0] == float:
        pass
    elif isinstance(args[0], tuple) and args[0][0] == double:
        pass
    elif isinstance(args[0], PythonTypes.IntType):
        pass
    elif args[0] == pure:
        pass
    elif args[0] == result:
        pass
    elif isinstance(args[0], tuple) and args[0][0] == complex:
        pass
    elif isinstance(args[0], tuple) and args[0][0] == bool:
        pass
    elif isinstance(args[0], tuple) and args[0][0] == new:
        pass
    elif isinstance(args[0], tuple) and args[0][0] == var_decl:
        pass
    elif isinstance(args[0], tuple) and args[0][0] == var_decl_init:
        pass
    elif isinstance(args[0], PythonTypes.StringType):
        pass
    elif isinstance(args[0], tuple) and args[0][0] == pointer_expr:
        pass
    elif isinstance(args[0], tuple) and args[0][0] == deref:
        pass
    elif isinstance(args[0], tuple) and args[0][0] == get_struct_item:
        pass
    elif isinstance(args[0], tuple) and args[0][0] == call:
        pass
    elif isinstance(args[0], tuple) and args[0][0] == cast:
        pass
    elif isinstance(args[0], tuple) and args[0][0] == set_struct_item:
        pass
    elif isinstance(args[0], tuple) and args[0][0] == assignment:
        pass
    elif isinstance(args[0], tuple) and args[0][0] == set_arg:
        pass
    elif isinstance(args[0], tuple) and args[0][0] == infix_expr:
        pass
    elif isinstance(args[0], tuple) and args[0][0] == prefix_expr:
        pass
    elif isinstance(args[0], tuple) and args[0][0] == sign_extend:
        pass
    else:
        print "\n","*"*72, "\n** GRAMMAR ERROR in argument args[0] = %s"%repr(args[0]),"\n", "*"*72
        print f.__name__+"():\n    \"\"\"%s\"\"\"\n" %f.__doc__.replace("\\n","\n").replace("\return","Returns").replace("\\c ","")
        print "\n  Most likely you now want to enter \"up<enter>l<enter>\"\n into the debugger to see what happened.\n"
        raise Exception("Grammar Error")
    if isinstance(args[1], list) or isinstance(args[1], tuple):
        for a in args[1]:
            if isinstance(a, tuple) and a[0] == stmt:
                pass
            elif isinstance(a, tuple) and a[0] == comment:
                pass
            else:
                print "\n","*"*72, "\n** GRAMMAR ERROR in argument a = %s"%repr(a),"\n", "*"*72
                print f.__name__+"():\n    \"\"\"%s\"\"\"\n" %f.__doc__.replace("\\n","\n").replace("\return","Returns").replace("\\c ","")
                print "\n  Most likely you now want to enter \"up<enter>l<enter>\"\n into the debugger to see what happened.\n"
                raise Exception("Grammar Error")
    else:
        print "\n","*"*72, "\n** GRAMMAR ERROR in argument args[1] = %s"%repr(args[1]),"\n", "*"*72
        print f.__name__+"():\n    \"\"\"%s\"\"\"\n" %f.__doc__.replace("\\n","\n").replace("\return","Returns").replace("\\c ","")
        print "\n  Most likely you now want to enter \"up<enter>l<enter>\"\n into the debugger to see what happened.\n"
        raise Exception("Grammar Error")
    return tuple(['if']+list(args))

def Return(*args):
    """
    Construct a "return" node. Valid arguments are 
    (\c Expr())
    \return (\c "Return", \c Expr())
    """
    f = Return
    if len(args) <> 1:
        print "**GRAMMAR ERROR: expected 1 arguments for a", f.__name__
        print "Most likely you want to enter \"up<enter>l<enter>\" now to see what happened."
        raise Exception("Grammar Error")
    if isinstance(args[0], tuple) and args[0][0] == str:
        pass
    elif isinstance(args[0], tuple) and args[0][0] == float:
        pass
    elif isinstance(args[0], tuple) and args[0][0] == double:
        pass
    elif isinstance(args[0], PythonTypes.IntType):
        pass
    elif args[0] == pure:
        pass
    elif args[0] == result:
        pass
    elif isinstance(args[0], tuple) and args[0][0] == complex:
        pass
    elif isinstance(args[0], tuple) and args[0][0] == bool:
        pass
    elif isinstance(args[0], tuple) and args[0][0] == new:
        pass
    elif isinstance(args[0], tuple) and args[0][0] == var_decl:
        pass
    elif isinstance(args[0], tuple) and args[0][0] == var_decl_init:
        pass
    elif isinstance(args[0], PythonTypes.StringType):
        pass
    elif isinstance(args[0], tuple) and args[0][0] == pointer_expr:
        pass
    elif isinstance(args[0], tuple) and args[0][0] == deref:
        pass
    elif isinstance(args[0], tuple) and args[0][0] == get_struct_item:
        pass
    elif isinstance(args[0], tuple) and args[0][0] == call:
        pass
    elif isinstance(args[0], tuple) and args[0][0] == cast:
        pass
    elif isinstance(args[0], tuple) and args[0][0] == set_struct_item:
        pass
    elif isinstance(args[0], tuple) and args[0][0] == assignment:
        pass
    elif isinstance(args[0], tuple) and args[0][0] == set_arg:
        pass
    elif isinstance(args[0], tuple) and args[0][0] == infix_expr:
        pass
    elif isinstance(args[0], tuple) and args[0][0] == prefix_expr:
        pass
    elif isinstance(args[0], tuple) and args[0][0] == sign_extend:
        pass
    else:
        print "\n","*"*72, "\n** GRAMMAR ERROR in argument args[0] = %s"%repr(args[0]),"\n", "*"*72
        print f.__name__+"():\n    \"\"\"%s\"\"\"\n" %f.__doc__.replace("\\n","\n").replace("\return","Returns").replace("\\c ","")
        print "\n  Most likely you now want to enter \"up<enter>l<enter>\"\n into the debugger to see what happened.\n"
        raise Exception("Grammar Error")
    return tuple(['return']+list(args))

def While(*args):
    """
    Construct a "while" node. Valid arguments are 
    (\c Expr(), \c Body())
    \return (\c "While", \c Expr(), \c Body())
    """
    f = While
    if len(args) <> 2:
        print "**GRAMMAR ERROR: expected 2 arguments for a", f.__name__
        print "Most likely you want to enter \"up<enter>l<enter>\" now to see what happened."
        raise Exception("Grammar Error")
    if isinstance(args[0], tuple) and args[0][0] == str:
        pass
    elif isinstance(args[0], tuple) and args[0][0] == float:
        pass
    elif isinstance(args[0], tuple) and args[0][0] == double:
        pass
    elif isinstance(args[0], PythonTypes.IntType):
        pass
    elif args[0] == pure:
        pass
    elif args[0] == result:
        pass
    elif isinstance(args[0], tuple) and args[0][0] == complex:
        pass
    elif isinstance(args[0], tuple) and args[0][0] == bool:
        pass
    elif isinstance(args[0], tuple) and args[0][0] == new:
        pass
    elif isinstance(args[0], tuple) and args[0][0] == var_decl:
        pass
    elif isinstance(args[0], tuple) and args[0][0] == var_decl_init:
        pass
    elif isinstance(args[0], PythonTypes.StringType):
        pass
    elif isinstance(args[0], tuple) and args[0][0] == pointer_expr:
        pass
    elif isinstance(args[0], tuple) and args[0][0] == deref:
        pass
    elif isinstance(args[0], tuple) and args[0][0] == get_struct_item:
        pass
    elif isinstance(args[0], tuple) and args[0][0] == call:
        pass
    elif isinstance(args[0], tuple) and args[0][0] == cast:
        pass
    elif isinstance(args[0], tuple) and args[0][0] == set_struct_item:
        pass
    elif isinstance(args[0], tuple) and args[0][0] == assignment:
        pass
    elif isinstance(args[0], tuple) and args[0][0] == set_arg:
        pass
    elif isinstance(args[0], tuple) and args[0][0] == infix_expr:
        pass
    elif isinstance(args[0], tuple) and args[0][0] == prefix_expr:
        pass
    elif isinstance(args[0], tuple) and args[0][0] == sign_extend:
        pass
    else:
        print "\n","*"*72, "\n** GRAMMAR ERROR in argument args[0] = %s"%repr(args[0]),"\n", "*"*72
        print f.__name__+"():\n    \"\"\"%s\"\"\"\n" %f.__doc__.replace("\\n","\n").replace("\return","Returns").replace("\\c ","")
        print "\n  Most likely you now want to enter \"up<enter>l<enter>\"\n into the debugger to see what happened.\n"
        raise Exception("Grammar Error")
    if isinstance(args[1], list) or isinstance(args[1], tuple):
        for a in args[1]:
            if isinstance(a, tuple) and a[0] == stmt:
                pass
            elif isinstance(a, tuple) and a[0] == comment:
                pass
            else:
                print "\n","*"*72, "\n** GRAMMAR ERROR in argument a = %s"%repr(a),"\n", "*"*72
                print f.__name__+"():\n    \"\"\"%s\"\"\"\n" %f.__doc__.replace("\\n","\n").replace("\return","Returns").replace("\\c ","")
                print "\n  Most likely you now want to enter \"up<enter>l<enter>\"\n into the debugger to see what happened.\n"
                raise Exception("Grammar Error")
    else:
        print "\n","*"*72, "\n** GRAMMAR ERROR in argument args[1] = %s"%repr(args[1]),"\n", "*"*72
        print f.__name__+"():\n    \"\"\"%s\"\"\"\n" %f.__doc__.replace("\\n","\n").replace("\return","Returns").replace("\\c ","")
        print "\n  Most likely you now want to enter \"up<enter>l<enter>\"\n into the debugger to see what happened.\n"
        raise Exception("Grammar Error")
    return tuple(['while']+list(args))

def Do_while(*args):
    """
    Construct a "do_while" node. Valid arguments are 
    (\c Body(), \c Expr())
    \return (\c "Do_while", \c Body(), \c Expr())
    """
    f = Do_while
    if len(args) <> 2:
        print "**GRAMMAR ERROR: expected 2 arguments for a", f.__name__
        print "Most likely you want to enter \"up<enter>l<enter>\" now to see what happened."
        raise Exception("Grammar Error")
    if isinstance(args[0], list) or isinstance(args[0], tuple):
        for a in args[0]:
            if isinstance(a, tuple) and a[0] == stmt:
                pass
            elif isinstance(a, tuple) and a[0] == comment:
                pass
            else:
                print "\n","*"*72, "\n** GRAMMAR ERROR in argument a = %s"%repr(a),"\n", "*"*72
                print f.__name__+"():\n    \"\"\"%s\"\"\"\n" %f.__doc__.replace("\\n","\n").replace("\return","Returns").replace("\\c ","")
                print "\n  Most likely you now want to enter \"up<enter>l<enter>\"\n into the debugger to see what happened.\n"
                raise Exception("Grammar Error")
    else:
        print "\n","*"*72, "\n** GRAMMAR ERROR in argument args[0] = %s"%repr(args[0]),"\n", "*"*72
        print f.__name__+"():\n    \"\"\"%s\"\"\"\n" %f.__doc__.replace("\\n","\n").replace("\return","Returns").replace("\\c ","")
        print "\n  Most likely you now want to enter \"up<enter>l<enter>\"\n into the debugger to see what happened.\n"
        raise Exception("Grammar Error")
    if isinstance(args[1], tuple) and args[1][0] == str:
        pass
    elif isinstance(args[1], tuple) and args[1][0] == float:
        pass
    elif isinstance(args[1], tuple) and args[1][0] == double:
        pass
    elif isinstance(args[1], PythonTypes.IntType):
        pass
    elif args[1] == pure:
        pass
    elif args[1] == result:
        pass
    elif isinstance(args[1], tuple) and args[1][0] == complex:
        pass
    elif isinstance(args[1], tuple) and args[1][0] == bool:
        pass
    elif isinstance(args[1], tuple) and args[1][0] == new:
        pass
    elif isinstance(args[1], tuple) and args[1][0] == var_decl:
        pass
    elif isinstance(args[1], tuple) and args[1][0] == var_decl_init:
        pass
    elif isinstance(args[1], PythonTypes.StringType):
        pass
    elif isinstance(args[1], tuple) and args[1][0] == pointer_expr:
        pass
    elif isinstance(args[1], tuple) and args[1][0] == deref:
        pass
    elif isinstance(args[1], tuple) and args[1][0] == get_struct_item:
        pass
    elif isinstance(args[1], tuple) and args[1][0] == call:
        pass
    elif isinstance(args[1], tuple) and args[1][0] == cast:
        pass
    elif isinstance(args[1], tuple) and args[1][0] == set_struct_item:
        pass
    elif isinstance(args[1], tuple) and args[1][0] == assignment:
        pass
    elif isinstance(args[1], tuple) and args[1][0] == set_arg:
        pass
    elif isinstance(args[1], tuple) and args[1][0] == infix_expr:
        pass
    elif isinstance(args[1], tuple) and args[1][0] == prefix_expr:
        pass
    elif isinstance(args[1], tuple) and args[1][0] == sign_extend:
        pass
    else:
        print "\n","*"*72, "\n** GRAMMAR ERROR in argument args[1] = %s"%repr(args[1]),"\n", "*"*72
        print f.__name__+"():\n    \"\"\"%s\"\"\"\n" %f.__doc__.replace("\\n","\n").replace("\return","Returns").replace("\\c ","")
        print "\n  Most likely you now want to enter \"up<enter>l<enter>\"\n into the debugger to see what happened.\n"
        raise Exception("Grammar Error")
    return tuple(['do_while']+list(args))

def Comment(*args):
    """
    Construct a "comment" node. Valid arguments are 
    (STR())
    \return (\c "Comment", STR())
    """
    f = Comment
    if len(args) <> 1:
        print "**GRAMMAR ERROR: expected 1 arguments for a", f.__name__
        print "Most likely you want to enter \"up<enter>l<enter>\" now to see what happened."
        raise Exception("Grammar Error")
    if isinstance(args[0], PythonTypes.StringType):
        pass
    else:
        print "\n","*"*72, "\n** GRAMMAR ERROR in argument args[0] = %s"%repr(args[0]),"\n", "*"*72
        print f.__name__+"():\n    \"\"\"%s\"\"\"\n" %f.__doc__.replace("\\n","\n").replace("\return","Returns").replace("\\c ","")
        print "\n  Most likely you now want to enter \"up<enter>l<enter>\"\n into the debugger to see what happened.\n"
        raise Exception("Grammar Error")
    return tuple(['comment']+list(args))

# skipping \c Stmt= (\c Stmt|\c Comment)
# skipping \c Body=[\c Stmt]
def Arg(*args):
    """
    Construct a "arg" node. Valid arguments are 
    ([\c Attr()], \c Mode(), \c Type(), \c Id())
    \return (\c "Arg", [\c Attr()], \c Mode(), \c Type(), \c Id())
    """
    f = Arg
    if len(args) <> 4:
        print "**GRAMMAR ERROR: expected 4 arguments for a", f.__name__
        print "Most likely you want to enter \"up<enter>l<enter>\" now to see what happened."
        raise Exception("Grammar Error")
    if isinstance(args[0], list) or isinstance(args[0], tuple):
        for a in args[0]:
            if a == static:
                pass
            elif a == pure:
                pass
            elif a == hooks:
                pass
            else:
                print "\n","*"*72, "\n** GRAMMAR ERROR in argument a = %s"%repr(a),"\n", "*"*72
                print f.__name__+"():\n    \"\"\"%s\"\"\"\n" %f.__doc__.replace("\\n","\n").replace("\return","Returns").replace("\\c ","")
                print "\n  Most likely you now want to enter \"up<enter>l<enter>\"\n into the debugger to see what happened.\n"
                raise Exception("Grammar Error")
    else:
        print "\n","*"*72, "\n** GRAMMAR ERROR in argument args[0] = %s"%repr(args[0]),"\n", "*"*72
        print f.__name__+"():\n    \"\"\"%s\"\"\"\n" %f.__doc__.replace("\\n","\n").replace("\return","Returns").replace("\\c ","")
        print "\n  Most likely you now want to enter \"up<enter>l<enter>\"\n into the debugger to see what happened.\n"
        raise Exception("Grammar Error")
    if args[1] == in_:
        pass
    elif args[1] == out:
        pass
    elif args[1] == inout:
        pass
    else:
        print "\n","*"*72, "\n** GRAMMAR ERROR in argument args[1] = %s"%repr(args[1]),"\n", "*"*72
        print f.__name__+"():\n    \"\"\"%s\"\"\"\n" %f.__doc__.replace("\\n","\n").replace("\return","Returns").replace("\\c ","")
        print "\n  Most likely you now want to enter \"up<enter>l<enter>\"\n into the debugger to see what happened.\n"
        raise Exception("Grammar Error")
    if isinstance(args[2], tuple) and args[2][0] == primitive_type:
        pass
    elif isinstance(args[2], tuple) and args[2][0] == pointer_type:
        pass
    elif isinstance(args[2], tuple) and args[2][0] == typedef_type:
        pass
    elif isinstance(args[2], tuple) and args[2][0] == const:
        pass
    elif isinstance(args[2], tuple) and args[2][0] == struct:
        pass
    elif isinstance(args[2], tuple) and args[2][0] == enum:
        pass
    elif isinstance(args[2], tuple) and args[2][0] == rarray:
        pass
    else:
        print "\n","*"*72, "\n** GRAMMAR ERROR in argument args[2] = %s"%repr(args[2]),"\n", "*"*72
        print f.__name__+"():\n    \"\"\"%s\"\"\"\n" %f.__doc__.replace("\\n","\n").replace("\return","Returns").replace("\\c ","")
        print "\n  Most likely you now want to enter \"up<enter>l<enter>\"\n into the debugger to see what happened.\n"
        raise Exception("Grammar Error")
    if isinstance(args[3], PythonTypes.StringType):
        pass
    else:
        print "\n","*"*72, "\n** GRAMMAR ERROR in argument args[3] = %s"%repr(args[3]),"\n", "*"*72
        print f.__name__+"():\n    \"\"\"%s\"\"\"\n" %f.__doc__.replace("\\n","\n").replace("\return","Returns").replace("\\c ","")
        print "\n  Most likely you now want to enter \"up<enter>l<enter>\"\n into the debugger to see what happened.\n"
        raise Exception("Grammar Error")
    return tuple(['arg']+list(args))

def Struct(*args):
    """
    Construct a "struct" node. Valid arguments are 
    (\c Scoped_id()
    |\c Id(), [\c Struct_item()], \c DocComment())
    \return (\c "Struct", \c Scoped_id()
    |\c Id(), [\c Struct_item()], \c DocComment())
    """
    f = Struct
    if len(args) <> 3:
        print "**GRAMMAR ERROR: expected 3 arguments for a", f.__name__
        print "Most likely you want to enter \"up<enter>l<enter>\" now to see what happened."
        raise Exception("Grammar Error")
    if isinstance(args[0], tuple) and args[0][0] == scoped_id:
        pass
    elif isinstance(args[0], PythonTypes.StringType):
        pass
    else:
        print "\n","*"*72, "\n** GRAMMAR ERROR in argument args[0] = %s"%repr(args[0]),"\n", "*"*72
        print f.__name__+"():\n    \"\"\"%s\"\"\"\n" %f.__doc__.replace("\\n","\n").replace("\return","Returns").replace("\\c ","")
        print "\n  Most likely you now want to enter \"up<enter>l<enter>\"\n into the debugger to see what happened.\n"
        raise Exception("Grammar Error")
    if isinstance(args[1], list) or isinstance(args[1], tuple):
        for a in args[1]:
            if isinstance(a, tuple) and a[0] == struct_item:
                pass
            else:
                print "\n","*"*72, "\n** GRAMMAR ERROR in argument a = %s"%repr(a),"\n", "*"*72
                print f.__name__+"():\n    \"\"\"%s\"\"\"\n" %f.__doc__.replace("\\n","\n").replace("\return","Returns").replace("\\c ","")
                print "\n  Most likely you now want to enter \"up<enter>l<enter>\"\n into the debugger to see what happened.\n"
                raise Exception("Grammar Error")
    else:
        print "\n","*"*72, "\n** GRAMMAR ERROR in argument args[1] = %s"%repr(args[1]),"\n", "*"*72
        print f.__name__+"():\n    \"\"\"%s\"\"\"\n" %f.__doc__.replace("\\n","\n").replace("\return","Returns").replace("\\c ","")
        print "\n  Most likely you now want to enter \"up<enter>l<enter>\"\n into the debugger to see what happened.\n"
        raise Exception("Grammar Error")
    if isinstance(args[2], PythonTypes.StringType):
        pass
    else:
        print "\n","*"*72, "\n** GRAMMAR ERROR in argument args[2] = %s"%repr(args[2]),"\n", "*"*72
        print f.__name__+"():\n    \"\"\"%s\"\"\"\n" %f.__doc__.replace("\\n","\n").replace("\return","Returns").replace("\\c ","")
        print "\n  Most likely you now want to enter \"up<enter>l<enter>\"\n into the debugger to see what happened.\n"
        raise Exception("Grammar Error")
    return tuple(['struct']+list(args))

def Struct_item(*args):
    """
    Construct a "struct_item" node. Valid arguments are 
    (\c Type(), \c Id())
    \return (\c "Struct_item", \c Type(), \c Id())
    """
    f = Struct_item
    if len(args) <> 2:
        print "**GRAMMAR ERROR: expected 2 arguments for a", f.__name__
        print "Most likely you want to enter \"up<enter>l<enter>\" now to see what happened."
        raise Exception("Grammar Error")
    if isinstance(args[0], tuple) and args[0][0] == primitive_type:
        pass
    elif isinstance(args[0], tuple) and args[0][0] == pointer_type:
        pass
    elif isinstance(args[0], tuple) and args[0][0] == typedef_type:
        pass
    elif isinstance(args[0], tuple) and args[0][0] == const:
        pass
    elif isinstance(args[0], tuple) and args[0][0] == struct:
        pass
    elif isinstance(args[0], tuple) and args[0][0] == enum:
        pass
    elif isinstance(args[0], tuple) and args[0][0] == rarray:
        pass
    else:
        print "\n","*"*72, "\n** GRAMMAR ERROR in argument args[0] = %s"%repr(args[0]),"\n", "*"*72
        print f.__name__+"():\n    \"\"\"%s\"\"\"\n" %f.__doc__.replace("\\n","\n").replace("\return","Returns").replace("\\c ","")
        print "\n  Most likely you now want to enter \"up<enter>l<enter>\"\n into the debugger to see what happened.\n"
        raise Exception("Grammar Error")
    if isinstance(args[1], PythonTypes.StringType):
        pass
    else:
        print "\n","*"*72, "\n** GRAMMAR ERROR in argument args[1] = %s"%repr(args[1]),"\n", "*"*72
        print f.__name__+"():\n    \"\"\"%s\"\"\"\n" %f.__doc__.replace("\\n","\n").replace("\return","Returns").replace("\\c ","")
        print "\n  Most likely you now want to enter \"up<enter>l<enter>\"\n into the debugger to see what happened.\n"
        raise Exception("Grammar Error")
    return tuple(['struct_item']+list(args))

# skipping \c VarRefExpr= (\c Id|\c Pointer_expr|\c Deref|\c Get_struct_item|\c Call)
# skipping \c Bin_op= (log_or|log_and|eq|ne|bit_or|bit_and|bit_xor|lt|gt|le|ge|lshift|rshift|plus|minus|times|divide|modulo|pow)
# skipping \c Un_op= (is|log_not|bit_not)
def INT():
    return INT
# skipping \c Literal= (\c StringLiteral|\c FloatLiteral|\c DoubleLiteral|INT|pure|result|\c Complex|\c Bool)
def Complex(*args):
    """
    Construct a "complex" node. Valid arguments are 
    (FLOAT(), FLOAT())
    \return (\c "Complex", FLOAT(), FLOAT())
    """
    f = Complex
    if len(args) <> 2:
        print "**GRAMMAR ERROR: expected 2 arguments for a", f.__name__
        print "Most likely you want to enter \"up<enter>l<enter>\" now to see what happened."
        raise Exception("Grammar Error")
    if isinstance(args[0], PythonTypes.FloatType):
        pass
    else:
        print "\n","*"*72, "\n** GRAMMAR ERROR in argument args[0] = %s"%repr(args[0]),"\n", "*"*72
        print f.__name__+"():\n    \"\"\"%s\"\"\"\n" %f.__doc__.replace("\\n","\n").replace("\return","Returns").replace("\\c ","")
        print "\n  Most likely you now want to enter \"up<enter>l<enter>\"\n into the debugger to see what happened.\n"
        raise Exception("Grammar Error")
    if isinstance(args[1], PythonTypes.FloatType):
        pass
    else:
        print "\n","*"*72, "\n** GRAMMAR ERROR in argument args[1] = %s"%repr(args[1]),"\n", "*"*72
        print f.__name__+"():\n    \"\"\"%s\"\"\"\n" %f.__doc__.replace("\\n","\n").replace("\return","Returns").replace("\\c ","")
        print "\n  Most likely you now want to enter \"up<enter>l<enter>\"\n into the debugger to see what happened.\n"
        raise Exception("Grammar Error")
    return tuple(['complex']+list(args))

def Bool(*args):
    """
    Construct a "bool" node. Valid arguments are 
    (True_()
    |False_())
    \return (\c "Bool", True_()
    |False_())
    """
    f = Bool
    if len(args) <> 1:
        print "**GRAMMAR ERROR: expected 1 arguments for a", f.__name__
        print "Most likely you want to enter \"up<enter>l<enter>\" now to see what happened."
        raise Exception("Grammar Error")
    if args[0] == true:
        pass
    elif args[0] == false:
        pass
    else:
        print "\n","*"*72, "\n** GRAMMAR ERROR in argument args[0] = %s"%repr(args[0]),"\n", "*"*72
        print f.__name__+"():\n    \"\"\"%s\"\"\"\n" %f.__doc__.replace("\\n","\n").replace("\return","Returns").replace("\\c ","")
        print "\n  Most likely you now want to enter \"up<enter>l<enter>\"\n into the debugger to see what happened.\n"
        raise Exception("Grammar Error")
    return tuple(['bool']+list(args))

def Double(*args):
    """
    Construct a "double" node. Valid arguments are 
    (FLOAT())
    \return (\c "DoubleLiteral", FLOAT())
    """
    f = Double
    if len(args) <> 1:
        print "**GRAMMAR ERROR: expected 1 arguments for a", f.__name__
        print "Most likely you want to enter \"up<enter>l<enter>\" now to see what happened."
        raise Exception("Grammar Error")
    if isinstance(args[0], PythonTypes.FloatType):
        pass
    else:
        print "\n","*"*72, "\n** GRAMMAR ERROR in argument args[0] = %s"%repr(args[0]),"\n", "*"*72
        print f.__name__+"():\n    \"\"\"%s\"\"\"\n" %f.__doc__.replace("\\n","\n").replace("\return","Returns").replace("\\c ","")
        print "\n  Most likely you now want to enter \"up<enter>l<enter>\"\n into the debugger to see what happened.\n"
        raise Exception("Grammar Error")
    return tuple(['double']+list(args))

def Float(*args):
    """
    Construct a "float" node. Valid arguments are 
    (FLOAT())
    \return (\c "FloatLiteral", FLOAT())
    """
    f = Float
    if len(args) <> 1:
        print "**GRAMMAR ERROR: expected 1 arguments for a", f.__name__
        print "Most likely you want to enter \"up<enter>l<enter>\" now to see what happened."
        raise Exception("Grammar Error")
    if isinstance(args[0], PythonTypes.FloatType):
        pass
    else:
        print "\n","*"*72, "\n** GRAMMAR ERROR in argument args[0] = %s"%repr(args[0]),"\n", "*"*72
        print f.__name__+"():\n    \"\"\"%s\"\"\"\n" %f.__doc__.replace("\\n","\n").replace("\return","Returns").replace("\\c ","")
        print "\n  Most likely you now want to enter \"up<enter>l<enter>\"\n into the debugger to see what happened.\n"
        raise Exception("Grammar Error")
    return tuple(['float']+list(args))

def Str(*args):
    """
    Construct a "str" node. Valid arguments are 
    (STR())
    \return (\c "StringLiteral", STR())
    """
    f = Str
    if len(args) <> 1:
        print "**GRAMMAR ERROR: expected 1 arguments for a", f.__name__
        print "Most likely you want to enter \"up<enter>l<enter>\" now to see what happened."
        raise Exception("Grammar Error")
    if isinstance(args[0], PythonTypes.StringType):
        pass
    else:
        print "\n","*"*72, "\n** GRAMMAR ERROR in argument args[0] = %s"%repr(args[0]),"\n", "*"*72
        print f.__name__+"():\n    \"\"\"%s\"\"\"\n" %f.__doc__.replace("\\n","\n").replace("\return","Returns").replace("\\c ","")
        print "\n  Most likely you now want to enter \"up<enter>l<enter>\"\n into the debugger to see what happened.\n"
        raise Exception("Grammar Error")
    return tuple(['str']+list(args))

def Scoped_id(*args):
    """
    Construct a "scoped_id" node. Valid arguments are 
    ([\c Module()], \c Id(), \c Extension())
    \return (\c "Scoped_id", [\c Module()], \c Id(), \c Extension())
    """
    f = Scoped_id
    if len(args) <> 3:
        print "**GRAMMAR ERROR: expected 3 arguments for a", f.__name__
        print "Most likely you want to enter \"up<enter>l<enter>\" now to see what happened."
        raise Exception("Grammar Error")
    if isinstance(args[0], list) or isinstance(args[0], tuple):
        for a in args[0]:
            if isinstance(a, PythonTypes.StringType):
                pass
            else:
                print "\n","*"*72, "\n** GRAMMAR ERROR in argument a = %s"%repr(a),"\n", "*"*72
                print f.__name__+"():\n    \"\"\"%s\"\"\"\n" %f.__doc__.replace("\\n","\n").replace("\return","Returns").replace("\\c ","")
                print "\n  Most likely you now want to enter \"up<enter>l<enter>\"\n into the debugger to see what happened.\n"
                raise Exception("Grammar Error")
    else:
        print "\n","*"*72, "\n** GRAMMAR ERROR in argument args[0] = %s"%repr(args[0]),"\n", "*"*72
        print f.__name__+"():\n    \"\"\"%s\"\"\"\n" %f.__doc__.replace("\\n","\n").replace("\return","Returns").replace("\\c ","")
        print "\n  Most likely you now want to enter \"up<enter>l<enter>\"\n into the debugger to see what happened.\n"
        raise Exception("Grammar Error")
    if isinstance(args[1], PythonTypes.StringType):
        pass
    else:
        print "\n","*"*72, "\n** GRAMMAR ERROR in argument args[1] = %s"%repr(args[1]),"\n", "*"*72
        print f.__name__+"():\n    \"\"\"%s\"\"\"\n" %f.__doc__.replace("\\n","\n").replace("\return","Returns").replace("\\c ","")
        print "\n  Most likely you now want to enter \"up<enter>l<enter>\"\n into the debugger to see what happened.\n"
        raise Exception("Grammar Error")
    if isinstance(args[2], PythonTypes.StringType):
        pass
    else:
        print "\n","*"*72, "\n** GRAMMAR ERROR in argument args[2] = %s"%repr(args[2]),"\n", "*"*72
        print f.__name__+"():\n    \"\"\"%s\"\"\"\n" %f.__doc__.replace("\\n","\n").replace("\return","Returns").replace("\\c ","")
        print "\n  Most likely you now want to enter \"up<enter>l<enter>\"\n into the debugger to see what happened.\n"
        raise Exception("Grammar Error")
    return tuple(['scoped_id']+list(args))

def STR():
    return STR
# skipping \c Enumerator= (\c Enumerator|\c Enumerator_value)
def Enum(*args):
    """
    Construct a "enum" node. Valid arguments are 
    (\c Id(), [\c Enumerator()], \c DocComment())
    \return (\c "Enum", \c Id(), [\c Enumerator()], \c DocComment())
    """
    f = Enum
    if len(args) <> 3:
        print "**GRAMMAR ERROR: expected 3 arguments for a", f.__name__
        print "Most likely you want to enter \"up<enter>l<enter>\" now to see what happened."
        raise Exception("Grammar Error")
    if isinstance(args[0], PythonTypes.StringType):
        pass
    else:
        print "\n","*"*72, "\n** GRAMMAR ERROR in argument args[0] = %s"%repr(args[0]),"\n", "*"*72
        print f.__name__+"():\n    \"\"\"%s\"\"\"\n" %f.__doc__.replace("\\n","\n").replace("\return","Returns").replace("\\c ","")
        print "\n  Most likely you now want to enter \"up<enter>l<enter>\"\n into the debugger to see what happened.\n"
        raise Exception("Grammar Error")
    if isinstance(args[1], list) or isinstance(args[1], tuple):
        for a in args[1]:
            if isinstance(a, tuple) and a[0] == enumerator:
                pass
            elif isinstance(a, tuple) and a[0] == enumerator_value:
                pass
            else:
                print "\n","*"*72, "\n** GRAMMAR ERROR in argument a = %s"%repr(a),"\n", "*"*72
                print f.__name__+"():\n    \"\"\"%s\"\"\"\n" %f.__doc__.replace("\\n","\n").replace("\return","Returns").replace("\\c ","")
                print "\n  Most likely you now want to enter \"up<enter>l<enter>\"\n into the debugger to see what happened.\n"
                raise Exception("Grammar Error")
    else:
        print "\n","*"*72, "\n** GRAMMAR ERROR in argument args[1] = %s"%repr(args[1]),"\n", "*"*72
        print f.__name__+"():\n    \"\"\"%s\"\"\"\n" %f.__doc__.replace("\\n","\n").replace("\return","Returns").replace("\\c ","")
        print "\n  Most likely you now want to enter \"up<enter>l<enter>\"\n into the debugger to see what happened.\n"
        raise Exception("Grammar Error")
    if isinstance(args[2], PythonTypes.StringType):
        pass
    else:
        print "\n","*"*72, "\n** GRAMMAR ERROR in argument args[2] = %s"%repr(args[2]),"\n", "*"*72
        print f.__name__+"():\n    \"\"\"%s\"\"\"\n" %f.__doc__.replace("\\n","\n").replace("\return","Returns").replace("\\c ","")
        print "\n  Most likely you now want to enter \"up<enter>l<enter>\"\n into the debugger to see what happened.\n"
        raise Exception("Grammar Error")
    return tuple(['enum']+list(args))

def Deref(*args):
    """
    Construct a "deref" node. Valid arguments are 
    (\c VarRefExpr())
    \return (\c "Deref", \c VarRefExpr())
    """
    f = Deref
    if len(args) <> 1:
        print "**GRAMMAR ERROR: expected 1 arguments for a", f.__name__
        print "Most likely you want to enter \"up<enter>l<enter>\" now to see what happened."
        raise Exception("Grammar Error")
    if isinstance(args[0], PythonTypes.StringType):
        pass
    elif isinstance(args[0], tuple) and args[0][0] == pointer_expr:
        pass
    elif isinstance(args[0], tuple) and args[0][0] == deref:
        pass
    elif isinstance(args[0], tuple) and args[0][0] == get_struct_item:
        pass
    elif isinstance(args[0], tuple) and args[0][0] == call:
        pass
    else:
        print "\n","*"*72, "\n** GRAMMAR ERROR in argument args[0] = %s"%repr(args[0]),"\n", "*"*72
        print f.__name__+"():\n    \"\"\"%s\"\"\"\n" %f.__doc__.replace("\\n","\n").replace("\return","Returns").replace("\\c ","")
        print "\n  Most likely you now want to enter \"up<enter>l<enter>\"\n into the debugger to see what happened.\n"
        raise Exception("Grammar Error")
    return tuple(['deref']+list(args))

def Pointer_expr(*args):
    """
    Construct a "pointer_expr" node. Valid arguments are 
    (\c VarRefExpr())
    \return (\c "Pointer_expr", \c VarRefExpr())
    """
    f = Pointer_expr
    if len(args) <> 1:
        print "**GRAMMAR ERROR: expected 1 arguments for a", f.__name__
        print "Most likely you want to enter \"up<enter>l<enter>\" now to see what happened."
        raise Exception("Grammar Error")
    if isinstance(args[0], PythonTypes.StringType):
        pass
    elif isinstance(args[0], tuple) and args[0][0] == pointer_expr:
        pass
    elif isinstance(args[0], tuple) and args[0][0] == deref:
        pass
    elif isinstance(args[0], tuple) and args[0][0] == get_struct_item:
        pass
    elif isinstance(args[0], tuple) and args[0][0] == call:
        pass
    else:
        print "\n","*"*72, "\n** GRAMMAR ERROR in argument args[0] = %s"%repr(args[0]),"\n", "*"*72
        print f.__name__+"():\n    \"\"\"%s\"\"\"\n" %f.__doc__.replace("\\n","\n").replace("\return","Returns").replace("\\c ","")
        print "\n  Most likely you now want to enter \"up<enter>l<enter>\"\n into the debugger to see what happened.\n"
        raise Exception("Grammar Error")
    return tuple(['pointer_expr']+list(args))

# skipping \c Attr= (static|pure|hooks)
# skipping \c Mode= (in|out|inout)
def Rarray(*args):
    """
    Construct a "rarray" node. Valid arguments are 
    (\c Primitive_type(), \c Dimension(), [\c Extents()])
    \return (\c "Rarray", \c Primitive_type(), \c Dimension(), [\c Extents()])
    """
    f = Rarray
    if len(args) <> 3:
        print "**GRAMMAR ERROR: expected 3 arguments for a", f.__name__
        print "Most likely you want to enter \"up<enter>l<enter>\" now to see what happened."
        raise Exception("Grammar Error")
    if isinstance(args[0], tuple) and args[0][0] == primitive_type:
        pass
    else:
        print "\n","*"*72, "\n** GRAMMAR ERROR in argument args[0] = %s"%repr(args[0]),"\n", "*"*72
        print f.__name__+"():\n    \"\"\"%s\"\"\"\n" %f.__doc__.replace("\\n","\n").replace("\return","Returns").replace("\\c ","")
        print "\n  Most likely you now want to enter \"up<enter>l<enter>\"\n into the debugger to see what happened.\n"
        raise Exception("Grammar Error")
    if isinstance(args[1], PythonTypes.IntType):
        pass
    else:
        print "\n","*"*72, "\n** GRAMMAR ERROR in argument args[1] = %s"%repr(args[1]),"\n", "*"*72
        print f.__name__+"():\n    \"\"\"%s\"\"\"\n" %f.__doc__.replace("\\n","\n").replace("\return","Returns").replace("\\c ","")
        print "\n  Most likely you now want to enter \"up<enter>l<enter>\"\n into the debugger to see what happened.\n"
        raise Exception("Grammar Error")
    if isinstance(args[2], list) or isinstance(args[2], tuple):
        for a in args[2]:
            if isinstance(a, tuple) and a[0] == simple_int_infix_expr:
                pass
            elif isinstance(a, tuple) and a[0] == simple_int_prefix_expr:
                pass
            elif isinstance(a, tuple) and a[0] == simple_int_fn_eval:
                pass
            elif isinstance(a, tuple) and a[0] == var_ref:
                pass
            elif isinstance(a, PythonTypes.IntType):
                pass
            else:
                print "\n","*"*72, "\n** GRAMMAR ERROR in argument a = %s"%repr(a),"\n", "*"*72
                print f.__name__+"():\n    \"\"\"%s\"\"\"\n" %f.__doc__.replace("\\n","\n").replace("\return","Returns").replace("\\c ","")
                print "\n  Most likely you now want to enter \"up<enter>l<enter>\"\n into the debugger to see what happened.\n"
                raise Exception("Grammar Error")
    else:
        print "\n","*"*72, "\n** GRAMMAR ERROR in argument args[2] = %s"%repr(args[2]),"\n", "*"*72
        print f.__name__+"():\n    \"\"\"%s\"\"\"\n" %f.__doc__.replace("\\n","\n").replace("\return","Returns").replace("\\c ","")
        print "\n  Most likely you now want to enter \"up<enter>l<enter>\"\n into the debugger to see what happened.\n"
        raise Exception("Grammar Error")
    return tuple(['rarray']+list(args))

def Pointer_type(*args):
    """
    Construct a "pointer_type" node. Valid arguments are 
    (\c Type()
    |\c Fn_decl())
    \return (\c "Pointer_type", \c Type()
    |\c Fn_decl())
    """
    f = Pointer_type
    if len(args) <> 1:
        print "**GRAMMAR ERROR: expected 1 arguments for a", f.__name__
        print "Most likely you want to enter \"up<enter>l<enter>\" now to see what happened."
        raise Exception("Grammar Error")
    if isinstance(args[0], tuple) and args[0][0] == primitive_type:
        pass
    elif isinstance(args[0], tuple) and args[0][0] == pointer_type:
        pass
    elif isinstance(args[0], tuple) and args[0][0] == typedef_type:
        pass
    elif isinstance(args[0], tuple) and args[0][0] == const:
        pass
    elif isinstance(args[0], tuple) and args[0][0] == struct:
        pass
    elif isinstance(args[0], tuple) and args[0][0] == enum:
        pass
    elif isinstance(args[0], tuple) and args[0][0] == rarray:
        pass
    elif isinstance(args[0], tuple) and args[0][0] == fn_decl:
        pass
    else:
        print "\n","*"*72, "\n** GRAMMAR ERROR in argument args[0] = %s"%repr(args[0]),"\n", "*"*72
        print f.__name__+"():\n    \"\"\"%s\"\"\"\n" %f.__doc__.replace("\\n","\n").replace("\return","Returns").replace("\\c ","")
        print "\n  Most likely you now want to enter \"up<enter>l<enter>\"\n into the debugger to see what happened.\n"
        raise Exception("Grammar Error")
    return tuple(['pointer_type']+list(args))

def Primitive_type(*args):
    """
    Construct a "primitive_type" node. Valid arguments are 
    (Bool()
    |Char()
    |Int()
    |Long()
    |Long_long()
    |Float()
    |Double()
    |Long_double()
    |Fcomplex()
    |Dcomplex()
    |String()
    |Void())
    \return (\c "Primitive_type", Bool()
    |Char()
    |Int()
    |Long()
    |Long_long()
    |Float()
    |Double()
    |Long_double()
    |Fcomplex()
    |Dcomplex()
    |String()
    |Void())
    """
    f = Primitive_type
    if len(args) <> 1:
        print "**GRAMMAR ERROR: expected 1 arguments for a", f.__name__
        print "Most likely you want to enter \"up<enter>l<enter>\" now to see what happened."
        raise Exception("Grammar Error")
    if args[0] == bool:
        pass
    elif args[0] == char:
        pass
    elif args[0] == int:
        pass
    elif args[0] == long:
        pass
    elif args[0] == long_long:
        pass
    elif args[0] == float:
        pass
    elif args[0] == double:
        pass
    elif args[0] == long_double:
        pass
    elif args[0] == fcomplex:
        pass
    elif args[0] == dcomplex:
        pass
    elif args[0] == string:
        pass
    elif args[0] == void:
        pass
    else:
        print "\n","*"*72, "\n** GRAMMAR ERROR in argument args[0] = %s"%repr(args[0]),"\n", "*"*72
        print f.__name__+"():\n    \"\"\"%s\"\"\"\n" %f.__doc__.replace("\\n","\n").replace("\return","Returns").replace("\\c ","")
        print "\n  Most likely you now want to enter \"up<enter>l<enter>\"\n into the debugger to see what happened.\n"
        raise Exception("Grammar Error")
    return tuple(['primitive_type']+list(args))

# skipping \c Extents= \c SimpleIntExpr
def INT():
    return INT
# skipping \c SimpleIntExpr= (\c Simple_int_infix_expr|\c Simple_int_prefix_expr|\c Simple_int_fn_eval|\c Var_ref|INT)
def STR():
    return STR
def STR():
    return STR
def Type_decl(*args):
    """
    Construct a "type_decl" node. Valid arguments are 
    (\c Type())
    \return (\c "Type_decl", \c Type())
    """
    f = Type_decl
    if len(args) <> 1:
        print "**GRAMMAR ERROR: expected 1 arguments for a", f.__name__
        print "Most likely you want to enter \"up<enter>l<enter>\" now to see what happened."
        raise Exception("Grammar Error")
    if isinstance(args[0], tuple) and args[0][0] == primitive_type:
        pass
    elif isinstance(args[0], tuple) and args[0][0] == pointer_type:
        pass
    elif isinstance(args[0], tuple) and args[0][0] == typedef_type:
        pass
    elif isinstance(args[0], tuple) and args[0][0] == const:
        pass
    elif isinstance(args[0], tuple) and args[0][0] == struct:
        pass
    elif isinstance(args[0], tuple) and args[0][0] == enum:
        pass
    elif isinstance(args[0], tuple) and args[0][0] == rarray:
        pass
    else:
        print "\n","*"*72, "\n** GRAMMAR ERROR in argument args[0] = %s"%repr(args[0]),"\n", "*"*72
        print f.__name__+"():\n    \"\"\"%s\"\"\"\n" %f.__doc__.replace("\\n","\n").replace("\return","Returns").replace("\\c ","")
        print "\n  Most likely you now want to enter \"up<enter>l<enter>\"\n into the debugger to see what happened.\n"
        raise Exception("Grammar Error")
    return tuple(['type_decl']+list(args))

def Stmt(*args):
    """
    Construct a "stmt" node. Valid arguments are 
    (\c Do_while()
    |\c While()
    |Break()
    |\c Return()
    |\c If()
    |\c Goto()
    |\c Expr())
    \return (\c "Stmt", \c Do_while()
    |\c While()
    |Break()
    |\c Return()
    |\c If()
    |\c Goto()
    |\c Expr())
    """
    f = Stmt
    if len(args) <> 1:
        print "**GRAMMAR ERROR: expected 1 arguments for a", f.__name__
        print "Most likely you want to enter \"up<enter>l<enter>\" now to see what happened."
        raise Exception("Grammar Error")
    if isinstance(args[0], tuple) and args[0][0] == do_while:
        pass
    elif isinstance(args[0], tuple) and args[0][0] == while_:
        pass
    elif args[0] == break_:
        pass
    elif isinstance(args[0], tuple) and args[0][0] == return_:
        pass
    elif isinstance(args[0], tuple) and args[0][0] == if_:
        pass
    elif isinstance(args[0], tuple) and args[0][0] == goto:
        pass
    elif isinstance(args[0], tuple) and args[0][0] == str:
        pass
    elif isinstance(args[0], tuple) and args[0][0] == float:
        pass
    elif isinstance(args[0], tuple) and args[0][0] == double:
        pass
    elif isinstance(args[0], PythonTypes.IntType):
        pass
    elif args[0] == pure:
        pass
    elif args[0] == result:
        pass
    elif isinstance(args[0], tuple) and args[0][0] == complex:
        pass
    elif isinstance(args[0], tuple) and args[0][0] == bool:
        pass
    elif isinstance(args[0], tuple) and args[0][0] == new:
        pass
    elif isinstance(args[0], tuple) and args[0][0] == var_decl:
        pass
    elif isinstance(args[0], tuple) and args[0][0] == var_decl_init:
        pass
    elif isinstance(args[0], PythonTypes.StringType):
        pass
    elif isinstance(args[0], tuple) and args[0][0] == pointer_expr:
        pass
    elif isinstance(args[0], tuple) and args[0][0] == deref:
        pass
    elif isinstance(args[0], tuple) and args[0][0] == get_struct_item:
        pass
    elif isinstance(args[0], tuple) and args[0][0] == call:
        pass
    elif isinstance(args[0], tuple) and args[0][0] == cast:
        pass
    elif isinstance(args[0], tuple) and args[0][0] == set_struct_item:
        pass
    elif isinstance(args[0], tuple) and args[0][0] == assignment:
        pass
    elif isinstance(args[0], tuple) and args[0][0] == set_arg:
        pass
    elif isinstance(args[0], tuple) and args[0][0] == infix_expr:
        pass
    elif isinstance(args[0], tuple) and args[0][0] == prefix_expr:
        pass
    elif isinstance(args[0], tuple) and args[0][0] == sign_extend:
        pass
    else:
        print "\n","*"*72, "\n** GRAMMAR ERROR in argument args[0] = %s"%repr(args[0]),"\n", "*"*72
        print f.__name__+"():\n    \"\"\"%s\"\"\"\n" %f.__doc__.replace("\\n","\n").replace("\return","Returns").replace("\\c ","")
        print "\n  Most likely you now want to enter \"up<enter>l<enter>\"\n into the debugger to see what happened.\n"
        raise Exception("Grammar Error")
    return tuple(['stmt']+list(args))

def New(*args):
    """
    Construct a "new" node. Valid arguments are 
    (\c Type(), [\c Arg()])
    \return (\c "New", \c Type(), [\c Arg()])
    """
    f = New
    if len(args) <> 2:
        print "**GRAMMAR ERROR: expected 2 arguments for a", f.__name__
        print "Most likely you want to enter \"up<enter>l<enter>\" now to see what happened."
        raise Exception("Grammar Error")
    if isinstance(args[0], tuple) and args[0][0] == primitive_type:
        pass
    elif isinstance(args[0], tuple) and args[0][0] == pointer_type:
        pass
    elif isinstance(args[0], tuple) and args[0][0] == typedef_type:
        pass
    elif isinstance(args[0], tuple) and args[0][0] == const:
        pass
    elif isinstance(args[0], tuple) and args[0][0] == struct:
        pass
    elif isinstance(args[0], tuple) and args[0][0] == enum:
        pass
    elif isinstance(args[0], tuple) and args[0][0] == rarray:
        pass
    else:
        print "\n","*"*72, "\n** GRAMMAR ERROR in argument args[0] = %s"%repr(args[0]),"\n", "*"*72
        print f.__name__+"():\n    \"\"\"%s\"\"\"\n" %f.__doc__.replace("\\n","\n").replace("\return","Returns").replace("\\c ","")
        print "\n  Most likely you now want to enter \"up<enter>l<enter>\"\n into the debugger to see what happened.\n"
        raise Exception("Grammar Error")
    if isinstance(args[1], list) or isinstance(args[1], tuple):
        for a in args[1]:
            if isinstance(a, tuple) and a[0] == arg:
                pass
            else:
                print "\n","*"*72, "\n** GRAMMAR ERROR in argument a = %s"%repr(a),"\n", "*"*72
                print f.__name__+"():\n    \"\"\"%s\"\"\"\n" %f.__doc__.replace("\\n","\n").replace("\return","Returns").replace("\\c ","")
                print "\n  Most likely you now want to enter \"up<enter>l<enter>\"\n into the debugger to see what happened.\n"
                raise Exception("Grammar Error")
    else:
        print "\n","*"*72, "\n** GRAMMAR ERROR in argument args[1] = %s"%repr(args[1]),"\n", "*"*72
        print f.__name__+"():\n    \"\"\"%s\"\"\"\n" %f.__doc__.replace("\\n","\n").replace("\return","Returns").replace("\\c ","")
        print "\n  Most likely you now want to enter \"up<enter>l<enter>\"\n into the debugger to see what happened.\n"
        raise Exception("Grammar Error")
    return tuple(['new']+list(args))

def Cast(*args):
    """
    Construct a "cast" node. Valid arguments are 
    (\c Type(), \c Expr())
    \return (\c "Cast", \c Type(), \c Expr())
    """
    f = Cast
    if len(args) <> 2:
        print "**GRAMMAR ERROR: expected 2 arguments for a", f.__name__
        print "Most likely you want to enter \"up<enter>l<enter>\" now to see what happened."
        raise Exception("Grammar Error")
    if isinstance(args[0], tuple) and args[0][0] == primitive_type:
        pass
    elif isinstance(args[0], tuple) and args[0][0] == pointer_type:
        pass
    elif isinstance(args[0], tuple) and args[0][0] == typedef_type:
        pass
    elif isinstance(args[0], tuple) and args[0][0] == const:
        pass
    elif isinstance(args[0], tuple) and args[0][0] == struct:
        pass
    elif isinstance(args[0], tuple) and args[0][0] == enum:
        pass
    elif isinstance(args[0], tuple) and args[0][0] == rarray:
        pass
    else:
        print "\n","*"*72, "\n** GRAMMAR ERROR in argument args[0] = %s"%repr(args[0]),"\n", "*"*72
        print f.__name__+"():\n    \"\"\"%s\"\"\"\n" %f.__doc__.replace("\\n","\n").replace("\return","Returns").replace("\\c ","")
        print "\n  Most likely you now want to enter \"up<enter>l<enter>\"\n into the debugger to see what happened.\n"
        raise Exception("Grammar Error")
    if isinstance(args[1], tuple) and args[1][0] == str:
        pass
    elif isinstance(args[1], tuple) and args[1][0] == float:
        pass
    elif isinstance(args[1], tuple) and args[1][0] == double:
        pass
    elif isinstance(args[1], PythonTypes.IntType):
        pass
    elif args[1] == pure:
        pass
    elif args[1] == result:
        pass
    elif isinstance(args[1], tuple) and args[1][0] == complex:
        pass
    elif isinstance(args[1], tuple) and args[1][0] == bool:
        pass
    elif isinstance(args[1], tuple) and args[1][0] == new:
        pass
    elif isinstance(args[1], tuple) and args[1][0] == var_decl:
        pass
    elif isinstance(args[1], tuple) and args[1][0] == var_decl_init:
        pass
    elif isinstance(args[1], PythonTypes.StringType):
        pass
    elif isinstance(args[1], tuple) and args[1][0] == pointer_expr:
        pass
    elif isinstance(args[1], tuple) and args[1][0] == deref:
        pass
    elif isinstance(args[1], tuple) and args[1][0] == get_struct_item:
        pass
    elif isinstance(args[1], tuple) and args[1][0] == call:
        pass
    elif isinstance(args[1], tuple) and args[1][0] == cast:
        pass
    elif isinstance(args[1], tuple) and args[1][0] == set_struct_item:
        pass
    elif isinstance(args[1], tuple) and args[1][0] == assignment:
        pass
    elif isinstance(args[1], tuple) and args[1][0] == set_arg:
        pass
    elif isinstance(args[1], tuple) and args[1][0] == infix_expr:
        pass
    elif isinstance(args[1], tuple) and args[1][0] == prefix_expr:
        pass
    elif isinstance(args[1], tuple) and args[1][0] == sign_extend:
        pass
    else:
        print "\n","*"*72, "\n** GRAMMAR ERROR in argument args[1] = %s"%repr(args[1]),"\n", "*"*72
        print f.__name__+"():\n    \"\"\"%s\"\"\"\n" %f.__doc__.replace("\\n","\n").replace("\return","Returns").replace("\\c ","")
        print "\n  Most likely you now want to enter \"up<enter>l<enter>\"\n into the debugger to see what happened.\n"
        raise Exception("Grammar Error")
    return tuple(['cast']+list(args))

def Set_struct_item(*args):
    """
    Construct a "set_struct_item" node. Valid arguments are 
    (\c Struct(), \c Expr(), \c Struct_item(), \c Expr())
    \return (\c "Set_struct_item", \c Struct(), \c Expr(), \c Struct_item(), \c Expr())
    """
    f = Set_struct_item
    if len(args) <> 4:
        print "**GRAMMAR ERROR: expected 4 arguments for a", f.__name__
        print "Most likely you want to enter \"up<enter>l<enter>\" now to see what happened."
        raise Exception("Grammar Error")
    if isinstance(args[0], tuple) and args[0][0] == struct:
        pass
    else:
        print "\n","*"*72, "\n** GRAMMAR ERROR in argument args[0] = %s"%repr(args[0]),"\n", "*"*72
        print f.__name__+"():\n    \"\"\"%s\"\"\"\n" %f.__doc__.replace("\\n","\n").replace("\return","Returns").replace("\\c ","")
        print "\n  Most likely you now want to enter \"up<enter>l<enter>\"\n into the debugger to see what happened.\n"
        raise Exception("Grammar Error")
    if isinstance(args[1], tuple) and args[1][0] == str:
        pass
    elif isinstance(args[1], tuple) and args[1][0] == float:
        pass
    elif isinstance(args[1], tuple) and args[1][0] == double:
        pass
    elif isinstance(args[1], PythonTypes.IntType):
        pass
    elif args[1] == pure:
        pass
    elif args[1] == result:
        pass
    elif isinstance(args[1], tuple) and args[1][0] == complex:
        pass
    elif isinstance(args[1], tuple) and args[1][0] == bool:
        pass
    elif isinstance(args[1], tuple) and args[1][0] == new:
        pass
    elif isinstance(args[1], tuple) and args[1][0] == var_decl:
        pass
    elif isinstance(args[1], tuple) and args[1][0] == var_decl_init:
        pass
    elif isinstance(args[1], PythonTypes.StringType):
        pass
    elif isinstance(args[1], tuple) and args[1][0] == pointer_expr:
        pass
    elif isinstance(args[1], tuple) and args[1][0] == deref:
        pass
    elif isinstance(args[1], tuple) and args[1][0] == get_struct_item:
        pass
    elif isinstance(args[1], tuple) and args[1][0] == call:
        pass
    elif isinstance(args[1], tuple) and args[1][0] == cast:
        pass
    elif isinstance(args[1], tuple) and args[1][0] == set_struct_item:
        pass
    elif isinstance(args[1], tuple) and args[1][0] == assignment:
        pass
    elif isinstance(args[1], tuple) and args[1][0] == set_arg:
        pass
    elif isinstance(args[1], tuple) and args[1][0] == infix_expr:
        pass
    elif isinstance(args[1], tuple) and args[1][0] == prefix_expr:
        pass
    elif isinstance(args[1], tuple) and args[1][0] == sign_extend:
        pass
    else:
        print "\n","*"*72, "\n** GRAMMAR ERROR in argument args[1] = %s"%repr(args[1]),"\n", "*"*72
        print f.__name__+"():\n    \"\"\"%s\"\"\"\n" %f.__doc__.replace("\\n","\n").replace("\return","Returns").replace("\\c ","")
        print "\n  Most likely you now want to enter \"up<enter>l<enter>\"\n into the debugger to see what happened.\n"
        raise Exception("Grammar Error")
    if isinstance(args[2], tuple) and args[2][0] == struct_item:
        pass
    else:
        print "\n","*"*72, "\n** GRAMMAR ERROR in argument args[2] = %s"%repr(args[2]),"\n", "*"*72
        print f.__name__+"():\n    \"\"\"%s\"\"\"\n" %f.__doc__.replace("\\n","\n").replace("\return","Returns").replace("\\c ","")
        print "\n  Most likely you now want to enter \"up<enter>l<enter>\"\n into the debugger to see what happened.\n"
        raise Exception("Grammar Error")
    if isinstance(args[3], tuple) and args[3][0] == str:
        pass
    elif isinstance(args[3], tuple) and args[3][0] == float:
        pass
    elif isinstance(args[3], tuple) and args[3][0] == double:
        pass
    elif isinstance(args[3], PythonTypes.IntType):
        pass
    elif args[3] == pure:
        pass
    elif args[3] == result:
        pass
    elif isinstance(args[3], tuple) and args[3][0] == complex:
        pass
    elif isinstance(args[3], tuple) and args[3][0] == bool:
        pass
    elif isinstance(args[3], tuple) and args[3][0] == new:
        pass
    elif isinstance(args[3], tuple) and args[3][0] == var_decl:
        pass
    elif isinstance(args[3], tuple) and args[3][0] == var_decl_init:
        pass
    elif isinstance(args[3], PythonTypes.StringType):
        pass
    elif isinstance(args[3], tuple) and args[3][0] == pointer_expr:
        pass
    elif isinstance(args[3], tuple) and args[3][0] == deref:
        pass
    elif isinstance(args[3], tuple) and args[3][0] == get_struct_item:
        pass
    elif isinstance(args[3], tuple) and args[3][0] == call:
        pass
    elif isinstance(args[3], tuple) and args[3][0] == cast:
        pass
    elif isinstance(args[3], tuple) and args[3][0] == set_struct_item:
        pass
    elif isinstance(args[3], tuple) and args[3][0] == assignment:
        pass
    elif isinstance(args[3], tuple) and args[3][0] == set_arg:
        pass
    elif isinstance(args[3], tuple) and args[3][0] == infix_expr:
        pass
    elif isinstance(args[3], tuple) and args[3][0] == prefix_expr:
        pass
    elif isinstance(args[3], tuple) and args[3][0] == sign_extend:
        pass
    else:
        print "\n","*"*72, "\n** GRAMMAR ERROR in argument args[3] = %s"%repr(args[3]),"\n", "*"*72
        print f.__name__+"():\n    \"\"\"%s\"\"\"\n" %f.__doc__.replace("\\n","\n").replace("\return","Returns").replace("\\c ","")
        print "\n  Most likely you now want to enter \"up<enter>l<enter>\"\n into the debugger to see what happened.\n"
        raise Exception("Grammar Error")
    return tuple(['set_struct_item']+list(args))

def Assignment(*args):
    """
    Construct a "assignment" node. Valid arguments are 
    (\c VarRefExpr(), \c Expr())
    \return (\c "Assignment", \c VarRefExpr(), \c Expr())
    """
    f = Assignment
    if len(args) <> 2:
        print "**GRAMMAR ERROR: expected 2 arguments for a", f.__name__
        print "Most likely you want to enter \"up<enter>l<enter>\" now to see what happened."
        raise Exception("Grammar Error")
    if isinstance(args[0], PythonTypes.StringType):
        pass
    elif isinstance(args[0], tuple) and args[0][0] == pointer_expr:
        pass
    elif isinstance(args[0], tuple) and args[0][0] == deref:
        pass
    elif isinstance(args[0], tuple) and args[0][0] == get_struct_item:
        pass
    elif isinstance(args[0], tuple) and args[0][0] == call:
        pass
    else:
        print "\n","*"*72, "\n** GRAMMAR ERROR in argument args[0] = %s"%repr(args[0]),"\n", "*"*72
        print f.__name__+"():\n    \"\"\"%s\"\"\"\n" %f.__doc__.replace("\\n","\n").replace("\return","Returns").replace("\\c ","")
        print "\n  Most likely you now want to enter \"up<enter>l<enter>\"\n into the debugger to see what happened.\n"
        raise Exception("Grammar Error")
    if isinstance(args[1], tuple) and args[1][0] == str:
        pass
    elif isinstance(args[1], tuple) and args[1][0] == float:
        pass
    elif isinstance(args[1], tuple) and args[1][0] == double:
        pass
    elif isinstance(args[1], PythonTypes.IntType):
        pass
    elif args[1] == pure:
        pass
    elif args[1] == result:
        pass
    elif isinstance(args[1], tuple) and args[1][0] == complex:
        pass
    elif isinstance(args[1], tuple) and args[1][0] == bool:
        pass
    elif isinstance(args[1], tuple) and args[1][0] == new:
        pass
    elif isinstance(args[1], tuple) and args[1][0] == var_decl:
        pass
    elif isinstance(args[1], tuple) and args[1][0] == var_decl_init:
        pass
    elif isinstance(args[1], PythonTypes.StringType):
        pass
    elif isinstance(args[1], tuple) and args[1][0] == pointer_expr:
        pass
    elif isinstance(args[1], tuple) and args[1][0] == deref:
        pass
    elif isinstance(args[1], tuple) and args[1][0] == get_struct_item:
        pass
    elif isinstance(args[1], tuple) and args[1][0] == call:
        pass
    elif isinstance(args[1], tuple) and args[1][0] == cast:
        pass
    elif isinstance(args[1], tuple) and args[1][0] == set_struct_item:
        pass
    elif isinstance(args[1], tuple) and args[1][0] == assignment:
        pass
    elif isinstance(args[1], tuple) and args[1][0] == set_arg:
        pass
    elif isinstance(args[1], tuple) and args[1][0] == infix_expr:
        pass
    elif isinstance(args[1], tuple) and args[1][0] == prefix_expr:
        pass
    elif isinstance(args[1], tuple) and args[1][0] == sign_extend:
        pass
    else:
        print "\n","*"*72, "\n** GRAMMAR ERROR in argument args[1] = %s"%repr(args[1]),"\n", "*"*72
        print f.__name__+"():\n    \"\"\"%s\"\"\"\n" %f.__doc__.replace("\\n","\n").replace("\return","Returns").replace("\\c ","")
        print "\n  Most likely you now want to enter \"up<enter>l<enter>\"\n into the debugger to see what happened.\n"
        raise Exception("Grammar Error")
    return tuple(['assignment']+list(args))

def Set_arg(*args):
    """
    Construct a "set_arg" node. Valid arguments are 
    (\c VarRefExpr(), \c Expr())
    \return (\c "Set_arg", \c VarRefExpr(), \c Expr())
    """
    f = Set_arg
    if len(args) <> 2:
        print "**GRAMMAR ERROR: expected 2 arguments for a", f.__name__
        print "Most likely you want to enter \"up<enter>l<enter>\" now to see what happened."
        raise Exception("Grammar Error")
    if isinstance(args[0], PythonTypes.StringType):
        pass
    elif isinstance(args[0], tuple) and args[0][0] == pointer_expr:
        pass
    elif isinstance(args[0], tuple) and args[0][0] == deref:
        pass
    elif isinstance(args[0], tuple) and args[0][0] == get_struct_item:
        pass
    elif isinstance(args[0], tuple) and args[0][0] == call:
        pass
    else:
        print "\n","*"*72, "\n** GRAMMAR ERROR in argument args[0] = %s"%repr(args[0]),"\n", "*"*72
        print f.__name__+"():\n    \"\"\"%s\"\"\"\n" %f.__doc__.replace("\\n","\n").replace("\return","Returns").replace("\\c ","")
        print "\n  Most likely you now want to enter \"up<enter>l<enter>\"\n into the debugger to see what happened.\n"
        raise Exception("Grammar Error")
    if isinstance(args[1], tuple) and args[1][0] == str:
        pass
    elif isinstance(args[1], tuple) and args[1][0] == float:
        pass
    elif isinstance(args[1], tuple) and args[1][0] == double:
        pass
    elif isinstance(args[1], PythonTypes.IntType):
        pass
    elif args[1] == pure:
        pass
    elif args[1] == result:
        pass
    elif isinstance(args[1], tuple) and args[1][0] == complex:
        pass
    elif isinstance(args[1], tuple) and args[1][0] == bool:
        pass
    elif isinstance(args[1], tuple) and args[1][0] == new:
        pass
    elif isinstance(args[1], tuple) and args[1][0] == var_decl:
        pass
    elif isinstance(args[1], tuple) and args[1][0] == var_decl_init:
        pass
    elif isinstance(args[1], PythonTypes.StringType):
        pass
    elif isinstance(args[1], tuple) and args[1][0] == pointer_expr:
        pass
    elif isinstance(args[1], tuple) and args[1][0] == deref:
        pass
    elif isinstance(args[1], tuple) and args[1][0] == get_struct_item:
        pass
    elif isinstance(args[1], tuple) and args[1][0] == call:
        pass
    elif isinstance(args[1], tuple) and args[1][0] == cast:
        pass
    elif isinstance(args[1], tuple) and args[1][0] == set_struct_item:
        pass
    elif isinstance(args[1], tuple) and args[1][0] == assignment:
        pass
    elif isinstance(args[1], tuple) and args[1][0] == set_arg:
        pass
    elif isinstance(args[1], tuple) and args[1][0] == infix_expr:
        pass
    elif isinstance(args[1], tuple) and args[1][0] == prefix_expr:
        pass
    elif isinstance(args[1], tuple) and args[1][0] == sign_extend:
        pass
    else:
        print "\n","*"*72, "\n** GRAMMAR ERROR in argument args[1] = %s"%repr(args[1]),"\n", "*"*72
        print f.__name__+"():\n    \"\"\"%s\"\"\"\n" %f.__doc__.replace("\\n","\n").replace("\return","Returns").replace("\\c ","")
        print "\n  Most likely you now want to enter \"up<enter>l<enter>\"\n into the debugger to see what happened.\n"
        raise Exception("Grammar Error")
    return tuple(['set_arg']+list(args))

def Infix_expr(*args):
    """
    Construct a "infix_expr" node. Valid arguments are 
    (\c Bin_op(), \c Expr(), \c Expr())
    \return (\c "Infix_expr", \c Bin_op(), \c Expr(), \c Expr())
    """
    f = Infix_expr
    if len(args) <> 3:
        print "**GRAMMAR ERROR: expected 3 arguments for a", f.__name__
        print "Most likely you want to enter \"up<enter>l<enter>\" now to see what happened."
        raise Exception("Grammar Error")
    if args[0] == log_or:
        pass
    elif args[0] == log_and:
        pass
    elif args[0] == eq:
        pass
    elif args[0] == ne:
        pass
    elif args[0] == bit_or:
        pass
    elif args[0] == bit_and:
        pass
    elif args[0] == bit_xor:
        pass
    elif args[0] == lt:
        pass
    elif args[0] == gt:
        pass
    elif args[0] == le:
        pass
    elif args[0] == ge:
        pass
    elif args[0] == lshift:
        pass
    elif args[0] == rshift:
        pass
    elif args[0] == plus:
        pass
    elif args[0] == minus:
        pass
    elif args[0] == times:
        pass
    elif args[0] == divide:
        pass
    elif args[0] == modulo:
        pass
    elif args[0] == pow:
        pass
    else:
        print "\n","*"*72, "\n** GRAMMAR ERROR in argument args[0] = %s"%repr(args[0]),"\n", "*"*72
        print f.__name__+"():\n    \"\"\"%s\"\"\"\n" %f.__doc__.replace("\\n","\n").replace("\return","Returns").replace("\\c ","")
        print "\n  Most likely you now want to enter \"up<enter>l<enter>\"\n into the debugger to see what happened.\n"
        raise Exception("Grammar Error")
    if isinstance(args[1], tuple) and args[1][0] == str:
        pass
    elif isinstance(args[1], tuple) and args[1][0] == float:
        pass
    elif isinstance(args[1], tuple) and args[1][0] == double:
        pass
    elif isinstance(args[1], PythonTypes.IntType):
        pass
    elif args[1] == pure:
        pass
    elif args[1] == result:
        pass
    elif isinstance(args[1], tuple) and args[1][0] == complex:
        pass
    elif isinstance(args[1], tuple) and args[1][0] == bool:
        pass
    elif isinstance(args[1], tuple) and args[1][0] == new:
        pass
    elif isinstance(args[1], tuple) and args[1][0] == var_decl:
        pass
    elif isinstance(args[1], tuple) and args[1][0] == var_decl_init:
        pass
    elif isinstance(args[1], PythonTypes.StringType):
        pass
    elif isinstance(args[1], tuple) and args[1][0] == pointer_expr:
        pass
    elif isinstance(args[1], tuple) and args[1][0] == deref:
        pass
    elif isinstance(args[1], tuple) and args[1][0] == get_struct_item:
        pass
    elif isinstance(args[1], tuple) and args[1][0] == call:
        pass
    elif isinstance(args[1], tuple) and args[1][0] == cast:
        pass
    elif isinstance(args[1], tuple) and args[1][0] == set_struct_item:
        pass
    elif isinstance(args[1], tuple) and args[1][0] == assignment:
        pass
    elif isinstance(args[1], tuple) and args[1][0] == set_arg:
        pass
    elif isinstance(args[1], tuple) and args[1][0] == infix_expr:
        pass
    elif isinstance(args[1], tuple) and args[1][0] == prefix_expr:
        pass
    elif isinstance(args[1], tuple) and args[1][0] == sign_extend:
        pass
    else:
        print "\n","*"*72, "\n** GRAMMAR ERROR in argument args[1] = %s"%repr(args[1]),"\n", "*"*72
        print f.__name__+"():\n    \"\"\"%s\"\"\"\n" %f.__doc__.replace("\\n","\n").replace("\return","Returns").replace("\\c ","")
        print "\n  Most likely you now want to enter \"up<enter>l<enter>\"\n into the debugger to see what happened.\n"
        raise Exception("Grammar Error")
    if isinstance(args[2], tuple) and args[2][0] == str:
        pass
    elif isinstance(args[2], tuple) and args[2][0] == float:
        pass
    elif isinstance(args[2], tuple) and args[2][0] == double:
        pass
    elif isinstance(args[2], PythonTypes.IntType):
        pass
    elif args[2] == pure:
        pass
    elif args[2] == result:
        pass
    elif isinstance(args[2], tuple) and args[2][0] == complex:
        pass
    elif isinstance(args[2], tuple) and args[2][0] == bool:
        pass
    elif isinstance(args[2], tuple) and args[2][0] == new:
        pass
    elif isinstance(args[2], tuple) and args[2][0] == var_decl:
        pass
    elif isinstance(args[2], tuple) and args[2][0] == var_decl_init:
        pass
    elif isinstance(args[2], PythonTypes.StringType):
        pass
    elif isinstance(args[2], tuple) and args[2][0] == pointer_expr:
        pass
    elif isinstance(args[2], tuple) and args[2][0] == deref:
        pass
    elif isinstance(args[2], tuple) and args[2][0] == get_struct_item:
        pass
    elif isinstance(args[2], tuple) and args[2][0] == call:
        pass
    elif isinstance(args[2], tuple) and args[2][0] == cast:
        pass
    elif isinstance(args[2], tuple) and args[2][0] == set_struct_item:
        pass
    elif isinstance(args[2], tuple) and args[2][0] == assignment:
        pass
    elif isinstance(args[2], tuple) and args[2][0] == set_arg:
        pass
    elif isinstance(args[2], tuple) and args[2][0] == infix_expr:
        pass
    elif isinstance(args[2], tuple) and args[2][0] == prefix_expr:
        pass
    elif isinstance(args[2], tuple) and args[2][0] == sign_extend:
        pass
    else:
        print "\n","*"*72, "\n** GRAMMAR ERROR in argument args[2] = %s"%repr(args[2]),"\n", "*"*72
        print f.__name__+"():\n    \"\"\"%s\"\"\"\n" %f.__doc__.replace("\\n","\n").replace("\return","Returns").replace("\\c ","")
        print "\n  Most likely you now want to enter \"up<enter>l<enter>\"\n into the debugger to see what happened.\n"
        raise Exception("Grammar Error")
    return tuple(['infix_expr']+list(args))

def Prefix_expr(*args):
    """
    Construct a "prefix_expr" node. Valid arguments are 
    (\c Un_op(), \c Expr())
    \return (\c "Prefix_expr", \c Un_op(), \c Expr())
    """
    f = Prefix_expr
    if len(args) <> 2:
        print "**GRAMMAR ERROR: expected 2 arguments for a", f.__name__
        print "Most likely you want to enter \"up<enter>l<enter>\" now to see what happened."
        raise Exception("Grammar Error")
    if args[0] == is_:
        pass
    elif args[0] == log_not:
        pass
    elif args[0] == bit_not:
        pass
    else:
        print "\n","*"*72, "\n** GRAMMAR ERROR in argument args[0] = %s"%repr(args[0]),"\n", "*"*72
        print f.__name__+"():\n    \"\"\"%s\"\"\"\n" %f.__doc__.replace("\\n","\n").replace("\return","Returns").replace("\\c ","")
        print "\n  Most likely you now want to enter \"up<enter>l<enter>\"\n into the debugger to see what happened.\n"
        raise Exception("Grammar Error")
    if isinstance(args[1], tuple) and args[1][0] == str:
        pass
    elif isinstance(args[1], tuple) and args[1][0] == float:
        pass
    elif isinstance(args[1], tuple) and args[1][0] == double:
        pass
    elif isinstance(args[1], PythonTypes.IntType):
        pass
    elif args[1] == pure:
        pass
    elif args[1] == result:
        pass
    elif isinstance(args[1], tuple) and args[1][0] == complex:
        pass
    elif isinstance(args[1], tuple) and args[1][0] == bool:
        pass
    elif isinstance(args[1], tuple) and args[1][0] == new:
        pass
    elif isinstance(args[1], tuple) and args[1][0] == var_decl:
        pass
    elif isinstance(args[1], tuple) and args[1][0] == var_decl_init:
        pass
    elif isinstance(args[1], PythonTypes.StringType):
        pass
    elif isinstance(args[1], tuple) and args[1][0] == pointer_expr:
        pass
    elif isinstance(args[1], tuple) and args[1][0] == deref:
        pass
    elif isinstance(args[1], tuple) and args[1][0] == get_struct_item:
        pass
    elif isinstance(args[1], tuple) and args[1][0] == call:
        pass
    elif isinstance(args[1], tuple) and args[1][0] == cast:
        pass
    elif isinstance(args[1], tuple) and args[1][0] == set_struct_item:
        pass
    elif isinstance(args[1], tuple) and args[1][0] == assignment:
        pass
    elif isinstance(args[1], tuple) and args[1][0] == set_arg:
        pass
    elif isinstance(args[1], tuple) and args[1][0] == infix_expr:
        pass
    elif isinstance(args[1], tuple) and args[1][0] == prefix_expr:
        pass
    elif isinstance(args[1], tuple) and args[1][0] == sign_extend:
        pass
    else:
        print "\n","*"*72, "\n** GRAMMAR ERROR in argument args[1] = %s"%repr(args[1]),"\n", "*"*72
        print f.__name__+"():\n    \"\"\"%s\"\"\"\n" %f.__doc__.replace("\\n","\n").replace("\return","Returns").replace("\\c ","")
        print "\n  Most likely you now want to enter \"up<enter>l<enter>\"\n into the debugger to see what happened.\n"
        raise Exception("Grammar Error")
    return tuple(['prefix_expr']+list(args))

def Sign_extend(*args):
    """
    Construct a "sign_extend" node. Valid arguments are 
    (\c Bits(), \c Expr())
    \return (\c "Sign_extend", \c Bits(), \c Expr())
    """
    f = Sign_extend
    if len(args) <> 2:
        print "**GRAMMAR ERROR: expected 2 arguments for a", f.__name__
        print "Most likely you want to enter \"up<enter>l<enter>\" now to see what happened."
        raise Exception("Grammar Error")
    if isinstance(args[0], PythonTypes.IntType):
        pass
    else:
        print "\n","*"*72, "\n** GRAMMAR ERROR in argument args[0] = %s"%repr(args[0]),"\n", "*"*72
        print f.__name__+"():\n    \"\"\"%s\"\"\"\n" %f.__doc__.replace("\\n","\n").replace("\return","Returns").replace("\\c ","")
        print "\n  Most likely you now want to enter \"up<enter>l<enter>\"\n into the debugger to see what happened.\n"
        raise Exception("Grammar Error")
    if isinstance(args[1], tuple) and args[1][0] == str:
        pass
    elif isinstance(args[1], tuple) and args[1][0] == float:
        pass
    elif isinstance(args[1], tuple) and args[1][0] == double:
        pass
    elif isinstance(args[1], PythonTypes.IntType):
        pass
    elif args[1] == pure:
        pass
    elif args[1] == result:
        pass
    elif isinstance(args[1], tuple) and args[1][0] == complex:
        pass
    elif isinstance(args[1], tuple) and args[1][0] == bool:
        pass
    elif isinstance(args[1], tuple) and args[1][0] == new:
        pass
    elif isinstance(args[1], tuple) and args[1][0] == var_decl:
        pass
    elif isinstance(args[1], tuple) and args[1][0] == var_decl_init:
        pass
    elif isinstance(args[1], PythonTypes.StringType):
        pass
    elif isinstance(args[1], tuple) and args[1][0] == pointer_expr:
        pass
    elif isinstance(args[1], tuple) and args[1][0] == deref:
        pass
    elif isinstance(args[1], tuple) and args[1][0] == get_struct_item:
        pass
    elif isinstance(args[1], tuple) and args[1][0] == call:
        pass
    elif isinstance(args[1], tuple) and args[1][0] == cast:
        pass
    elif isinstance(args[1], tuple) and args[1][0] == set_struct_item:
        pass
    elif isinstance(args[1], tuple) and args[1][0] == assignment:
        pass
    elif isinstance(args[1], tuple) and args[1][0] == set_arg:
        pass
    elif isinstance(args[1], tuple) and args[1][0] == infix_expr:
        pass
    elif isinstance(args[1], tuple) and args[1][0] == prefix_expr:
        pass
    elif isinstance(args[1], tuple) and args[1][0] == sign_extend:
        pass
    else:
        print "\n","*"*72, "\n** GRAMMAR ERROR in argument args[1] = %s"%repr(args[1]),"\n", "*"*72
        print f.__name__+"():\n    \"\"\"%s\"\"\"\n" %f.__doc__.replace("\\n","\n").replace("\return","Returns").replace("\\c ","")
        print "\n  Most likely you now want to enter \"up<enter>l<enter>\"\n into the debugger to see what happened.\n"
        raise Exception("Grammar Error")
    return tuple(['sign_extend']+list(args))

def Var_decl(*args):
    """
    Construct a "var_decl" node. Valid arguments are 
    (\c Type(), \c Id())
    \return (\c "Var_decl", \c Type(), \c Id())
    """
    f = Var_decl
    if len(args) <> 2:
        print "**GRAMMAR ERROR: expected 2 arguments for a", f.__name__
        print "Most likely you want to enter \"up<enter>l<enter>\" now to see what happened."
        raise Exception("Grammar Error")
    if isinstance(args[0], tuple) and args[0][0] == primitive_type:
        pass
    elif isinstance(args[0], tuple) and args[0][0] == pointer_type:
        pass
    elif isinstance(args[0], tuple) and args[0][0] == typedef_type:
        pass
    elif isinstance(args[0], tuple) and args[0][0] == const:
        pass
    elif isinstance(args[0], tuple) and args[0][0] == struct:
        pass
    elif isinstance(args[0], tuple) and args[0][0] == enum:
        pass
    elif isinstance(args[0], tuple) and args[0][0] == rarray:
        pass
    else:
        print "\n","*"*72, "\n** GRAMMAR ERROR in argument args[0] = %s"%repr(args[0]),"\n", "*"*72
        print f.__name__+"():\n    \"\"\"%s\"\"\"\n" %f.__doc__.replace("\\n","\n").replace("\return","Returns").replace("\\c ","")
        print "\n  Most likely you now want to enter \"up<enter>l<enter>\"\n into the debugger to see what happened.\n"
        raise Exception("Grammar Error")
    if isinstance(args[1], PythonTypes.StringType):
        pass
    else:
        print "\n","*"*72, "\n** GRAMMAR ERROR in argument args[1] = %s"%repr(args[1]),"\n", "*"*72
        print f.__name__+"():\n    \"\"\"%s\"\"\"\n" %f.__doc__.replace("\\n","\n").replace("\return","Returns").replace("\\c ","")
        print "\n  Most likely you now want to enter \"up<enter>l<enter>\"\n into the debugger to see what happened.\n"
        raise Exception("Grammar Error")
    return tuple(['var_decl']+list(args))

def Var_decl_init(*args):
    """
    Construct a "var_decl_init" node. Valid arguments are 
    (\c Type(), \c Id(), \c Expr())
    \return (\c "Var_decl_init", \c Type(), \c Id(), \c Expr())
    """
    f = Var_decl_init
    if len(args) <> 3:
        print "**GRAMMAR ERROR: expected 3 arguments for a", f.__name__
        print "Most likely you want to enter \"up<enter>l<enter>\" now to see what happened."
        raise Exception("Grammar Error")
    if isinstance(args[0], tuple) and args[0][0] == primitive_type:
        pass
    elif isinstance(args[0], tuple) and args[0][0] == pointer_type:
        pass
    elif isinstance(args[0], tuple) and args[0][0] == typedef_type:
        pass
    elif isinstance(args[0], tuple) and args[0][0] == const:
        pass
    elif isinstance(args[0], tuple) and args[0][0] == struct:
        pass
    elif isinstance(args[0], tuple) and args[0][0] == enum:
        pass
    elif isinstance(args[0], tuple) and args[0][0] == rarray:
        pass
    else:
        print "\n","*"*72, "\n** GRAMMAR ERROR in argument args[0] = %s"%repr(args[0]),"\n", "*"*72
        print f.__name__+"():\n    \"\"\"%s\"\"\"\n" %f.__doc__.replace("\\n","\n").replace("\return","Returns").replace("\\c ","")
        print "\n  Most likely you now want to enter \"up<enter>l<enter>\"\n into the debugger to see what happened.\n"
        raise Exception("Grammar Error")
    if isinstance(args[1], PythonTypes.StringType):
        pass
    else:
        print "\n","*"*72, "\n** GRAMMAR ERROR in argument args[1] = %s"%repr(args[1]),"\n", "*"*72
        print f.__name__+"():\n    \"\"\"%s\"\"\"\n" %f.__doc__.replace("\\n","\n").replace("\return","Returns").replace("\\c ","")
        print "\n  Most likely you now want to enter \"up<enter>l<enter>\"\n into the debugger to see what happened.\n"
        raise Exception("Grammar Error")
    if isinstance(args[2], tuple) and args[2][0] == str:
        pass
    elif isinstance(args[2], tuple) and args[2][0] == float:
        pass
    elif isinstance(args[2], tuple) and args[2][0] == double:
        pass
    elif isinstance(args[2], PythonTypes.IntType):
        pass
    elif args[2] == pure:
        pass
    elif args[2] == result:
        pass
    elif isinstance(args[2], tuple) and args[2][0] == complex:
        pass
    elif isinstance(args[2], tuple) and args[2][0] == bool:
        pass
    elif isinstance(args[2], tuple) and args[2][0] == new:
        pass
    elif isinstance(args[2], tuple) and args[2][0] == var_decl:
        pass
    elif isinstance(args[2], tuple) and args[2][0] == var_decl_init:
        pass
    elif isinstance(args[2], PythonTypes.StringType):
        pass
    elif isinstance(args[2], tuple) and args[2][0] == pointer_expr:
        pass
    elif isinstance(args[2], tuple) and args[2][0] == deref:
        pass
    elif isinstance(args[2], tuple) and args[2][0] == get_struct_item:
        pass
    elif isinstance(args[2], tuple) and args[2][0] == call:
        pass
    elif isinstance(args[2], tuple) and args[2][0] == cast:
        pass
    elif isinstance(args[2], tuple) and args[2][0] == set_struct_item:
        pass
    elif isinstance(args[2], tuple) and args[2][0] == assignment:
        pass
    elif isinstance(args[2], tuple) and args[2][0] == set_arg:
        pass
    elif isinstance(args[2], tuple) and args[2][0] == infix_expr:
        pass
    elif isinstance(args[2], tuple) and args[2][0] == prefix_expr:
        pass
    elif isinstance(args[2], tuple) and args[2][0] == sign_extend:
        pass
    else:
        print "\n","*"*72, "\n** GRAMMAR ERROR in argument args[2] = %s"%repr(args[2]),"\n", "*"*72
        print f.__name__+"():\n    \"\"\"%s\"\"\"\n" %f.__doc__.replace("\\n","\n").replace("\return","Returns").replace("\\c ","")
        print "\n  Most likely you now want to enter \"up<enter>l<enter>\"\n into the debugger to see what happened.\n"
        raise Exception("Grammar Error")
    return tuple(['var_decl_init']+list(args))

def Enumerator(*args):
    """
    Construct a "enumerator" node. Valid arguments are 
    (\c Id())
    \return (\c "Enumerator", \c Id())
    """
    f = Enumerator
    if len(args) <> 1:
        print "**GRAMMAR ERROR: expected 1 arguments for a", f.__name__
        print "Most likely you want to enter \"up<enter>l<enter>\" now to see what happened."
        raise Exception("Grammar Error")
    if isinstance(args[0], PythonTypes.StringType):
        pass
    else:
        print "\n","*"*72, "\n** GRAMMAR ERROR in argument args[0] = %s"%repr(args[0]),"\n", "*"*72
        print f.__name__+"():\n    \"\"\"%s\"\"\"\n" %f.__doc__.replace("\\n","\n").replace("\return","Returns").replace("\\c ","")
        print "\n  Most likely you now want to enter \"up<enter>l<enter>\"\n into the debugger to see what happened.\n"
        raise Exception("Grammar Error")
    return tuple(['enumerator']+list(args))

def Enumerator_value(*args):
    """
    Construct a "enumerator_value" node. Valid arguments are 
    (\c Id(), INT())
    \return (\c "Enumerator_value", \c Id(), INT())
    """
    f = Enumerator_value
    if len(args) <> 2:
        print "**GRAMMAR ERROR: expected 2 arguments for a", f.__name__
        print "Most likely you want to enter \"up<enter>l<enter>\" now to see what happened."
        raise Exception("Grammar Error")
    if isinstance(args[0], PythonTypes.StringType):
        pass
    else:
        print "\n","*"*72, "\n** GRAMMAR ERROR in argument args[0] = %s"%repr(args[0]),"\n", "*"*72
        print f.__name__+"():\n    \"\"\"%s\"\"\"\n" %f.__doc__.replace("\\n","\n").replace("\return","Returns").replace("\\c ","")
        print "\n  Most likely you now want to enter \"up<enter>l<enter>\"\n into the debugger to see what happened.\n"
        raise Exception("Grammar Error")
    if isinstance(args[1], PythonTypes.IntType):
        pass
    else:
        print "\n","*"*72, "\n** GRAMMAR ERROR in argument args[1] = %s"%repr(args[1]),"\n", "*"*72
        print f.__name__+"():\n    \"\"\"%s\"\"\"\n" %f.__doc__.replace("\\n","\n").replace("\return","Returns").replace("\\c ","")
        print "\n  Most likely you now want to enter \"up<enter>l<enter>\"\n into the debugger to see what happened.\n"
        raise Exception("Grammar Error")
    return tuple(['enumerator_value']+list(args))

def Get_struct_item(*args):
    """
    Construct a "get_struct_item" node. Valid arguments are 
    (\c Struct(), \c Expr(), \c Struct_item())
    \return (\c "Get_struct_item", \c Struct(), \c Expr(), \c Struct_item())
    """
    f = Get_struct_item
    if len(args) <> 3:
        print "**GRAMMAR ERROR: expected 3 arguments for a", f.__name__
        print "Most likely you want to enter \"up<enter>l<enter>\" now to see what happened."
        raise Exception("Grammar Error")
    if isinstance(args[0], tuple) and args[0][0] == struct:
        pass
    else:
        print "\n","*"*72, "\n** GRAMMAR ERROR in argument args[0] = %s"%repr(args[0]),"\n", "*"*72
        print f.__name__+"():\n    \"\"\"%s\"\"\"\n" %f.__doc__.replace("\\n","\n").replace("\return","Returns").replace("\\c ","")
        print "\n  Most likely you now want to enter \"up<enter>l<enter>\"\n into the debugger to see what happened.\n"
        raise Exception("Grammar Error")
    if isinstance(args[1], tuple) and args[1][0] == str:
        pass
    elif isinstance(args[1], tuple) and args[1][0] == float:
        pass
    elif isinstance(args[1], tuple) and args[1][0] == double:
        pass
    elif isinstance(args[1], PythonTypes.IntType):
        pass
    elif args[1] == pure:
        pass
    elif args[1] == result:
        pass
    elif isinstance(args[1], tuple) and args[1][0] == complex:
        pass
    elif isinstance(args[1], tuple) and args[1][0] == bool:
        pass
    elif isinstance(args[1], tuple) and args[1][0] == new:
        pass
    elif isinstance(args[1], tuple) and args[1][0] == var_decl:
        pass
    elif isinstance(args[1], tuple) and args[1][0] == var_decl_init:
        pass
    elif isinstance(args[1], PythonTypes.StringType):
        pass
    elif isinstance(args[1], tuple) and args[1][0] == pointer_expr:
        pass
    elif isinstance(args[1], tuple) and args[1][0] == deref:
        pass
    elif isinstance(args[1], tuple) and args[1][0] == get_struct_item:
        pass
    elif isinstance(args[1], tuple) and args[1][0] == call:
        pass
    elif isinstance(args[1], tuple) and args[1][0] == cast:
        pass
    elif isinstance(args[1], tuple) and args[1][0] == set_struct_item:
        pass
    elif isinstance(args[1], tuple) and args[1][0] == assignment:
        pass
    elif isinstance(args[1], tuple) and args[1][0] == set_arg:
        pass
    elif isinstance(args[1], tuple) and args[1][0] == infix_expr:
        pass
    elif isinstance(args[1], tuple) and args[1][0] == prefix_expr:
        pass
    elif isinstance(args[1], tuple) and args[1][0] == sign_extend:
        pass
    else:
        print "\n","*"*72, "\n** GRAMMAR ERROR in argument args[1] = %s"%repr(args[1]),"\n", "*"*72
        print f.__name__+"():\n    \"\"\"%s\"\"\"\n" %f.__doc__.replace("\\n","\n").replace("\return","Returns").replace("\\c ","")
        print "\n  Most likely you now want to enter \"up<enter>l<enter>\"\n into the debugger to see what happened.\n"
        raise Exception("Grammar Error")
    if isinstance(args[2], tuple) and args[2][0] == struct_item:
        pass
    else:
        print "\n","*"*72, "\n** GRAMMAR ERROR in argument args[2] = %s"%repr(args[2]),"\n", "*"*72
        print f.__name__+"():\n    \"\"\"%s\"\"\"\n" %f.__doc__.replace("\\n","\n").replace("\return","Returns").replace("\\c ","")
        print "\n  Most likely you now want to enter \"up<enter>l<enter>\"\n into the debugger to see what happened.\n"
        raise Exception("Grammar Error")
    return tuple(['get_struct_item']+list(args))

def Call(*args):
    """
    Construct a "call" node. Valid arguments are 
    (\c Expr(), [\c Expr()])
    \return (\c "Call", \c Expr(), [\c Expr()])
    """
    f = Call
    if len(args) <> 2:
        print "**GRAMMAR ERROR: expected 2 arguments for a", f.__name__
        print "Most likely you want to enter \"up<enter>l<enter>\" now to see what happened."
        raise Exception("Grammar Error")
    if isinstance(args[0], tuple) and args[0][0] == str:
        pass
    elif isinstance(args[0], tuple) and args[0][0] == float:
        pass
    elif isinstance(args[0], tuple) and args[0][0] == double:
        pass
    elif isinstance(args[0], PythonTypes.IntType):
        pass
    elif args[0] == pure:
        pass
    elif args[0] == result:
        pass
    elif isinstance(args[0], tuple) and args[0][0] == complex:
        pass
    elif isinstance(args[0], tuple) and args[0][0] == bool:
        pass
    elif isinstance(args[0], tuple) and args[0][0] == new:
        pass
    elif isinstance(args[0], tuple) and args[0][0] == var_decl:
        pass
    elif isinstance(args[0], tuple) and args[0][0] == var_decl_init:
        pass
    elif isinstance(args[0], PythonTypes.StringType):
        pass
    elif isinstance(args[0], tuple) and args[0][0] == pointer_expr:
        pass
    elif isinstance(args[0], tuple) and args[0][0] == deref:
        pass
    elif isinstance(args[0], tuple) and args[0][0] == get_struct_item:
        pass
    elif isinstance(args[0], tuple) and args[0][0] == call:
        pass
    elif isinstance(args[0], tuple) and args[0][0] == cast:
        pass
    elif isinstance(args[0], tuple) and args[0][0] == set_struct_item:
        pass
    elif isinstance(args[0], tuple) and args[0][0] == assignment:
        pass
    elif isinstance(args[0], tuple) and args[0][0] == set_arg:
        pass
    elif isinstance(args[0], tuple) and args[0][0] == infix_expr:
        pass
    elif isinstance(args[0], tuple) and args[0][0] == prefix_expr:
        pass
    elif isinstance(args[0], tuple) and args[0][0] == sign_extend:
        pass
    else:
        print "\n","*"*72, "\n** GRAMMAR ERROR in argument args[0] = %s"%repr(args[0]),"\n", "*"*72
        print f.__name__+"():\n    \"\"\"%s\"\"\"\n" %f.__doc__.replace("\\n","\n").replace("\return","Returns").replace("\\c ","")
        print "\n  Most likely you now want to enter \"up<enter>l<enter>\"\n into the debugger to see what happened.\n"
        raise Exception("Grammar Error")
    if isinstance(args[1], list) or isinstance(args[1], tuple):
        for a in args[1]:
            if isinstance(a, tuple) and a[0] == str:
                pass
            elif isinstance(a, tuple) and a[0] == float:
                pass
            elif isinstance(a, tuple) and a[0] == double:
                pass
            elif isinstance(a, PythonTypes.IntType):
                pass
            elif a == pure:
                pass
            elif a == result:
                pass
            elif isinstance(a, tuple) and a[0] == complex:
                pass
            elif isinstance(a, tuple) and a[0] == bool:
                pass
            elif isinstance(a, tuple) and a[0] == new:
                pass
            elif isinstance(a, tuple) and a[0] == var_decl:
                pass
            elif isinstance(a, tuple) and a[0] == var_decl_init:
                pass
            elif isinstance(a, PythonTypes.StringType):
                pass
            elif isinstance(a, tuple) and a[0] == pointer_expr:
                pass
            elif isinstance(a, tuple) and a[0] == deref:
                pass
            elif isinstance(a, tuple) and a[0] == get_struct_item:
                pass
            elif isinstance(a, tuple) and a[0] == call:
                pass
            elif isinstance(a, tuple) and a[0] == cast:
                pass
            elif isinstance(a, tuple) and a[0] == set_struct_item:
                pass
            elif isinstance(a, tuple) and a[0] == assignment:
                pass
            elif isinstance(a, tuple) and a[0] == set_arg:
                pass
            elif isinstance(a, tuple) and a[0] == infix_expr:
                pass
            elif isinstance(a, tuple) and a[0] == prefix_expr:
                pass
            elif isinstance(a, tuple) and a[0] == sign_extend:
                pass
            else:
                print "\n","*"*72, "\n** GRAMMAR ERROR in argument a = %s"%repr(a),"\n", "*"*72
                print f.__name__+"():\n    \"\"\"%s\"\"\"\n" %f.__doc__.replace("\\n","\n").replace("\return","Returns").replace("\\c ","")
                print "\n  Most likely you now want to enter \"up<enter>l<enter>\"\n into the debugger to see what happened.\n"
                raise Exception("Grammar Error")
    else:
        print "\n","*"*72, "\n** GRAMMAR ERROR in argument args[1] = %s"%repr(args[1]),"\n", "*"*72
        print f.__name__+"():\n    \"\"\"%s\"\"\"\n" %f.__doc__.replace("\\n","\n").replace("\return","Returns").replace("\\c ","")
        print "\n  Most likely you now want to enter \"up<enter>l<enter>\"\n into the debugger to see what happened.\n"
        raise Exception("Grammar Error")
    return tuple(['call']+list(args))

def Typedef_type(*args):
    """
    Construct a "typedef_type" node. Valid arguments are 
    (\c Id())
    \return (\c "Typedef_type", \c Id())
    """
    f = Typedef_type
    if len(args) <> 1:
        print "**GRAMMAR ERROR: expected 1 arguments for a", f.__name__
        print "Most likely you want to enter \"up<enter>l<enter>\" now to see what happened."
        raise Exception("Grammar Error")
    if isinstance(args[0], PythonTypes.StringType):
        pass
    else:
        print "\n","*"*72, "\n** GRAMMAR ERROR in argument args[0] = %s"%repr(args[0]),"\n", "*"*72
        print f.__name__+"():\n    \"\"\"%s\"\"\"\n" %f.__doc__.replace("\\n","\n").replace("\return","Returns").replace("\\c ","")
        print "\n  Most likely you now want to enter \"up<enter>l<enter>\"\n into the debugger to see what happened.\n"
        raise Exception("Grammar Error")
    return tuple(['typedef_type']+list(args))

def Const(*args):
    """
    Construct a "const" node. Valid arguments are 
    (\c Type())
    \return (\c "Const", \c Type())
    """
    f = Const
    if len(args) <> 1:
        print "**GRAMMAR ERROR: expected 1 arguments for a", f.__name__
        print "Most likely you want to enter \"up<enter>l<enter>\" now to see what happened."
        raise Exception("Grammar Error")
    if isinstance(args[0], tuple) and args[0][0] == primitive_type:
        pass
    elif isinstance(args[0], tuple) and args[0][0] == pointer_type:
        pass
    elif isinstance(args[0], tuple) and args[0][0] == typedef_type:
        pass
    elif isinstance(args[0], tuple) and args[0][0] == const:
        pass
    elif isinstance(args[0], tuple) and args[0][0] == struct:
        pass
    elif isinstance(args[0], tuple) and args[0][0] == enum:
        pass
    elif isinstance(args[0], tuple) and args[0][0] == rarray:
        pass
    else:
        print "\n","*"*72, "\n** GRAMMAR ERROR in argument args[0] = %s"%repr(args[0]),"\n", "*"*72
        print f.__name__+"():\n    \"\"\"%s\"\"\"\n" %f.__doc__.replace("\\n","\n").replace("\return","Returns").replace("\\c ","")
        print "\n  Most likely you now want to enter \"up<enter>l<enter>\"\n into the debugger to see what happened.\n"
        raise Exception("Grammar Error")
    return tuple(['const']+list(args))

def Simple_int_infix_expr(*args):
    """
    Construct a "simple_int_infix_expr" node. Valid arguments are 
    (\c Bin_op(), \c SimpleIntExpr(), \c SimpleIntExpr())
    \return (\c "Simple_int_infix_expr", \c Bin_op(), \c SimpleIntExpr(), \c SimpleIntExpr())
    """
    f = Simple_int_infix_expr
    if len(args) <> 3:
        print "**GRAMMAR ERROR: expected 3 arguments for a", f.__name__
        print "Most likely you want to enter \"up<enter>l<enter>\" now to see what happened."
        raise Exception("Grammar Error")
    if args[0] == log_or:
        pass
    elif args[0] == log_and:
        pass
    elif args[0] == eq:
        pass
    elif args[0] == ne:
        pass
    elif args[0] == bit_or:
        pass
    elif args[0] == bit_and:
        pass
    elif args[0] == bit_xor:
        pass
    elif args[0] == lt:
        pass
    elif args[0] == gt:
        pass
    elif args[0] == le:
        pass
    elif args[0] == ge:
        pass
    elif args[0] == lshift:
        pass
    elif args[0] == rshift:
        pass
    elif args[0] == plus:
        pass
    elif args[0] == minus:
        pass
    elif args[0] == times:
        pass
    elif args[0] == divide:
        pass
    elif args[0] == modulo:
        pass
    elif args[0] == pow:
        pass
    else:
        print "\n","*"*72, "\n** GRAMMAR ERROR in argument args[0] = %s"%repr(args[0]),"\n", "*"*72
        print f.__name__+"():\n    \"\"\"%s\"\"\"\n" %f.__doc__.replace("\\n","\n").replace("\return","Returns").replace("\\c ","")
        print "\n  Most likely you now want to enter \"up<enter>l<enter>\"\n into the debugger to see what happened.\n"
        raise Exception("Grammar Error")
    if isinstance(args[1], tuple) and args[1][0] == simple_int_infix_expr:
        pass
    elif isinstance(args[1], tuple) and args[1][0] == simple_int_prefix_expr:
        pass
    elif isinstance(args[1], tuple) and args[1][0] == simple_int_fn_eval:
        pass
    elif isinstance(args[1], tuple) and args[1][0] == var_ref:
        pass
    elif isinstance(args[1], PythonTypes.IntType):
        pass
    else:
        print "\n","*"*72, "\n** GRAMMAR ERROR in argument args[1] = %s"%repr(args[1]),"\n", "*"*72
        print f.__name__+"():\n    \"\"\"%s\"\"\"\n" %f.__doc__.replace("\\n","\n").replace("\return","Returns").replace("\\c ","")
        print "\n  Most likely you now want to enter \"up<enter>l<enter>\"\n into the debugger to see what happened.\n"
        raise Exception("Grammar Error")
    if isinstance(args[2], tuple) and args[2][0] == simple_int_infix_expr:
        pass
    elif isinstance(args[2], tuple) and args[2][0] == simple_int_prefix_expr:
        pass
    elif isinstance(args[2], tuple) and args[2][0] == simple_int_fn_eval:
        pass
    elif isinstance(args[2], tuple) and args[2][0] == var_ref:
        pass
    elif isinstance(args[2], PythonTypes.IntType):
        pass
    else:
        print "\n","*"*72, "\n** GRAMMAR ERROR in argument args[2] = %s"%repr(args[2]),"\n", "*"*72
        print f.__name__+"():\n    \"\"\"%s\"\"\"\n" %f.__doc__.replace("\\n","\n").replace("\return","Returns").replace("\\c ","")
        print "\n  Most likely you now want to enter \"up<enter>l<enter>\"\n into the debugger to see what happened.\n"
        raise Exception("Grammar Error")
    return tuple(['simple_int_infix_expr']+list(args))

def Simple_int_prefix_expr(*args):
    """
    Construct a "simple_int_prefix_expr" node. Valid arguments are 
    (\c Un_op(), \c SimpleIntExpr())
    \return (\c "Simple_int_prefix_expr", \c Un_op(), \c SimpleIntExpr())
    """
    f = Simple_int_prefix_expr
    if len(args) <> 2:
        print "**GRAMMAR ERROR: expected 2 arguments for a", f.__name__
        print "Most likely you want to enter \"up<enter>l<enter>\" now to see what happened."
        raise Exception("Grammar Error")
    if args[0] == is_:
        pass
    elif args[0] == log_not:
        pass
    elif args[0] == bit_not:
        pass
    else:
        print "\n","*"*72, "\n** GRAMMAR ERROR in argument args[0] = %s"%repr(args[0]),"\n", "*"*72
        print f.__name__+"():\n    \"\"\"%s\"\"\"\n" %f.__doc__.replace("\\n","\n").replace("\return","Returns").replace("\\c ","")
        print "\n  Most likely you now want to enter \"up<enter>l<enter>\"\n into the debugger to see what happened.\n"
        raise Exception("Grammar Error")
    if isinstance(args[1], tuple) and args[1][0] == simple_int_infix_expr:
        pass
    elif isinstance(args[1], tuple) and args[1][0] == simple_int_prefix_expr:
        pass
    elif isinstance(args[1], tuple) and args[1][0] == simple_int_fn_eval:
        pass
    elif isinstance(args[1], tuple) and args[1][0] == var_ref:
        pass
    elif isinstance(args[1], PythonTypes.IntType):
        pass
    else:
        print "\n","*"*72, "\n** GRAMMAR ERROR in argument args[1] = %s"%repr(args[1]),"\n", "*"*72
        print f.__name__+"():\n    \"\"\"%s\"\"\"\n" %f.__doc__.replace("\\n","\n").replace("\return","Returns").replace("\\c ","")
        print "\n  Most likely you now want to enter \"up<enter>l<enter>\"\n into the debugger to see what happened.\n"
        raise Exception("Grammar Error")
    return tuple(['simple_int_prefix_expr']+list(args))

def Simple_int_fn_eval(*args):
    """
    Construct a "simple_int_fn_eval" node. Valid arguments are 
    (\c Id(), [\c SimpleIntExpr()])
    \return (\c "Simple_int_fn_eval", \c Id(), [\c SimpleIntExpr()])
    """
    f = Simple_int_fn_eval
    if len(args) <> 2:
        print "**GRAMMAR ERROR: expected 2 arguments for a", f.__name__
        print "Most likely you want to enter \"up<enter>l<enter>\" now to see what happened."
        raise Exception("Grammar Error")
    if isinstance(args[0], PythonTypes.StringType):
        pass
    else:
        print "\n","*"*72, "\n** GRAMMAR ERROR in argument args[0] = %s"%repr(args[0]),"\n", "*"*72
        print f.__name__+"():\n    \"\"\"%s\"\"\"\n" %f.__doc__.replace("\\n","\n").replace("\return","Returns").replace("\\c ","")
        print "\n  Most likely you now want to enter \"up<enter>l<enter>\"\n into the debugger to see what happened.\n"
        raise Exception("Grammar Error")
    if isinstance(args[1], list) or isinstance(args[1], tuple):
        for a in args[1]:
            if isinstance(a, tuple) and a[0] == simple_int_infix_expr:
                pass
            elif isinstance(a, tuple) and a[0] == simple_int_prefix_expr:
                pass
            elif isinstance(a, tuple) and a[0] == simple_int_fn_eval:
                pass
            elif isinstance(a, tuple) and a[0] == var_ref:
                pass
            elif isinstance(a, PythonTypes.IntType):
                pass
            else:
                print "\n","*"*72, "\n** GRAMMAR ERROR in argument a = %s"%repr(a),"\n", "*"*72
                print f.__name__+"():\n    \"\"\"%s\"\"\"\n" %f.__doc__.replace("\\n","\n").replace("\return","Returns").replace("\\c ","")
                print "\n  Most likely you now want to enter \"up<enter>l<enter>\"\n into the debugger to see what happened.\n"
                raise Exception("Grammar Error")
    else:
        print "\n","*"*72, "\n** GRAMMAR ERROR in argument args[1] = %s"%repr(args[1]),"\n", "*"*72
        print f.__name__+"():\n    \"\"\"%s\"\"\"\n" %f.__doc__.replace("\\n","\n").replace("\return","Returns").replace("\\c ","")
        print "\n  Most likely you now want to enter \"up<enter>l<enter>\"\n into the debugger to see what happened.\n"
        raise Exception("Grammar Error")
    return tuple(['simple_int_fn_eval']+list(args))

def Var_ref(*args):
    """
    Construct a "var_ref" node. Valid arguments are 
    (\c Id())
    \return (\c "Var_ref", \c Id())
    """
    f = Var_ref
    if len(args) <> 1:
        print "**GRAMMAR ERROR: expected 1 arguments for a", f.__name__
        print "Most likely you want to enter \"up<enter>l<enter>\" now to see what happened."
        raise Exception("Grammar Error")
    if isinstance(args[0], PythonTypes.StringType):
        pass
    else:
        print "\n","*"*72, "\n** GRAMMAR ERROR in argument args[0] = %s"%repr(args[0]),"\n", "*"*72
        print f.__name__+"():\n    \"\"\"%s\"\"\"\n" %f.__doc__.replace("\\n","\n").replace("\return","Returns").replace("\\c ","")
        print "\n  Most likely you now want to enter \"up<enter>l<enter>\"\n into the debugger to see what happened.\n"
        raise Exception("Grammar Error")
    return tuple(['var_ref']+list(args))



## Accessor functions

# skipping \c Type= (\c Primitive_type|\c Pointer_type|\c Typedef_type|\c Const|\c Struct|\c Enum|\c Rarray)
def import_id(arg):
    """
    Accessor function.
    \return the "id" member of a "import" node.
    """
    if not isinstance(arg, tuple):
        raise Exception("Grammar Error")
    elif arg[0] <> 'import':
        raise Exception("Grammar Error")
    else: return arg[1]


# skipping \c Var_decl= (\c Var_decl|\c Var_decl_init)
def fn_defn_attrs(arg):
    """
    Accessor function.
    \return the "attrs" member of a "fn_defn" node.
    """
    if not isinstance(arg, tuple):
        raise Exception("Grammar Error")
    elif arg[0] <> 'fn_defn':
        raise Exception("Grammar Error")
    else: return arg[1]


def fn_defn_type(arg):
    """
    Accessor function.
    \return the "type" member of a "fn_defn" node.
    """
    if not isinstance(arg, tuple):
        raise Exception("Grammar Error")
    elif arg[0] <> 'fn_defn':
        raise Exception("Grammar Error")
    else: return arg[2]


def fn_defn_id(arg):
    """
    Accessor function.
    \return the "id" member of a "fn_defn" node.
    """
    if not isinstance(arg, tuple):
        raise Exception("Grammar Error")
    elif arg[0] <> 'fn_defn':
        raise Exception("Grammar Error")
    else: return arg[3]


def fn_defn_args(arg):
    """
    Accessor function.
    \return the "args" member of a "fn_defn" node.
    """
    if not isinstance(arg, tuple):
        raise Exception("Grammar Error")
    elif arg[0] <> 'fn_defn':
        raise Exception("Grammar Error")
    else: return arg[4]


def fn_defn_stmts(arg):
    """
    Accessor function.
    \return the "stmts" member of a "fn_defn" node.
    """
    if not isinstance(arg, tuple):
        raise Exception("Grammar Error")
    elif arg[0] <> 'fn_defn':
        raise Exception("Grammar Error")
    else: return arg[5]


def fn_defn_docComment(arg):
    """
    Accessor function.
    \return the "docComment" member of a "fn_defn" node.
    """
    if not isinstance(arg, tuple):
        raise Exception("Grammar Error")
    elif arg[0] <> 'fn_defn':
        raise Exception("Grammar Error")
    else: return arg[6]


def fn_decl_attrs(arg):
    """
    Accessor function.
    \return the "attrs" member of a "fn_decl" node.
    """
    if not isinstance(arg, tuple):
        raise Exception("Grammar Error")
    elif arg[0] <> 'fn_decl':
        raise Exception("Grammar Error")
    else: return arg[1]


def fn_decl_type(arg):
    """
    Accessor function.
    \return the "type" member of a "fn_decl" node.
    """
    if not isinstance(arg, tuple):
        raise Exception("Grammar Error")
    elif arg[0] <> 'fn_decl':
        raise Exception("Grammar Error")
    else: return arg[2]


def fn_decl_id(arg):
    """
    Accessor function.
    \return the "id" member of a "fn_decl" node.
    """
    if not isinstance(arg, tuple):
        raise Exception("Grammar Error")
    elif arg[0] <> 'fn_decl':
        raise Exception("Grammar Error")
    else: return arg[3]


def fn_decl_args(arg):
    """
    Accessor function.
    \return the "args" member of a "fn_decl" node.
    """
    if not isinstance(arg, tuple):
        raise Exception("Grammar Error")
    elif arg[0] <> 'fn_decl':
        raise Exception("Grammar Error")
    else: return arg[4]


def fn_decl_docComment(arg):
    """
    Accessor function.
    \return the "docComment" member of a "fn_decl" node.
    """
    if not isinstance(arg, tuple):
        raise Exception("Grammar Error")
    elif arg[0] <> 'fn_decl':
        raise Exception("Grammar Error")
    else: return arg[5]


# skipping \c _File=[ (\c Fn_decl|\c Fn_defn|\c Var_decl|\c Import|\c Type_decl)]
# skipping \c Id=STR
def goto_expr(arg):
    """
    Accessor function.
    \return the "expr" member of a "goto" node.
    """
    if not isinstance(arg, tuple):
        raise Exception("Grammar Error")
    elif arg[0] <> 'goto':
        raise Exception("Grammar Error")
    else: return arg[1]


# skipping \c Expr= (\c Literal|\c New|\c Var_decl|\c VarRefExpr|\c Cast|\c Set_struct_item|\c Assignment|\c Set_arg|\c Infix_expr|\c Prefix_expr|\c Sign_extend)
def if_expr(arg):
    """
    Accessor function.
    \return the "expr" member of a "if" node.
    """
    if not isinstance(arg, tuple):
        raise Exception("Grammar Error")
    elif arg[0] <> 'if':
        raise Exception("Grammar Error")
    else: return arg[1]


def if_body(arg):
    """
    Accessor function.
    \return the "body" member of a "if" node.
    """
    if not isinstance(arg, tuple):
        raise Exception("Grammar Error")
    elif arg[0] <> 'if':
        raise Exception("Grammar Error")
    else: return arg[2]


def return_expr(arg):
    """
    Accessor function.
    \return the "expr" member of a "return" node.
    """
    if not isinstance(arg, tuple):
        raise Exception("Grammar Error")
    elif arg[0] <> 'return':
        raise Exception("Grammar Error")
    else: return arg[1]


def while_expr(arg):
    """
    Accessor function.
    \return the "expr" member of a "while" node.
    """
    if not isinstance(arg, tuple):
        raise Exception("Grammar Error")
    elif arg[0] <> 'while':
        raise Exception("Grammar Error")
    else: return arg[1]


def while_body(arg):
    """
    Accessor function.
    \return the "body" member of a "while" node.
    """
    if not isinstance(arg, tuple):
        raise Exception("Grammar Error")
    elif arg[0] <> 'while':
        raise Exception("Grammar Error")
    else: return arg[2]


def do_while_body(arg):
    """
    Accessor function.
    \return the "body" member of a "do_while" node.
    """
    if not isinstance(arg, tuple):
        raise Exception("Grammar Error")
    elif arg[0] <> 'do_while':
        raise Exception("Grammar Error")
    else: return arg[1]


def do_while_expr(arg):
    """
    Accessor function.
    \return the "expr" member of a "do_while" node.
    """
    if not isinstance(arg, tuple):
        raise Exception("Grammar Error")
    elif arg[0] <> 'do_while':
        raise Exception("Grammar Error")
    else: return arg[2]


def comment_STR(arg):
    """
    Accessor function.
    \return the "STR" member of a "comment" node.
    """
    if not isinstance(arg, tuple):
        raise Exception("Grammar Error")
    elif arg[0] <> 'comment':
        raise Exception("Grammar Error")
    else: return arg[1]


# skipping \c Stmt= (\c Stmt|\c Comment)
# skipping \c Body=[\c Stmt]
def arg_attrs(arg):
    """
    Accessor function.
    \return the "attrs" member of a "arg" node.
    """
    if not isinstance(arg, tuple):
        raise Exception("Grammar Error")
    elif arg[0] <> 'arg':
        raise Exception("Grammar Error")
    else: return arg[1]


def arg_mode(arg):
    """
    Accessor function.
    \return the "mode" member of a "arg" node.
    """
    if not isinstance(arg, tuple):
        raise Exception("Grammar Error")
    elif arg[0] <> 'arg':
        raise Exception("Grammar Error")
    else: return arg[2]


def arg_type(arg):
    """
    Accessor function.
    \return the "type" member of a "arg" node.
    """
    if not isinstance(arg, tuple):
        raise Exception("Grammar Error")
    elif arg[0] <> 'arg':
        raise Exception("Grammar Error")
    else: return arg[3]


def arg_id(arg):
    """
    Accessor function.
    \return the "id" member of a "arg" node.
    """
    if not isinstance(arg, tuple):
        raise Exception("Grammar Error")
    elif arg[0] <> 'arg':
        raise Exception("Grammar Error")
    else: return arg[4]


def struct_scoped_id(arg):
    """
    Accessor function.
    \return the "scoped_id" member of a "struct" node.
    """
    if not isinstance(arg, tuple):
        raise Exception("Grammar Error")
    elif arg[0] <> 'struct':
        raise Exception("Grammar Error")
    else: return arg[1]


def struct_id(arg):
    """
    Accessor function.
    \return the "id" member of a "struct" node.
    """
    if not isinstance(arg, tuple):
        raise Exception("Grammar Error")
    elif arg[0] <> 'struct':
        raise Exception("Grammar Error")
    else: return arg[1]


def struct_struct_items(arg):
    """
    Accessor function.
    \return the "struct_items" member of a "struct" node.
    """
    if not isinstance(arg, tuple):
        raise Exception("Grammar Error")
    elif arg[0] <> 'struct':
        raise Exception("Grammar Error")
    else: return arg[2]


def struct_docComment(arg):
    """
    Accessor function.
    \return the "docComment" member of a "struct" node.
    """
    if not isinstance(arg, tuple):
        raise Exception("Grammar Error")
    elif arg[0] <> 'struct':
        raise Exception("Grammar Error")
    else: return arg[3]


def struct_item_type(arg):
    """
    Accessor function.
    \return the "type" member of a "struct_item" node.
    """
    if not isinstance(arg, tuple):
        raise Exception("Grammar Error")
    elif arg[0] <> 'struct_item':
        raise Exception("Grammar Error")
    else: return arg[1]


def struct_item_id(arg):
    """
    Accessor function.
    \return the "id" member of a "struct_item" node.
    """
    if not isinstance(arg, tuple):
        raise Exception("Grammar Error")
    elif arg[0] <> 'struct_item':
        raise Exception("Grammar Error")
    else: return arg[2]


# skipping \c VarRefExpr= (\c Id|\c Pointer_expr|\c Deref|\c Get_struct_item|\c Call)
# skipping \c Bin_op= (log_or|log_and|eq|ne|bit_or|bit_and|bit_xor|lt|gt|le|ge|lshift|rshift|plus|minus|times|divide|modulo|pow)
# skipping \c Un_op= (is|log_not|bit_not)
# skipping \c Bits=INT
# skipping \c Literal= (\c StringLiteral|\c FloatLiteral|\c DoubleLiteral|INT|pure|result|\c Complex|\c Bool)
def complex_FLOAT(arg):
    """
    Accessor function.
    \return the "FLOAT" member of a "complex" node.
    """
    if not isinstance(arg, tuple):
        raise Exception("Grammar Error")
    elif arg[0] <> 'complex':
        raise Exception("Grammar Error")
    else: return arg[1]


def complex_FLOAT(arg):
    """
    Accessor function.
    \return the "FLOAT" member of a "complex" node.
    """
    if not isinstance(arg, tuple):
        raise Exception("Grammar Error")
    elif arg[0] <> 'complex':
        raise Exception("Grammar Error")
    else: return arg[2]


def bool_true(arg):
    """
    Accessor function.
    \return the "true" member of a "bool" node.
    """
    if not isinstance(arg, tuple):
        raise Exception("Grammar Error")
    elif arg[0] <> 'bool':
        raise Exception("Grammar Error")
    else: return arg[1]


def bool_false(arg):
    """
    Accessor function.
    \return the "false" member of a "bool" node.
    """
    if not isinstance(arg, tuple):
        raise Exception("Grammar Error")
    elif arg[0] <> 'bool':
        raise Exception("Grammar Error")
    else: return arg[1]


def double_FLOAT(arg):
    """
    Accessor function.
    \return the "FLOAT" member of a "double" node.
    """
    if not isinstance(arg, tuple):
        raise Exception("Grammar Error")
    elif arg[0] <> 'double':
        raise Exception("Grammar Error")
    else: return arg[1]


def float_FLOAT(arg):
    """
    Accessor function.
    \return the "FLOAT" member of a "float" node.
    """
    if not isinstance(arg, tuple):
        raise Exception("Grammar Error")
    elif arg[0] <> 'float':
        raise Exception("Grammar Error")
    else: return arg[1]


def str_STR(arg):
    """
    Accessor function.
    \return the "STR" member of a "str" node.
    """
    if not isinstance(arg, tuple):
        raise Exception("Grammar Error")
    elif arg[0] <> 'str':
        raise Exception("Grammar Error")
    else: return arg[1]


def scoped_id_modules(arg):
    """
    Accessor function.
    \return the "modules" member of a "scoped_id" node.
    """
    if not isinstance(arg, tuple):
        raise Exception("Grammar Error")
    elif arg[0] <> 'scoped_id':
        raise Exception("Grammar Error")
    else: return arg[1]


def scoped_id_id(arg):
    """
    Accessor function.
    \return the "id" member of a "scoped_id" node.
    """
    if not isinstance(arg, tuple):
        raise Exception("Grammar Error")
    elif arg[0] <> 'scoped_id':
        raise Exception("Grammar Error")
    else: return arg[2]


def scoped_id_extension(arg):
    """
    Accessor function.
    \return the "extension" member of a "scoped_id" node.
    """
    if not isinstance(arg, tuple):
        raise Exception("Grammar Error")
    elif arg[0] <> 'scoped_id':
        raise Exception("Grammar Error")
    else: return arg[3]


# skipping \c DocComment=STR
# skipping \c Enumerator= (\c Enumerator|\c Enumerator_value)
def enum_id(arg):
    """
    Accessor function.
    \return the "id" member of a "enum" node.
    """
    if not isinstance(arg, tuple):
        raise Exception("Grammar Error")
    elif arg[0] <> 'enum':
        raise Exception("Grammar Error")
    else: return arg[1]


def enum_enumerators(arg):
    """
    Accessor function.
    \return the "enumerators" member of a "enum" node.
    """
    if not isinstance(arg, tuple):
        raise Exception("Grammar Error")
    elif arg[0] <> 'enum':
        raise Exception("Grammar Error")
    else: return arg[2]


def enum_docComment(arg):
    """
    Accessor function.
    \return the "docComment" member of a "enum" node.
    """
    if not isinstance(arg, tuple):
        raise Exception("Grammar Error")
    elif arg[0] <> 'enum':
        raise Exception("Grammar Error")
    else: return arg[3]


def deref_varRefExpr(arg):
    """
    Accessor function.
    \return the "varRefExpr" member of a "deref" node.
    """
    if not isinstance(arg, tuple):
        raise Exception("Grammar Error")
    elif arg[0] <> 'deref':
        raise Exception("Grammar Error")
    else: return arg[1]


def pointer_expr_varRefExpr(arg):
    """
    Accessor function.
    \return the "varRefExpr" member of a "pointer_expr" node.
    """
    if not isinstance(arg, tuple):
        raise Exception("Grammar Error")
    elif arg[0] <> 'pointer_expr':
        raise Exception("Grammar Error")
    else: return arg[1]


# skipping \c Attr= (static|pure|hooks)
# skipping \c Mode= (in|out|inout)
def rarray_primitive_type(arg):
    """
    Accessor function.
    \return the "primitive_type" member of a "rarray" node.
    """
    if not isinstance(arg, tuple):
        raise Exception("Grammar Error")
    elif arg[0] <> 'rarray':
        raise Exception("Grammar Error")
    else: return arg[1]


def rarray_dimension(arg):
    """
    Accessor function.
    \return the "dimension" member of a "rarray" node.
    """
    if not isinstance(arg, tuple):
        raise Exception("Grammar Error")
    elif arg[0] <> 'rarray':
        raise Exception("Grammar Error")
    else: return arg[2]


def rarray_extents(arg):
    """
    Accessor function.
    \return the "extents" member of a "rarray" node.
    """
    if not isinstance(arg, tuple):
        raise Exception("Grammar Error")
    elif arg[0] <> 'rarray':
        raise Exception("Grammar Error")
    else: return arg[3]


def pointer_type_type(arg):
    """
    Accessor function.
    \return the "type" member of a "pointer_type" node.
    """
    if not isinstance(arg, tuple):
        raise Exception("Grammar Error")
    elif arg[0] <> 'pointer_type':
        raise Exception("Grammar Error")
    else: return arg[1]


def pointer_type_fn_decl(arg):
    """
    Accessor function.
    \return the "fn_decl" member of a "pointer_type" node.
    """
    if not isinstance(arg, tuple):
        raise Exception("Grammar Error")
    elif arg[0] <> 'pointer_type':
        raise Exception("Grammar Error")
    else: return arg[1]


def primitive_type_bool(arg):
    """
    Accessor function.
    \return the "bool" member of a "primitive_type" node.
    """
    if not isinstance(arg, tuple):
        raise Exception("Grammar Error")
    elif arg[0] <> 'primitive_type':
        raise Exception("Grammar Error")
    else: return arg[1]


def primitive_type_char(arg):
    """
    Accessor function.
    \return the "char" member of a "primitive_type" node.
    """
    if not isinstance(arg, tuple):
        raise Exception("Grammar Error")
    elif arg[0] <> 'primitive_type':
        raise Exception("Grammar Error")
    else: return arg[1]


def primitive_type_int(arg):
    """
    Accessor function.
    \return the "int" member of a "primitive_type" node.
    """
    if not isinstance(arg, tuple):
        raise Exception("Grammar Error")
    elif arg[0] <> 'primitive_type':
        raise Exception("Grammar Error")
    else: return arg[1]


def primitive_type_long(arg):
    """
    Accessor function.
    \return the "long" member of a "primitive_type" node.
    """
    if not isinstance(arg, tuple):
        raise Exception("Grammar Error")
    elif arg[0] <> 'primitive_type':
        raise Exception("Grammar Error")
    else: return arg[1]


def primitive_type_long_long(arg):
    """
    Accessor function.
    \return the "long_long" member of a "primitive_type" node.
    """
    if not isinstance(arg, tuple):
        raise Exception("Grammar Error")
    elif arg[0] <> 'primitive_type':
        raise Exception("Grammar Error")
    else: return arg[1]


def primitive_type_float(arg):
    """
    Accessor function.
    \return the "float" member of a "primitive_type" node.
    """
    if not isinstance(arg, tuple):
        raise Exception("Grammar Error")
    elif arg[0] <> 'primitive_type':
        raise Exception("Grammar Error")
    else: return arg[1]


def primitive_type_double(arg):
    """
    Accessor function.
    \return the "double" member of a "primitive_type" node.
    """
    if not isinstance(arg, tuple):
        raise Exception("Grammar Error")
    elif arg[0] <> 'primitive_type':
        raise Exception("Grammar Error")
    else: return arg[1]


def primitive_type_long_double(arg):
    """
    Accessor function.
    \return the "long_double" member of a "primitive_type" node.
    """
    if not isinstance(arg, tuple):
        raise Exception("Grammar Error")
    elif arg[0] <> 'primitive_type':
        raise Exception("Grammar Error")
    else: return arg[1]


def primitive_type_fcomplex(arg):
    """
    Accessor function.
    \return the "fcomplex" member of a "primitive_type" node.
    """
    if not isinstance(arg, tuple):
        raise Exception("Grammar Error")
    elif arg[0] <> 'primitive_type':
        raise Exception("Grammar Error")
    else: return arg[1]


def primitive_type_dcomplex(arg):
    """
    Accessor function.
    \return the "dcomplex" member of a "primitive_type" node.
    """
    if not isinstance(arg, tuple):
        raise Exception("Grammar Error")
    elif arg[0] <> 'primitive_type':
        raise Exception("Grammar Error")
    else: return arg[1]


def primitive_type_string(arg):
    """
    Accessor function.
    \return the "string" member of a "primitive_type" node.
    """
    if not isinstance(arg, tuple):
        raise Exception("Grammar Error")
    elif arg[0] <> 'primitive_type':
        raise Exception("Grammar Error")
    else: return arg[1]


def primitive_type_void(arg):
    """
    Accessor function.
    \return the "void" member of a "primitive_type" node.
    """
    if not isinstance(arg, tuple):
        raise Exception("Grammar Error")
    elif arg[0] <> 'primitive_type':
        raise Exception("Grammar Error")
    else: return arg[1]


# skipping \c Extents= \c SimpleIntExpr
# skipping \c Dimension=INT
# skipping \c SimpleIntExpr= (\c Simple_int_infix_expr|\c Simple_int_prefix_expr|\c Simple_int_fn_eval|\c Var_ref|INT)
# skipping \c Module=STR
# skipping \c Extension=STR
def type_decl_type(arg):
    """
    Accessor function.
    \return the "type" member of a "type_decl" node.
    """
    if not isinstance(arg, tuple):
        raise Exception("Grammar Error")
    elif arg[0] <> 'type_decl':
        raise Exception("Grammar Error")
    else: return arg[1]


def stmt_do_while(arg):
    """
    Accessor function.
    \return the "do_while" member of a "stmt" node.
    """
    if not isinstance(arg, tuple):
        raise Exception("Grammar Error")
    elif arg[0] <> 'stmt':
        raise Exception("Grammar Error")
    else: return arg[1]


def stmt_while_(arg):
    """
    Accessor function.
    \return the "while_" member of a "stmt" node.
    """
    if not isinstance(arg, tuple):
        raise Exception("Grammar Error")
    elif arg[0] <> 'stmt':
        raise Exception("Grammar Error")
    else: return arg[1]


def stmt_break(arg):
    """
    Accessor function.
    \return the "break" member of a "stmt" node.
    """
    if not isinstance(arg, tuple):
        raise Exception("Grammar Error")
    elif arg[0] <> 'stmt':
        raise Exception("Grammar Error")
    else: return arg[1]


def stmt_return_(arg):
    """
    Accessor function.
    \return the "return_" member of a "stmt" node.
    """
    if not isinstance(arg, tuple):
        raise Exception("Grammar Error")
    elif arg[0] <> 'stmt':
        raise Exception("Grammar Error")
    else: return arg[1]


def stmt_if_(arg):
    """
    Accessor function.
    \return the "if_" member of a "stmt" node.
    """
    if not isinstance(arg, tuple):
        raise Exception("Grammar Error")
    elif arg[0] <> 'stmt':
        raise Exception("Grammar Error")
    else: return arg[1]


def stmt_goto(arg):
    """
    Accessor function.
    \return the "goto" member of a "stmt" node.
    """
    if not isinstance(arg, tuple):
        raise Exception("Grammar Error")
    elif arg[0] <> 'stmt':
        raise Exception("Grammar Error")
    else: return arg[1]


def stmt_expr(arg):
    """
    Accessor function.
    \return the "expr" member of a "stmt" node.
    """
    if not isinstance(arg, tuple):
        raise Exception("Grammar Error")
    elif arg[0] <> 'stmt':
        raise Exception("Grammar Error")
    else: return arg[1]


def new_type(arg):
    """
    Accessor function.
    \return the "type" member of a "new" node.
    """
    if not isinstance(arg, tuple):
        raise Exception("Grammar Error")
    elif arg[0] <> 'new':
        raise Exception("Grammar Error")
    else: return arg[1]


def new_args(arg):
    """
    Accessor function.
    \return the "args" member of a "new" node.
    """
    if not isinstance(arg, tuple):
        raise Exception("Grammar Error")
    elif arg[0] <> 'new':
        raise Exception("Grammar Error")
    else: return arg[2]


def cast_type(arg):
    """
    Accessor function.
    \return the "type" member of a "cast" node.
    """
    if not isinstance(arg, tuple):
        raise Exception("Grammar Error")
    elif arg[0] <> 'cast':
        raise Exception("Grammar Error")
    else: return arg[1]


def cast_expr(arg):
    """
    Accessor function.
    \return the "expr" member of a "cast" node.
    """
    if not isinstance(arg, tuple):
        raise Exception("Grammar Error")
    elif arg[0] <> 'cast':
        raise Exception("Grammar Error")
    else: return arg[2]


def set_struct_item_struct(arg):
    """
    Accessor function.
    \return the "struct" member of a "set_struct_item" node.
    """
    if not isinstance(arg, tuple):
        raise Exception("Grammar Error")
    elif arg[0] <> 'set_struct_item':
        raise Exception("Grammar Error")
    else: return arg[1]


def set_struct_item_expr(arg):
    """
    Accessor function.
    \return the "expr" member of a "set_struct_item" node.
    """
    if not isinstance(arg, tuple):
        raise Exception("Grammar Error")
    elif arg[0] <> 'set_struct_item':
        raise Exception("Grammar Error")
    else: return arg[2]


def set_struct_item_struct_item(arg):
    """
    Accessor function.
    \return the "struct_item" member of a "set_struct_item" node.
    """
    if not isinstance(arg, tuple):
        raise Exception("Grammar Error")
    elif arg[0] <> 'set_struct_item':
        raise Exception("Grammar Error")
    else: return arg[3]


def set_struct_item_expr(arg):
    """
    Accessor function.
    \return the "expr" member of a "set_struct_item" node.
    """
    if not isinstance(arg, tuple):
        raise Exception("Grammar Error")
    elif arg[0] <> 'set_struct_item':
        raise Exception("Grammar Error")
    else: return arg[4]


def assignment_varRefExpr(arg):
    """
    Accessor function.
    \return the "varRefExpr" member of a "assignment" node.
    """
    if not isinstance(arg, tuple):
        raise Exception("Grammar Error")
    elif arg[0] <> 'assignment':
        raise Exception("Grammar Error")
    else: return arg[1]


def assignment_expr(arg):
    """
    Accessor function.
    \return the "expr" member of a "assignment" node.
    """
    if not isinstance(arg, tuple):
        raise Exception("Grammar Error")
    elif arg[0] <> 'assignment':
        raise Exception("Grammar Error")
    else: return arg[2]


def set_arg_varRefExpr(arg):
    """
    Accessor function.
    \return the "varRefExpr" member of a "set_arg" node.
    """
    if not isinstance(arg, tuple):
        raise Exception("Grammar Error")
    elif arg[0] <> 'set_arg':
        raise Exception("Grammar Error")
    else: return arg[1]


def set_arg_expr(arg):
    """
    Accessor function.
    \return the "expr" member of a "set_arg" node.
    """
    if not isinstance(arg, tuple):
        raise Exception("Grammar Error")
    elif arg[0] <> 'set_arg':
        raise Exception("Grammar Error")
    else: return arg[2]


def infix_expr_bin_op(arg):
    """
    Accessor function.
    \return the "bin_op" member of a "infix_expr" node.
    """
    if not isinstance(arg, tuple):
        raise Exception("Grammar Error")
    elif arg[0] <> 'infix_expr':
        raise Exception("Grammar Error")
    else: return arg[1]


def infix_expr_expr(arg):
    """
    Accessor function.
    \return the "expr" member of a "infix_expr" node.
    """
    if not isinstance(arg, tuple):
        raise Exception("Grammar Error")
    elif arg[0] <> 'infix_expr':
        raise Exception("Grammar Error")
    else: return arg[2]


def infix_expr_expr(arg):
    """
    Accessor function.
    \return the "expr" member of a "infix_expr" node.
    """
    if not isinstance(arg, tuple):
        raise Exception("Grammar Error")
    elif arg[0] <> 'infix_expr':
        raise Exception("Grammar Error")
    else: return arg[3]


def prefix_expr_un_op(arg):
    """
    Accessor function.
    \return the "un_op" member of a "prefix_expr" node.
    """
    if not isinstance(arg, tuple):
        raise Exception("Grammar Error")
    elif arg[0] <> 'prefix_expr':
        raise Exception("Grammar Error")
    else: return arg[1]


def prefix_expr_expr(arg):
    """
    Accessor function.
    \return the "expr" member of a "prefix_expr" node.
    """
    if not isinstance(arg, tuple):
        raise Exception("Grammar Error")
    elif arg[0] <> 'prefix_expr':
        raise Exception("Grammar Error")
    else: return arg[2]


def sign_extend_bits(arg):
    """
    Accessor function.
    \return the "bits" member of a "sign_extend" node.
    """
    if not isinstance(arg, tuple):
        raise Exception("Grammar Error")
    elif arg[0] <> 'sign_extend':
        raise Exception("Grammar Error")
    else: return arg[1]


def sign_extend_expr(arg):
    """
    Accessor function.
    \return the "expr" member of a "sign_extend" node.
    """
    if not isinstance(arg, tuple):
        raise Exception("Grammar Error")
    elif arg[0] <> 'sign_extend':
        raise Exception("Grammar Error")
    else: return arg[2]


def var_decl_type(arg):
    """
    Accessor function.
    \return the "type" member of a "var_decl" node.
    """
    if not isinstance(arg, tuple):
        raise Exception("Grammar Error")
    elif arg[0] <> 'var_decl':
        raise Exception("Grammar Error")
    else: return arg[1]


def var_decl_id(arg):
    """
    Accessor function.
    \return the "id" member of a "var_decl" node.
    """
    if not isinstance(arg, tuple):
        raise Exception("Grammar Error")
    elif arg[0] <> 'var_decl':
        raise Exception("Grammar Error")
    else: return arg[2]


def var_decl_init_type(arg):
    """
    Accessor function.
    \return the "type" member of a "var_decl_init" node.
    """
    if not isinstance(arg, tuple):
        raise Exception("Grammar Error")
    elif arg[0] <> 'var_decl_init':
        raise Exception("Grammar Error")
    else: return arg[1]


def var_decl_init_id(arg):
    """
    Accessor function.
    \return the "id" member of a "var_decl_init" node.
    """
    if not isinstance(arg, tuple):
        raise Exception("Grammar Error")
    elif arg[0] <> 'var_decl_init':
        raise Exception("Grammar Error")
    else: return arg[2]


def var_decl_init_expr(arg):
    """
    Accessor function.
    \return the "expr" member of a "var_decl_init" node.
    """
    if not isinstance(arg, tuple):
        raise Exception("Grammar Error")
    elif arg[0] <> 'var_decl_init':
        raise Exception("Grammar Error")
    else: return arg[3]


def enumerator_id(arg):
    """
    Accessor function.
    \return the "id" member of a "enumerator" node.
    """
    if not isinstance(arg, tuple):
        raise Exception("Grammar Error")
    elif arg[0] <> 'enumerator':
        raise Exception("Grammar Error")
    else: return arg[1]


def enumerator_value_id(arg):
    """
    Accessor function.
    \return the "id" member of a "enumerator_value" node.
    """
    if not isinstance(arg, tuple):
        raise Exception("Grammar Error")
    elif arg[0] <> 'enumerator_value':
        raise Exception("Grammar Error")
    else: return arg[1]


def enumerator_value_INT(arg):
    """
    Accessor function.
    \return the "INT" member of a "enumerator_value" node.
    """
    if not isinstance(arg, tuple):
        raise Exception("Grammar Error")
    elif arg[0] <> 'enumerator_value':
        raise Exception("Grammar Error")
    else: return arg[2]


def get_struct_item_struct(arg):
    """
    Accessor function.
    \return the "struct" member of a "get_struct_item" node.
    """
    if not isinstance(arg, tuple):
        raise Exception("Grammar Error")
    elif arg[0] <> 'get_struct_item':
        raise Exception("Grammar Error")
    else: return arg[1]


def get_struct_item_expr(arg):
    """
    Accessor function.
    \return the "expr" member of a "get_struct_item" node.
    """
    if not isinstance(arg, tuple):
        raise Exception("Grammar Error")
    elif arg[0] <> 'get_struct_item':
        raise Exception("Grammar Error")
    else: return arg[2]


def get_struct_item_struct_item(arg):
    """
    Accessor function.
    \return the "struct_item" member of a "get_struct_item" node.
    """
    if not isinstance(arg, tuple):
        raise Exception("Grammar Error")
    elif arg[0] <> 'get_struct_item':
        raise Exception("Grammar Error")
    else: return arg[3]


def call_expr(arg):
    """
    Accessor function.
    \return the "expr" member of a "call" node.
    """
    if not isinstance(arg, tuple):
        raise Exception("Grammar Error")
    elif arg[0] <> 'call':
        raise Exception("Grammar Error")
    else: return arg[1]


def call_exprs(arg):
    """
    Accessor function.
    \return the "exprs" member of a "call" node.
    """
    if not isinstance(arg, tuple):
        raise Exception("Grammar Error")
    elif arg[0] <> 'call':
        raise Exception("Grammar Error")
    else: return arg[2]


def typedef_type_id(arg):
    """
    Accessor function.
    \return the "id" member of a "typedef_type" node.
    """
    if not isinstance(arg, tuple):
        raise Exception("Grammar Error")
    elif arg[0] <> 'typedef_type':
        raise Exception("Grammar Error")
    else: return arg[1]


def const_type(arg):
    """
    Accessor function.
    \return the "type" member of a "const" node.
    """
    if not isinstance(arg, tuple):
        raise Exception("Grammar Error")
    elif arg[0] <> 'const':
        raise Exception("Grammar Error")
    else: return arg[1]


def simple_int_infix_expr_bin_op(arg):
    """
    Accessor function.
    \return the "bin_op" member of a "simple_int_infix_expr" node.
    """
    if not isinstance(arg, tuple):
        raise Exception("Grammar Error")
    elif arg[0] <> 'simple_int_infix_expr':
        raise Exception("Grammar Error")
    else: return arg[1]


def simple_int_infix_expr_simpleIntExpr(arg):
    """
    Accessor function.
    \return the "simpleIntExpr" member of a "simple_int_infix_expr" node.
    """
    if not isinstance(arg, tuple):
        raise Exception("Grammar Error")
    elif arg[0] <> 'simple_int_infix_expr':
        raise Exception("Grammar Error")
    else: return arg[2]


def simple_int_infix_expr_simpleIntExpr(arg):
    """
    Accessor function.
    \return the "simpleIntExpr" member of a "simple_int_infix_expr" node.
    """
    if not isinstance(arg, tuple):
        raise Exception("Grammar Error")
    elif arg[0] <> 'simple_int_infix_expr':
        raise Exception("Grammar Error")
    else: return arg[3]


def simple_int_prefix_expr_un_op(arg):
    """
    Accessor function.
    \return the "un_op" member of a "simple_int_prefix_expr" node.
    """
    if not isinstance(arg, tuple):
        raise Exception("Grammar Error")
    elif arg[0] <> 'simple_int_prefix_expr':
        raise Exception("Grammar Error")
    else: return arg[1]


def simple_int_prefix_expr_simpleIntExpr(arg):
    """
    Accessor function.
    \return the "simpleIntExpr" member of a "simple_int_prefix_expr" node.
    """
    if not isinstance(arg, tuple):
        raise Exception("Grammar Error")
    elif arg[0] <> 'simple_int_prefix_expr':
        raise Exception("Grammar Error")
    else: return arg[2]


def simple_int_fn_eval_id(arg):
    """
    Accessor function.
    \return the "id" member of a "simple_int_fn_eval" node.
    """
    if not isinstance(arg, tuple):
        raise Exception("Grammar Error")
    elif arg[0] <> 'simple_int_fn_eval':
        raise Exception("Grammar Error")
    else: return arg[1]


def simple_int_fn_eval_simpleIntExprs(arg):
    """
    Accessor function.
    \return the "simpleIntExprs" member of a "simple_int_fn_eval" node.
    """
    if not isinstance(arg, tuple):
        raise Exception("Grammar Error")
    elif arg[0] <> 'simple_int_fn_eval':
        raise Exception("Grammar Error")
    else: return arg[2]


def var_ref_id(arg):
    """
    Accessor function.
    \return the "id" member of a "var_ref" node.
    """
    if not isinstance(arg, tuple):
        raise Exception("Grammar Error")
    elif arg[0] <> 'var_ref':
        raise Exception("Grammar Error")
    else: return arg[1]




## instance checks

# skipping \c Type= (\c Primitive_type|\c Pointer_type|\c Typedef_type|\c Const|\c Struct|\c Enum|\c Rarray)
def is_import(arg):
    """
    instanceof-like function.
    \return \c True if the argument is a "import" node.
    """
    if not isinstance(arg, tuple):
        return False
    return arg[0] == 'import'

# skipping \c Var_decl= (\c Var_decl|\c Var_decl_init)
def is_fn_defn(arg):
    """
    instanceof-like function.
    \return \c True if the argument is a "fn_defn" node.
    """
    if not isinstance(arg, tuple):
        return False
    return arg[0] == 'fn_defn'

def is_fn_decl(arg):
    """
    instanceof-like function.
    \return \c True if the argument is a "fn_decl" node.
    """
    if not isinstance(arg, tuple):
        return False
    return arg[0] == 'fn_decl'

# skipping \c _File=[ (\c Fn_decl|\c Fn_defn|\c Var_decl|\c Import|\c Type_decl)]
# skipping \c Id=STR
def is_goto(arg):
    """
    instanceof-like function.
    \return \c True if the argument is a "goto" node.
    """
    if not isinstance(arg, tuple):
        return False
    return arg[0] == 'goto'

# skipping \c Expr= (\c Literal|\c New|\c Var_decl|\c VarRefExpr|\c Cast|\c Set_struct_item|\c Assignment|\c Set_arg|\c Infix_expr|\c Prefix_expr|\c Sign_extend)
def is_if(arg):
    """
    instanceof-like function.
    \return \c True if the argument is a "if" node.
    """
    if not isinstance(arg, tuple):
        return False
    return arg[0] == 'if'

def is_return(arg):
    """
    instanceof-like function.
    \return \c True if the argument is a "return" node.
    """
    if not isinstance(arg, tuple):
        return False
    return arg[0] == 'return'

def is_while(arg):
    """
    instanceof-like function.
    \return \c True if the argument is a "while" node.
    """
    if not isinstance(arg, tuple):
        return False
    return arg[0] == 'while'

def is_do_while(arg):
    """
    instanceof-like function.
    \return \c True if the argument is a "do_while" node.
    """
    if not isinstance(arg, tuple):
        return False
    return arg[0] == 'do_while'

def is_comment(arg):
    """
    instanceof-like function.
    \return \c True if the argument is a "comment" node.
    """
    if not isinstance(arg, tuple):
        return False
    return arg[0] == 'comment'

# skipping \c Stmt= (\c Stmt|\c Comment)
# skipping \c Body=[\c Stmt]
def is_arg(arg):
    """
    instanceof-like function.
    \return \c True if the argument is a "arg" node.
    """
    if not isinstance(arg, tuple):
        return False
    return arg[0] == 'arg'

def is_struct(arg):
    """
    instanceof-like function.
    \return \c True if the argument is a "struct" node.
    """
    if not isinstance(arg, tuple):
        return False
    return arg[0] == 'struct'

def is_struct_item(arg):
    """
    instanceof-like function.
    \return \c True if the argument is a "struct_item" node.
    """
    if not isinstance(arg, tuple):
        return False
    return arg[0] == 'struct_item'

# skipping \c VarRefExpr= (\c Id|\c Pointer_expr|\c Deref|\c Get_struct_item|\c Call)
# skipping \c Bin_op= (log_or|log_and|eq|ne|bit_or|bit_and|bit_xor|lt|gt|le|ge|lshift|rshift|plus|minus|times|divide|modulo|pow)
# skipping \c Un_op= (is|log_not|bit_not)
# skipping \c Bits=INT
# skipping \c Literal= (\c StringLiteral|\c FloatLiteral|\c DoubleLiteral|INT|pure|result|\c Complex|\c Bool)
def is_complex(arg):
    """
    instanceof-like function.
    \return \c True if the argument is a "complex" node.
    """
    if not isinstance(arg, tuple):
        return False
    return arg[0] == 'complex'

def is_bool(arg):
    """
    instanceof-like function.
    \return \c True if the argument is a "bool" node.
    """
    if not isinstance(arg, tuple):
        return False
    return arg[0] == 'bool'

def is_double(arg):
    """
    instanceof-like function.
    \return \c True if the argument is a "double" node.
    """
    if not isinstance(arg, tuple):
        return False
    return arg[0] == 'double'

def is_float(arg):
    """
    instanceof-like function.
    \return \c True if the argument is a "float" node.
    """
    if not isinstance(arg, tuple):
        return False
    return arg[0] == 'float'

def is_str(arg):
    """
    instanceof-like function.
    \return \c True if the argument is a "str" node.
    """
    if not isinstance(arg, tuple):
        return False
    return arg[0] == 'str'

def is_scoped_id(arg):
    """
    instanceof-like function.
    \return \c True if the argument is a "scoped_id" node.
    """
    if not isinstance(arg, tuple):
        return False
    return arg[0] == 'scoped_id'

# skipping \c DocComment=STR
# skipping \c Enumerator= (\c Enumerator|\c Enumerator_value)
def is_enum(arg):
    """
    instanceof-like function.
    \return \c True if the argument is a "enum" node.
    """
    if not isinstance(arg, tuple):
        return False
    return arg[0] == 'enum'

def is_deref(arg):
    """
    instanceof-like function.
    \return \c True if the argument is a "deref" node.
    """
    if not isinstance(arg, tuple):
        return False
    return arg[0] == 'deref'

def is_pointer_expr(arg):
    """
    instanceof-like function.
    \return \c True if the argument is a "pointer_expr" node.
    """
    if not isinstance(arg, tuple):
        return False
    return arg[0] == 'pointer_expr'

# skipping \c Attr= (static|pure|hooks)
# skipping \c Mode= (in|out|inout)
def is_rarray(arg):
    """
    instanceof-like function.
    \return \c True if the argument is a "rarray" node.
    """
    if not isinstance(arg, tuple):
        return False
    return arg[0] == 'rarray'

def is_pointer_type(arg):
    """
    instanceof-like function.
    \return \c True if the argument is a "pointer_type" node.
    """
    if not isinstance(arg, tuple):
        return False
    return arg[0] == 'pointer_type'

def is_primitive_type(arg):
    """
    instanceof-like function.
    \return \c True if the argument is a "primitive_type" node.
    """
    if not isinstance(arg, tuple):
        return False
    return arg[0] == 'primitive_type'

# skipping \c Extents= \c SimpleIntExpr
# skipping \c Dimension=INT
# skipping \c SimpleIntExpr= (\c Simple_int_infix_expr|\c Simple_int_prefix_expr|\c Simple_int_fn_eval|\c Var_ref|INT)
# skipping \c Module=STR
# skipping \c Extension=STR
def is_type_decl(arg):
    """
    instanceof-like function.
    \return \c True if the argument is a "type_decl" node.
    """
    if not isinstance(arg, tuple):
        return False
    return arg[0] == 'type_decl'

def is_stmt(arg):
    """
    instanceof-like function.
    \return \c True if the argument is a "stmt" node.
    """
    if not isinstance(arg, tuple):
        return False
    return arg[0] == 'stmt'

def is_new(arg):
    """
    instanceof-like function.
    \return \c True if the argument is a "new" node.
    """
    if not isinstance(arg, tuple):
        return False
    return arg[0] == 'new'

def is_cast(arg):
    """
    instanceof-like function.
    \return \c True if the argument is a "cast" node.
    """
    if not isinstance(arg, tuple):
        return False
    return arg[0] == 'cast'

def is_set_struct_item(arg):
    """
    instanceof-like function.
    \return \c True if the argument is a "set_struct_item" node.
    """
    if not isinstance(arg, tuple):
        return False
    return arg[0] == 'set_struct_item'

def is_assignment(arg):
    """
    instanceof-like function.
    \return \c True if the argument is a "assignment" node.
    """
    if not isinstance(arg, tuple):
        return False
    return arg[0] == 'assignment'

def is_set_arg(arg):
    """
    instanceof-like function.
    \return \c True if the argument is a "set_arg" node.
    """
    if not isinstance(arg, tuple):
        return False
    return arg[0] == 'set_arg'

def is_infix_expr(arg):
    """
    instanceof-like function.
    \return \c True if the argument is a "infix_expr" node.
    """
    if not isinstance(arg, tuple):
        return False
    return arg[0] == 'infix_expr'

def is_prefix_expr(arg):
    """
    instanceof-like function.
    \return \c True if the argument is a "prefix_expr" node.
    """
    if not isinstance(arg, tuple):
        return False
    return arg[0] == 'prefix_expr'

def is_sign_extend(arg):
    """
    instanceof-like function.
    \return \c True if the argument is a "sign_extend" node.
    """
    if not isinstance(arg, tuple):
        return False
    return arg[0] == 'sign_extend'

def is_var_decl(arg):
    """
    instanceof-like function.
    \return \c True if the argument is a "var_decl" node.
    """
    if not isinstance(arg, tuple):
        return False
    return arg[0] == 'var_decl'

def is_var_decl_init(arg):
    """
    instanceof-like function.
    \return \c True if the argument is a "var_decl_init" node.
    """
    if not isinstance(arg, tuple):
        return False
    return arg[0] == 'var_decl_init'

def is_enumerator(arg):
    """
    instanceof-like function.
    \return \c True if the argument is a "enumerator" node.
    """
    if not isinstance(arg, tuple):
        return False
    return arg[0] == 'enumerator'

def is_enumerator_value(arg):
    """
    instanceof-like function.
    \return \c True if the argument is a "enumerator_value" node.
    """
    if not isinstance(arg, tuple):
        return False
    return arg[0] == 'enumerator_value'

def is_get_struct_item(arg):
    """
    instanceof-like function.
    \return \c True if the argument is a "get_struct_item" node.
    """
    if not isinstance(arg, tuple):
        return False
    return arg[0] == 'get_struct_item'

def is_call(arg):
    """
    instanceof-like function.
    \return \c True if the argument is a "call" node.
    """
    if not isinstance(arg, tuple):
        return False
    return arg[0] == 'call'

def is_typedef_type(arg):
    """
    instanceof-like function.
    \return \c True if the argument is a "typedef_type" node.
    """
    if not isinstance(arg, tuple):
        return False
    return arg[0] == 'typedef_type'

def is_const(arg):
    """
    instanceof-like function.
    \return \c True if the argument is a "const" node.
    """
    if not isinstance(arg, tuple):
        return False
    return arg[0] == 'const'

def is_simple_int_infix_expr(arg):
    """
    instanceof-like function.
    \return \c True if the argument is a "simple_int_infix_expr" node.
    """
    if not isinstance(arg, tuple):
        return False
    return arg[0] == 'simple_int_infix_expr'

def is_simple_int_prefix_expr(arg):
    """
    instanceof-like function.
    \return \c True if the argument is a "simple_int_prefix_expr" node.
    """
    if not isinstance(arg, tuple):
        return False
    return arg[0] == 'simple_int_prefix_expr'

def is_simple_int_fn_eval(arg):
    """
    instanceof-like function.
    \return \c True if the argument is a "simple_int_fn_eval" node.
    """
    if not isinstance(arg, tuple):
        return False
    return arg[0] == 'simple_int_fn_eval'

def is_var_ref(arg):
    """
    instanceof-like function.
    \return \c True if the argument is a "var_ref" node.
    """
    if not isinstance(arg, tuple):
        return False
    return arg[0] == 'var_ref'

 ## token overrides fir sidl.def compatibility
bit_not = '~'
eq = '=='
ne = '!='
bit_or = '|'
bit_and = '&'
bit_xor = '^'
lt = '<'
gt = '>'
le = '<='
ge = '>='
lshift = '<<'
rshift = '>>'
plus = '+'
minus = '_'
times = '*'
divide = '/'
modulo = '%'
pow = '**'
 ## ir primitive types
pt_bool     = Primitive_type(bool)
pt_char     = Primitive_type(char)
pt_int      = Primitive_type(int)
pt_long     = Primitive_type(long)
pt_float    = Primitive_type(float)
pt_double   = Primitive_type(double)
pt_fcomplex = Primitive_type(fcomplex)
pt_dcomplex = Primitive_type(dcomplex)
pt_string   = Primitive_type(string)
pt_void     = Primitive_type(void)
void_ptr    = Pointer_type(pt_void)
pt_long_long= Primitive_type(long_long)
pt_long_double= Primitive_type(long_double)
 ## const char*
const_str = Pointer_type(Const(Primitive_type(char)))
 
def Plus(A, B):
    """
    same as Infix_expr(ir.plus, A, B)
    """
    return Infix_expr(plus, A, B)
def Get_struct_item_stmt(struct, sname, iname):
    """
    Convenience replacement function for Get_struct_item().
    Accepts just the name of the item and looks up the type from \c struct.
    """
    for item in struct[2]:
        (_, _, id) = item
        if id == iname:
            return Stmt(Get_struct_item(struct, sname, item))
    raise Exception('lookup failed')
def Set_struct_item_stmt(struct, sname, iname, expr):
    """
    Convenience replacement function for Set_struct_item().
    Accepts just the name of the item and looks up the type from \c struct.
    """
    for item in struct[2]:
        (_, _, id) = item
        if id == iname:
            return Stmt(Set_struct_item(struct, sname, item, expr))
    raise Exception('lookup failed')
