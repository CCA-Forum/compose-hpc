#!/usr/bin/env python
# -*- python -*-
## @package sidl
# Grammar for the SIDL intermediate representation (IR).
# This is NOT a grammar for SIDL, the language.
#
# Please report bugs to <adrian@llnl.gov>.
#
# \authors <pre>
#
# Copyright (c) 2011, Lawrence Livermore National Security, LLC.
# Produced at the Lawrence Livermore National Laboratory
# Written by Adrian Prantl <adrian@llnl.gov>.
#
# LLNL-CODE-473891.
# All rights reserved.
#
# This file is part of BRAID. For details, see
# http://compose-hpc.sourceforge.net/.
# Please read the COPYRIGHT file for Our Notice and
# for the BSD License.
#
# </pre>
#
#
# <h2>Grammar definition</h2>
#
#\verbatim
# 
# [
#   _File = file([Require], [Import], [User_type]),
#   Version = version('STR' | 'FLOAT' | 'INT'),
#   Require = require(Scoped_id, Version),
#   Import = import(Scoped_id, Version),
#   Package = package(Id, Version, [User_type], Doc_comment),
#   User_type = user_type([(Type_attr|Custom_attr)], Cipse),
#   Cipse = ( Class
# 	  | Interface
# 	  | Package
# 	  | Struct
# 	  | Enum ),
#   Type_attr = (final | abstract),
#   Id = 'STR',
#   Doc_comment = 'STR',
#   Enum = enum(Id, [Enumerator], Doc_comment),
#   Enumerator = ( enumerator(Id) | enumerator(Id, 'INT')),
#   Struct = struct(Scoped_id, [Struct_item]),
#   Struct_item = struct_item(Type_void, Id),
#   Class = class(Id, [Extends], [Implements], [Invariant], [Method], Doc_comment),
#   Interface = interface(Id, [Extends], [Invariant], [Method], Doc_comment),
#   Implements = ( implements(Scoped_id)
# 	       | implements_all(Scoped_id)),
#   Method = method(Type_void, Method_name, [Method_attr], [Arg],
# 		  [Except], [From], [Require], [Ensure], Doc_comment),
#   Method_name = method_name(Id, Extension),
#   Extension = 'STR',
#   Type_void = ( void | Type ),
#   Method_attr = ( oneway
# 		| local
# 		| static
# 		| abstract
# 		| final
# 		| nonblocking
# 		| copy ),
#   From = from(Scoped_id),
#   Invariant = invariant(Assertion),
#   Assertion = assertion(Id, AssertExpr),
#   Except = except([Scoped_id]),
#   Ensure = ensure([Scoped_id]),
#   Extends = extends([Scoped_id]),
#   Arg = ( arg([Arg_attr], Mode, Type_void, Id)
# 	| rarg([Arg_attr], Mode, Rarray) ),
#   Arg_attr = (copy | ['STR']),
#   Custom_attr = ( custom_attribute('STR')
# 		| custom_attribute_assoc('STR', 'STR')
# 		),
#   Mode = (in | out | inout),
#   Type = (Primitive_type | Array | Scoped_id),
#   Primitive_type = primitive_type(
#       bool|char|int|long|float|double|fcomplex|dcomplex|string|opaque),
#   Array = array(Scalar_type, Dimension, Orientation),
#   Scalar_type = (Primitive_type|Scoped_id),
#   Dimension = 'INT',
#   Orientation = (row_major|column_major),
#   Rarray = rarray(Primitive_type, Dimension, Id, Extents),
#   Extents = SimpleIntExpression,
#   SimpleIntExpression = 'INT', % resolved by the parser?
#   AssertExpr = ( infix_expr(Bin_op, AssertExpr, AssertExpr)
# 	       | prefix_expr(Un_op, AssertExpr)
# 	       | fn_eval(Id, [Arg])
# 	       | var_ref(Id)
# 	       | Id
# 	       | Literal
# 	       ),
#   Bin_op = (log_or|log_and|eq|ne|bit_or|bit_and|bit_xor|lt|gt|lshift|rshift
# 	  |plus|minus|times|divide|modulo|rem|pow),
#   Un_op = ( is|log_not|bit_not ),
#   Scoped_id = scoped_id([Id], Extension),
#   Literal = ('INT' | 'FLOAT' | 'STR' | pure | result | Complex),
#   Complex = complex('FLOAT', 'FLOAT')
# ].
#\endverbatim


# Automatically generated by GRAMOLA.
#     ### ### #### ### ###
#     ### DO NOT EDIT! ###
#     ### ### #### ### ###
import types as PythonTypes


## Token definitions

abstract = 'abstract'
arg = 'arg'
array = 'array'
assertion = 'assertion'
bit_and = 'bit_and'
bit_not = 'bit_not'
bit_or = 'bit_or'
bit_xor = 'bit_xor'
bool = 'bool'
char = 'char'
class_ = 'class'
column_major = 'column_major'
complex = 'complex'
copy = 'copy'
custom_attribute = 'custom_attribute'
custom_attribute_assoc = 'custom_attribute_assoc'
dcomplex = 'dcomplex'
divide = 'divide'
double = 'double'
ensure = 'ensure'
enum = 'enum'
enumerator = 'enumerator'
eq = 'eq'
except_ = 'except'
extends = 'extends'
fcomplex = 'fcomplex'
file = 'file'
final = 'final'
float = 'float'
fn_eval = 'fn_eval'
from_ = 'from'
gt = 'gt'
implements = 'implements'
implements_all = 'implements_all'
import_ = 'import'
in_ = 'in'
infix_expr = 'infix_expr'
inout = 'inout'
int = 'int'
interface = 'interface'
invariant = 'invariant'
is_ = 'is'
local = 'local'
log_and = 'log_and'
log_not = 'log_not'
log_or = 'log_or'
long = 'long'
lshift = 'lshift'
lt = 'lt'
method = 'method'
method_name = 'method_name'
minus = 'minus'
modulo = 'modulo'
ne = 'ne'
nonblocking = 'nonblocking'
oneway = 'oneway'
opaque = 'opaque'
out = 'out'
package = 'package'
plus = 'plus'
pow = 'pow'
prefix_expr = 'prefix_expr'
primitive_type = 'primitive_type'
pure = 'pure'
rarg = 'rarg'
rarray = 'rarray'
rem = 'rem'
require = 'require'
result = 'result'
row_major = 'row_major'
rshift = 'rshift'
scoped_id = 'scoped_id'
static = 'static'
string = 'string'
struct = 'struct'
struct_item = 'struct_item'
times = 'times'
user_type = 'user_type'
var_ref = 'var_ref'
version = 'version'
void = 'void'


## Constructor definitions

def Require(*args):
    """
    Construct a "require" node. Valid arguments are 
    (\c Scoped_id(), \c Version())
    \return (\c "Require", \c Scoped_id(), \c Version())
    """
    f = Require
    if len(args) <> 2:
        print "**GRAMMAR ERROR: expected 2 arguments for a", f.__name__
        print "Most likely you want to enter \"up<enter>l<enter>\" now to see what happened."
        raise Exception("Grammar Error")
    if isinstance(args[0], tuple) and args[0][0] == scoped_id:
        pass
    else:
        print f.__name__+"():\n    \"\"\"%s\"\"\"\n" %f.__doc__.replace("\\n","\n").replace("\return","Returns").replace("\\c ","")
        print "**GRAMMAR ERROR in argument args[0] = %s"%repr(args[0])
        print "  Most likely you now want to enter \"up<enter>l<enter>\"\n into the debugger to see what happened.\n"
        raise Exception("Grammar Error")
    if isinstance(args[1], tuple) and args[1][0] == version:
        pass
    else:
        print f.__name__+"():\n    \"\"\"%s\"\"\"\n" %f.__doc__.replace("\\n","\n").replace("\return","Returns").replace("\\c ","")
        print "**GRAMMAR ERROR in argument args[1] = %s"%repr(args[1])
        print "  Most likely you now want to enter \"up<enter>l<enter>\"\n into the debugger to see what happened.\n"
        raise Exception("Grammar Error")
    return tuple(['require']+list(args))

def Import(*args):
    """
    Construct a "import" node. Valid arguments are 
    (\c Scoped_id(), \c Version())
    \return (\c "Import", \c Scoped_id(), \c Version())
    """
    f = Import
    if len(args) <> 2:
        print "**GRAMMAR ERROR: expected 2 arguments for a", f.__name__
        print "Most likely you want to enter \"up<enter>l<enter>\" now to see what happened."
        raise Exception("Grammar Error")
    if isinstance(args[0], tuple) and args[0][0] == scoped_id:
        pass
    else:
        print f.__name__+"():\n    \"\"\"%s\"\"\"\n" %f.__doc__.replace("\\n","\n").replace("\return","Returns").replace("\\c ","")
        print "**GRAMMAR ERROR in argument args[0] = %s"%repr(args[0])
        print "  Most likely you now want to enter \"up<enter>l<enter>\"\n into the debugger to see what happened.\n"
        raise Exception("Grammar Error")
    if isinstance(args[1], tuple) and args[1][0] == version:
        pass
    else:
        print f.__name__+"():\n    \"\"\"%s\"\"\"\n" %f.__doc__.replace("\\n","\n").replace("\return","Returns").replace("\\c ","")
        print "**GRAMMAR ERROR in argument args[1] = %s"%repr(args[1])
        print "  Most likely you now want to enter \"up<enter>l<enter>\"\n into the debugger to see what happened.\n"
        raise Exception("Grammar Error")
    return tuple(['import']+list(args))

def User_type(*args):
    """
    Construct a "user_type" node. Valid arguments are 
    ([\c Type_attr()
    |\c Custom_attr()], \c Cipse())
    \return (\c "User_type", [\c Type_attr()
    |\c Custom_attr()], \c Cipse())
    """
    f = User_type
    if len(args) <> 2:
        print "**GRAMMAR ERROR: expected 2 arguments for a", f.__name__
        print "Most likely you want to enter \"up<enter>l<enter>\" now to see what happened."
        raise Exception("Grammar Error")
    if isinstance(args[0], list):
        for a in args[0]:
            if a == final:
                pass
            elif a == abstract:
                pass
            elif isinstance(a, tuple) and a[0] == custom_attribute:
                pass
            elif isinstance(a, tuple) and a[0] == custom_attribute_assoc:
                pass
            else:
                print f.__name__+"():\n    \"\"\"%s\"\"\"\n" %f.__doc__.replace("\\n","\n").replace("\return","Returns").replace("\\c ","")
                print "**GRAMMAR ERROR in argument a = %s"%repr(a)
                print "  Most likely you now want to enter \"up<enter>l<enter>\"\n into the debugger to see what happened.\n"
                raise Exception("Grammar Error")
    else:
        print f.__name__+"():\n    \"\"\"%s\"\"\"\n" %f.__doc__.replace("\\n","\n").replace("\return","Returns").replace("\\c ","")
        print "**GRAMMAR ERROR in argument args[0] = %s"%repr(args[0])
        print "  Most likely you now want to enter \"up<enter>l<enter>\"\n into the debugger to see what happened.\n"
        raise Exception("Grammar Error")
    if isinstance(args[1], tuple) and args[1][0] == class_:
        pass
    elif isinstance(args[1], tuple) and args[1][0] == interface:
        pass
    elif isinstance(args[1], tuple) and args[1][0] == package:
        pass
    elif isinstance(args[1], tuple) and args[1][0] == struct:
        pass
    elif isinstance(args[1], tuple) and args[1][0] == enum:
        pass
    else:
        print f.__name__+"():\n    \"\"\"%s\"\"\"\n" %f.__doc__.replace("\\n","\n").replace("\return","Returns").replace("\\c ","")
        print "**GRAMMAR ERROR in argument args[1] = %s"%repr(args[1])
        print "  Most likely you now want to enter \"up<enter>l<enter>\"\n into the debugger to see what happened.\n"
        raise Exception("Grammar Error")
    return tuple(['user_type']+list(args))

def File(*args):
    """
    Construct a "file" node. Valid arguments are 
    ([\c Require()], [\c Import()], [\c User_type()])
    \return (\c "_File", [\c Require()], [\c Import()], [\c User_type()])
    """
    f = File
    if len(args) <> 3:
        print "**GRAMMAR ERROR: expected 3 arguments for a", f.__name__
        print "Most likely you want to enter \"up<enter>l<enter>\" now to see what happened."
        raise Exception("Grammar Error")
    if isinstance(args[0], list):
        for a in args[0]:
            if isinstance(a, tuple) and a[0] == require:
                pass
            else:
                print f.__name__+"():\n    \"\"\"%s\"\"\"\n" %f.__doc__.replace("\\n","\n").replace("\return","Returns").replace("\\c ","")
                print "**GRAMMAR ERROR in argument a = %s"%repr(a)
                print "  Most likely you now want to enter \"up<enter>l<enter>\"\n into the debugger to see what happened.\n"
                raise Exception("Grammar Error")
    else:
        print f.__name__+"():\n    \"\"\"%s\"\"\"\n" %f.__doc__.replace("\\n","\n").replace("\return","Returns").replace("\\c ","")
        print "**GRAMMAR ERROR in argument args[0] = %s"%repr(args[0])
        print "  Most likely you now want to enter \"up<enter>l<enter>\"\n into the debugger to see what happened.\n"
        raise Exception("Grammar Error")
    if isinstance(args[1], list):
        for a in args[1]:
            if isinstance(a, tuple) and a[0] == import_:
                pass
            else:
                print f.__name__+"():\n    \"\"\"%s\"\"\"\n" %f.__doc__.replace("\\n","\n").replace("\return","Returns").replace("\\c ","")
                print "**GRAMMAR ERROR in argument a = %s"%repr(a)
                print "  Most likely you now want to enter \"up<enter>l<enter>\"\n into the debugger to see what happened.\n"
                raise Exception("Grammar Error")
    else:
        print f.__name__+"():\n    \"\"\"%s\"\"\"\n" %f.__doc__.replace("\\n","\n").replace("\return","Returns").replace("\\c ","")
        print "**GRAMMAR ERROR in argument args[1] = %s"%repr(args[1])
        print "  Most likely you now want to enter \"up<enter>l<enter>\"\n into the debugger to see what happened.\n"
        raise Exception("Grammar Error")
    if isinstance(args[2], list):
        for a in args[2]:
            if isinstance(a, tuple) and a[0] == user_type:
                pass
            else:
                print f.__name__+"():\n    \"\"\"%s\"\"\"\n" %f.__doc__.replace("\\n","\n").replace("\return","Returns").replace("\\c ","")
                print "**GRAMMAR ERROR in argument a = %s"%repr(a)
                print "  Most likely you now want to enter \"up<enter>l<enter>\"\n into the debugger to see what happened.\n"
                raise Exception("Grammar Error")
    else:
        print f.__name__+"():\n    \"\"\"%s\"\"\"\n" %f.__doc__.replace("\\n","\n").replace("\return","Returns").replace("\\c ","")
        print "**GRAMMAR ERROR in argument args[2] = %s"%repr(args[2])
        print "  Most likely you now want to enter \"up<enter>l<enter>\"\n into the debugger to see what happened.\n"
        raise Exception("Grammar Error")
    return tuple(['file']+list(args))

def Version(*args):
    """
    Construct a "version" node. Valid arguments are 
    (STR()
    |FLOAT()
    |INT())
    \return (\c "Version", STR()
    |FLOAT()
    |INT())
    """
    f = Version
    if len(args) <> 1:
        print "**GRAMMAR ERROR: expected 1 arguments for a", f.__name__
        print "Most likely you want to enter \"up<enter>l<enter>\" now to see what happened."
        raise Exception("Grammar Error")
    if isinstance(args[0], PythonTypes.StringType):
        pass
    elif isinstance(args[0], PythonTypes.FloatType):
        pass
    elif isinstance(args[0], PythonTypes.IntType):
        pass
    else:
        print f.__name__+"():\n    \"\"\"%s\"\"\"\n" %f.__doc__.replace("\\n","\n").replace("\return","Returns").replace("\\c ","")
        print "**GRAMMAR ERROR in argument args[0] = %s"%repr(args[0])
        print "  Most likely you now want to enter \"up<enter>l<enter>\"\n into the debugger to see what happened.\n"
        raise Exception("Grammar Error")
    return tuple(['version']+list(args))

def Scoped_id(*args):
    """
    Construct a "scoped_id" node. Valid arguments are 
    ([\c Id()], \c Extension())
    \return (\c "Scoped_id", [\c Id()], \c Extension())
    """
    f = Scoped_id
    if len(args) <> 2:
        print "**GRAMMAR ERROR: expected 2 arguments for a", f.__name__
        print "Most likely you want to enter \"up<enter>l<enter>\" now to see what happened."
        raise Exception("Grammar Error")
    if isinstance(args[0], list):
        for a in args[0]:
            if isinstance(a, PythonTypes.StringType):
                pass
            else:
                print f.__name__+"():\n    \"\"\"%s\"\"\"\n" %f.__doc__.replace("\\n","\n").replace("\return","Returns").replace("\\c ","")
                print "**GRAMMAR ERROR in argument a = %s"%repr(a)
                print "  Most likely you now want to enter \"up<enter>l<enter>\"\n into the debugger to see what happened.\n"
                raise Exception("Grammar Error")
    else:
        print f.__name__+"():\n    \"\"\"%s\"\"\"\n" %f.__doc__.replace("\\n","\n").replace("\return","Returns").replace("\\c ","")
        print "**GRAMMAR ERROR in argument args[0] = %s"%repr(args[0])
        print "  Most likely you now want to enter \"up<enter>l<enter>\"\n into the debugger to see what happened.\n"
        raise Exception("Grammar Error")
    if isinstance(args[1], PythonTypes.StringType):
        pass
    else:
        print f.__name__+"():\n    \"\"\"%s\"\"\"\n" %f.__doc__.replace("\\n","\n").replace("\return","Returns").replace("\\c ","")
        print "**GRAMMAR ERROR in argument args[1] = %s"%repr(args[1])
        print "  Most likely you now want to enter \"up<enter>l<enter>\"\n into the debugger to see what happened.\n"
        raise Exception("Grammar Error")
    return tuple(['scoped_id']+list(args))

def STR():
    return STR
def STR():
    return STR
def Package(*args):
    """
    Construct a "package" node. Valid arguments are 
    (\c Id(), \c Version(), [\c User_type()], \c Doc_comment())
    \return (\c "Package", \c Id(), \c Version(), [\c User_type()], \c Doc_comment())
    """
    f = Package
    if len(args) <> 4:
        print "**GRAMMAR ERROR: expected 4 arguments for a", f.__name__
        print "Most likely you want to enter \"up<enter>l<enter>\" now to see what happened."
        raise Exception("Grammar Error")
    if isinstance(args[0], PythonTypes.StringType):
        pass
    else:
        print f.__name__+"():\n    \"\"\"%s\"\"\"\n" %f.__doc__.replace("\\n","\n").replace("\return","Returns").replace("\\c ","")
        print "**GRAMMAR ERROR in argument args[0] = %s"%repr(args[0])
        print "  Most likely you now want to enter \"up<enter>l<enter>\"\n into the debugger to see what happened.\n"
        raise Exception("Grammar Error")
    if isinstance(args[1], tuple) and args[1][0] == version:
        pass
    else:
        print f.__name__+"():\n    \"\"\"%s\"\"\"\n" %f.__doc__.replace("\\n","\n").replace("\return","Returns").replace("\\c ","")
        print "**GRAMMAR ERROR in argument args[1] = %s"%repr(args[1])
        print "  Most likely you now want to enter \"up<enter>l<enter>\"\n into the debugger to see what happened.\n"
        raise Exception("Grammar Error")
    if isinstance(args[2], list):
        for a in args[2]:
            if isinstance(a, tuple) and a[0] == user_type:
                pass
            else:
                print f.__name__+"():\n    \"\"\"%s\"\"\"\n" %f.__doc__.replace("\\n","\n").replace("\return","Returns").replace("\\c ","")
                print "**GRAMMAR ERROR in argument a = %s"%repr(a)
                print "  Most likely you now want to enter \"up<enter>l<enter>\"\n into the debugger to see what happened.\n"
                raise Exception("Grammar Error")
    else:
        print f.__name__+"():\n    \"\"\"%s\"\"\"\n" %f.__doc__.replace("\\n","\n").replace("\return","Returns").replace("\\c ","")
        print "**GRAMMAR ERROR in argument args[2] = %s"%repr(args[2])
        print "  Most likely you now want to enter \"up<enter>l<enter>\"\n into the debugger to see what happened.\n"
        raise Exception("Grammar Error")
    if isinstance(args[3], PythonTypes.StringType):
        pass
    else:
        print f.__name__+"():\n    \"\"\"%s\"\"\"\n" %f.__doc__.replace("\\n","\n").replace("\return","Returns").replace("\\c ","")
        print "**GRAMMAR ERROR in argument args[3] = %s"%repr(args[3])
        print "  Most likely you now want to enter \"up<enter>l<enter>\"\n into the debugger to see what happened.\n"
        raise Exception("Grammar Error")
    return tuple(['package']+list(args))

# skipping \c Type_attr= (final|abstract)
# skipping \c Custom_attr= (\c Custom_attribute|\c Custom_attribute_assoc)
# skipping \c Cipse= (\c Class|\c Interface|\c Package|\c Struct|\c Enum)
def Struct(*args):
    """
    Construct a "struct" node. Valid arguments are 
    (\c Scoped_id(), [\c Struct_item()])
    \return (\c "Struct", \c Scoped_id(), [\c Struct_item()])
    """
    f = Struct
    if len(args) <> 2:
        print "**GRAMMAR ERROR: expected 2 arguments for a", f.__name__
        print "Most likely you want to enter \"up<enter>l<enter>\" now to see what happened."
        raise Exception("Grammar Error")
    if isinstance(args[0], tuple) and args[0][0] == scoped_id:
        pass
    else:
        print f.__name__+"():\n    \"\"\"%s\"\"\"\n" %f.__doc__.replace("\\n","\n").replace("\return","Returns").replace("\\c ","")
        print "**GRAMMAR ERROR in argument args[0] = %s"%repr(args[0])
        print "  Most likely you now want to enter \"up<enter>l<enter>\"\n into the debugger to see what happened.\n"
        raise Exception("Grammar Error")
    if isinstance(args[1], list):
        for a in args[1]:
            if isinstance(a, tuple) and a[0] == struct_item:
                pass
            else:
                print f.__name__+"():\n    \"\"\"%s\"\"\"\n" %f.__doc__.replace("\\n","\n").replace("\return","Returns").replace("\\c ","")
                print "**GRAMMAR ERROR in argument a = %s"%repr(a)
                print "  Most likely you now want to enter \"up<enter>l<enter>\"\n into the debugger to see what happened.\n"
                raise Exception("Grammar Error")
    else:
        print f.__name__+"():\n    \"\"\"%s\"\"\"\n" %f.__doc__.replace("\\n","\n").replace("\return","Returns").replace("\\c ","")
        print "**GRAMMAR ERROR in argument args[1] = %s"%repr(args[1])
        print "  Most likely you now want to enter \"up<enter>l<enter>\"\n into the debugger to see what happened.\n"
        raise Exception("Grammar Error")
    return tuple(['struct']+list(args))

def Enum(*args):
    """
    Construct a "enum" node. Valid arguments are 
    (\c Id(), [\c Enumerator()], \c Doc_comment())
    \return (\c "Enum", \c Id(), [\c Enumerator()], \c Doc_comment())
    """
    f = Enum
    if len(args) <> 3:
        print "**GRAMMAR ERROR: expected 3 arguments for a", f.__name__
        print "Most likely you want to enter \"up<enter>l<enter>\" now to see what happened."
        raise Exception("Grammar Error")
    if isinstance(args[0], PythonTypes.StringType):
        pass
    else:
        print f.__name__+"():\n    \"\"\"%s\"\"\"\n" %f.__doc__.replace("\\n","\n").replace("\return","Returns").replace("\\c ","")
        print "**GRAMMAR ERROR in argument args[0] = %s"%repr(args[0])
        print "  Most likely you now want to enter \"up<enter>l<enter>\"\n into the debugger to see what happened.\n"
        raise Exception("Grammar Error")
    if isinstance(args[1], list):
        for a in args[1]:
            if isinstance(a, tuple) and a[0] == enumerator:
                pass
            elif isinstance(a, tuple) and a[0] == enumerator:
                pass
            else:
                print f.__name__+"():\n    \"\"\"%s\"\"\"\n" %f.__doc__.replace("\\n","\n").replace("\return","Returns").replace("\\c ","")
                print "**GRAMMAR ERROR in argument a = %s"%repr(a)
                print "  Most likely you now want to enter \"up<enter>l<enter>\"\n into the debugger to see what happened.\n"
                raise Exception("Grammar Error")
    else:
        print f.__name__+"():\n    \"\"\"%s\"\"\"\n" %f.__doc__.replace("\\n","\n").replace("\return","Returns").replace("\\c ","")
        print "**GRAMMAR ERROR in argument args[1] = %s"%repr(args[1])
        print "  Most likely you now want to enter \"up<enter>l<enter>\"\n into the debugger to see what happened.\n"
        raise Exception("Grammar Error")
    if isinstance(args[2], PythonTypes.StringType):
        pass
    else:
        print f.__name__+"():\n    \"\"\"%s\"\"\"\n" %f.__doc__.replace("\\n","\n").replace("\return","Returns").replace("\\c ","")
        print "**GRAMMAR ERROR in argument args[2] = %s"%repr(args[2])
        print "  Most likely you now want to enter \"up<enter>l<enter>\"\n into the debugger to see what happened.\n"
        raise Exception("Grammar Error")
    return tuple(['enum']+list(args))

def Interface(*args):
    """
    Construct a "interface" node. Valid arguments are 
    (\c Id(), [\c Extends()], [\c Invariant()], [\c Method()], \c Doc_comment())
    \return (\c "Interface", \c Id(), [\c Extends()], [\c Invariant()], [\c Method()], \c Doc_comment())
    """
    f = Interface
    if len(args) <> 5:
        print "**GRAMMAR ERROR: expected 5 arguments for a", f.__name__
        print "Most likely you want to enter \"up<enter>l<enter>\" now to see what happened."
        raise Exception("Grammar Error")
    if isinstance(args[0], PythonTypes.StringType):
        pass
    else:
        print f.__name__+"():\n    \"\"\"%s\"\"\"\n" %f.__doc__.replace("\\n","\n").replace("\return","Returns").replace("\\c ","")
        print "**GRAMMAR ERROR in argument args[0] = %s"%repr(args[0])
        print "  Most likely you now want to enter \"up<enter>l<enter>\"\n into the debugger to see what happened.\n"
        raise Exception("Grammar Error")
    if isinstance(args[1], list):
        for a in args[1]:
            if isinstance(a, tuple) and a[0] == extends:
                pass
            else:
                print f.__name__+"():\n    \"\"\"%s\"\"\"\n" %f.__doc__.replace("\\n","\n").replace("\return","Returns").replace("\\c ","")
                print "**GRAMMAR ERROR in argument a = %s"%repr(a)
                print "  Most likely you now want to enter \"up<enter>l<enter>\"\n into the debugger to see what happened.\n"
                raise Exception("Grammar Error")
    else:
        print f.__name__+"():\n    \"\"\"%s\"\"\"\n" %f.__doc__.replace("\\n","\n").replace("\return","Returns").replace("\\c ","")
        print "**GRAMMAR ERROR in argument args[1] = %s"%repr(args[1])
        print "  Most likely you now want to enter \"up<enter>l<enter>\"\n into the debugger to see what happened.\n"
        raise Exception("Grammar Error")
    if isinstance(args[2], list):
        for a in args[2]:
            if isinstance(a, tuple) and a[0] == invariant:
                pass
            else:
                print f.__name__+"():\n    \"\"\"%s\"\"\"\n" %f.__doc__.replace("\\n","\n").replace("\return","Returns").replace("\\c ","")
                print "**GRAMMAR ERROR in argument a = %s"%repr(a)
                print "  Most likely you now want to enter \"up<enter>l<enter>\"\n into the debugger to see what happened.\n"
                raise Exception("Grammar Error")
    else:
        print f.__name__+"():\n    \"\"\"%s\"\"\"\n" %f.__doc__.replace("\\n","\n").replace("\return","Returns").replace("\\c ","")
        print "**GRAMMAR ERROR in argument args[2] = %s"%repr(args[2])
        print "  Most likely you now want to enter \"up<enter>l<enter>\"\n into the debugger to see what happened.\n"
        raise Exception("Grammar Error")
    if isinstance(args[3], list):
        for a in args[3]:
            if isinstance(a, tuple) and a[0] == method:
                pass
            else:
                print f.__name__+"():\n    \"\"\"%s\"\"\"\n" %f.__doc__.replace("\\n","\n").replace("\return","Returns").replace("\\c ","")
                print "**GRAMMAR ERROR in argument a = %s"%repr(a)
                print "  Most likely you now want to enter \"up<enter>l<enter>\"\n into the debugger to see what happened.\n"
                raise Exception("Grammar Error")
    else:
        print f.__name__+"():\n    \"\"\"%s\"\"\"\n" %f.__doc__.replace("\\n","\n").replace("\return","Returns").replace("\\c ","")
        print "**GRAMMAR ERROR in argument args[3] = %s"%repr(args[3])
        print "  Most likely you now want to enter \"up<enter>l<enter>\"\n into the debugger to see what happened.\n"
        raise Exception("Grammar Error")
    if isinstance(args[4], PythonTypes.StringType):
        pass
    else:
        print f.__name__+"():\n    \"\"\"%s\"\"\"\n" %f.__doc__.replace("\\n","\n").replace("\return","Returns").replace("\\c ","")
        print "**GRAMMAR ERROR in argument args[4] = %s"%repr(args[4])
        print "  Most likely you now want to enter \"up<enter>l<enter>\"\n into the debugger to see what happened.\n"
        raise Exception("Grammar Error")
    return tuple(['interface']+list(args))

def Class(*args):
    """
    Construct a "class" node. Valid arguments are 
    (\c Id(), [\c Extends()], [\c Implements()], [\c Invariant()], [\c Method()], \c Doc_comment())
    \return (\c "Class", \c Id(), [\c Extends()], [\c Implements()], [\c Invariant()], [\c Method()], \c Doc_comment())
    """
    f = Class
    if len(args) <> 6:
        print "**GRAMMAR ERROR: expected 6 arguments for a", f.__name__
        print "Most likely you want to enter \"up<enter>l<enter>\" now to see what happened."
        raise Exception("Grammar Error")
    if isinstance(args[0], PythonTypes.StringType):
        pass
    else:
        print f.__name__+"():\n    \"\"\"%s\"\"\"\n" %f.__doc__.replace("\\n","\n").replace("\return","Returns").replace("\\c ","")
        print "**GRAMMAR ERROR in argument args[0] = %s"%repr(args[0])
        print "  Most likely you now want to enter \"up<enter>l<enter>\"\n into the debugger to see what happened.\n"
        raise Exception("Grammar Error")
    if isinstance(args[1], list):
        for a in args[1]:
            if isinstance(a, tuple) and a[0] == extends:
                pass
            else:
                print f.__name__+"():\n    \"\"\"%s\"\"\"\n" %f.__doc__.replace("\\n","\n").replace("\return","Returns").replace("\\c ","")
                print "**GRAMMAR ERROR in argument a = %s"%repr(a)
                print "  Most likely you now want to enter \"up<enter>l<enter>\"\n into the debugger to see what happened.\n"
                raise Exception("Grammar Error")
    else:
        print f.__name__+"():\n    \"\"\"%s\"\"\"\n" %f.__doc__.replace("\\n","\n").replace("\return","Returns").replace("\\c ","")
        print "**GRAMMAR ERROR in argument args[1] = %s"%repr(args[1])
        print "  Most likely you now want to enter \"up<enter>l<enter>\"\n into the debugger to see what happened.\n"
        raise Exception("Grammar Error")
    if isinstance(args[2], list):
        for a in args[2]:
            if isinstance(a, tuple) and a[0] == implements:
                pass
            elif isinstance(a, tuple) and a[0] == implements_all:
                pass
            else:
                print f.__name__+"():\n    \"\"\"%s\"\"\"\n" %f.__doc__.replace("\\n","\n").replace("\return","Returns").replace("\\c ","")
                print "**GRAMMAR ERROR in argument a = %s"%repr(a)
                print "  Most likely you now want to enter \"up<enter>l<enter>\"\n into the debugger to see what happened.\n"
                raise Exception("Grammar Error")
    else:
        print f.__name__+"():\n    \"\"\"%s\"\"\"\n" %f.__doc__.replace("\\n","\n").replace("\return","Returns").replace("\\c ","")
        print "**GRAMMAR ERROR in argument args[2] = %s"%repr(args[2])
        print "  Most likely you now want to enter \"up<enter>l<enter>\"\n into the debugger to see what happened.\n"
        raise Exception("Grammar Error")
    if isinstance(args[3], list):
        for a in args[3]:
            if isinstance(a, tuple) and a[0] == invariant:
                pass
            else:
                print f.__name__+"():\n    \"\"\"%s\"\"\"\n" %f.__doc__.replace("\\n","\n").replace("\return","Returns").replace("\\c ","")
                print "**GRAMMAR ERROR in argument a = %s"%repr(a)
                print "  Most likely you now want to enter \"up<enter>l<enter>\"\n into the debugger to see what happened.\n"
                raise Exception("Grammar Error")
    else:
        print f.__name__+"():\n    \"\"\"%s\"\"\"\n" %f.__doc__.replace("\\n","\n").replace("\return","Returns").replace("\\c ","")
        print "**GRAMMAR ERROR in argument args[3] = %s"%repr(args[3])
        print "  Most likely you now want to enter \"up<enter>l<enter>\"\n into the debugger to see what happened.\n"
        raise Exception("Grammar Error")
    if isinstance(args[4], list):
        for a in args[4]:
            if isinstance(a, tuple) and a[0] == method:
                pass
            else:
                print f.__name__+"():\n    \"\"\"%s\"\"\"\n" %f.__doc__.replace("\\n","\n").replace("\return","Returns").replace("\\c ","")
                print "**GRAMMAR ERROR in argument a = %s"%repr(a)
                print "  Most likely you now want to enter \"up<enter>l<enter>\"\n into the debugger to see what happened.\n"
                raise Exception("Grammar Error")
    else:
        print f.__name__+"():\n    \"\"\"%s\"\"\"\n" %f.__doc__.replace("\\n","\n").replace("\return","Returns").replace("\\c ","")
        print "**GRAMMAR ERROR in argument args[4] = %s"%repr(args[4])
        print "  Most likely you now want to enter \"up<enter>l<enter>\"\n into the debugger to see what happened.\n"
        raise Exception("Grammar Error")
    if isinstance(args[5], PythonTypes.StringType):
        pass
    else:
        print f.__name__+"():\n    \"\"\"%s\"\"\"\n" %f.__doc__.replace("\\n","\n").replace("\return","Returns").replace("\\c ","")
        print "**GRAMMAR ERROR in argument args[5] = %s"%repr(args[5])
        print "  Most likely you now want to enter \"up<enter>l<enter>\"\n into the debugger to see what happened.\n"
        raise Exception("Grammar Error")
    return tuple(['class']+list(args))

# skipping \c Enumerator= (\c Enumerator|\c Enumerator)
def Struct_item(*args):
    """
    Construct a "struct_item" node. Valid arguments are 
    (\c Type_void(), \c Id())
    \return (\c "Struct_item", \c Type_void(), \c Id())
    """
    f = Struct_item
    if len(args) <> 2:
        print "**GRAMMAR ERROR: expected 2 arguments for a", f.__name__
        print "Most likely you want to enter \"up<enter>l<enter>\" now to see what happened."
        raise Exception("Grammar Error")
    if args[0] == void:
        pass
    elif isinstance(args[0], tuple) and args[0][0] == primitive_type:
        pass
    elif isinstance(args[0], tuple) and args[0][0] == array:
        pass
    elif isinstance(args[0], tuple) and args[0][0] == scoped_id:
        pass
    else:
        print f.__name__+"():\n    \"\"\"%s\"\"\"\n" %f.__doc__.replace("\\n","\n").replace("\return","Returns").replace("\\c ","")
        print "**GRAMMAR ERROR in argument args[0] = %s"%repr(args[0])
        print "  Most likely you now want to enter \"up<enter>l<enter>\"\n into the debugger to see what happened.\n"
        raise Exception("Grammar Error")
    if isinstance(args[1], PythonTypes.StringType):
        pass
    else:
        print f.__name__+"():\n    \"\"\"%s\"\"\"\n" %f.__doc__.replace("\\n","\n").replace("\return","Returns").replace("\\c ","")
        print "**GRAMMAR ERROR in argument args[1] = %s"%repr(args[1])
        print "  Most likely you now want to enter \"up<enter>l<enter>\"\n into the debugger to see what happened.\n"
        raise Exception("Grammar Error")
    return tuple(['struct_item']+list(args))

# skipping \c Type_void= (void|\c Type)
def Extends(*args):
    """
    Construct a "extends" node. Valid arguments are 
    ([\c Scoped_id()])
    \return (\c "Extends", [\c Scoped_id()])
    """
    f = Extends
    if len(args) <> 1:
        print "**GRAMMAR ERROR: expected 1 arguments for a", f.__name__
        print "Most likely you want to enter \"up<enter>l<enter>\" now to see what happened."
        raise Exception("Grammar Error")
    if isinstance(args[0], list):
        for a in args[0]:
            if isinstance(a, tuple) and a[0] == scoped_id:
                pass
            else:
                print f.__name__+"():\n    \"\"\"%s\"\"\"\n" %f.__doc__.replace("\\n","\n").replace("\return","Returns").replace("\\c ","")
                print "**GRAMMAR ERROR in argument a = %s"%repr(a)
                print "  Most likely you now want to enter \"up<enter>l<enter>\"\n into the debugger to see what happened.\n"
                raise Exception("Grammar Error")
    else:
        print f.__name__+"():\n    \"\"\"%s\"\"\"\n" %f.__doc__.replace("\\n","\n").replace("\return","Returns").replace("\\c ","")
        print "**GRAMMAR ERROR in argument args[0] = %s"%repr(args[0])
        print "  Most likely you now want to enter \"up<enter>l<enter>\"\n into the debugger to see what happened.\n"
        raise Exception("Grammar Error")
    return tuple(['extends']+list(args))

# skipping \c Implements= (\c Implements|\c Implements_all)
def Invariant(*args):
    """
    Construct a "invariant" node. Valid arguments are 
    (\c Assertion())
    \return (\c "Invariant", \c Assertion())
    """
    f = Invariant
    if len(args) <> 1:
        print "**GRAMMAR ERROR: expected 1 arguments for a", f.__name__
        print "Most likely you want to enter \"up<enter>l<enter>\" now to see what happened."
        raise Exception("Grammar Error")
    if isinstance(args[0], tuple) and args[0][0] == assertion:
        pass
    else:
        print f.__name__+"():\n    \"\"\"%s\"\"\"\n" %f.__doc__.replace("\\n","\n").replace("\return","Returns").replace("\\c ","")
        print "**GRAMMAR ERROR in argument args[0] = %s"%repr(args[0])
        print "  Most likely you now want to enter \"up<enter>l<enter>\"\n into the debugger to see what happened.\n"
        raise Exception("Grammar Error")
    return tuple(['invariant']+list(args))

def Method(*args):
    """
    Construct a "method" node. Valid arguments are 
    (\c Type_void(), \c Method_name(), [\c Method_attr()], [\c Arg()], [\c Except()], [\c From()], [\c Require()], [\c Ensure()], \c Doc_comment())
    \return (\c "Method", \c Type_void(), \c Method_name(), [\c Method_attr()], [\c Arg()], [\c Except()], [\c From()], [\c Require()], [\c Ensure()], \c Doc_comment())
    """
    f = Method
    if len(args) <> 9:
        print "**GRAMMAR ERROR: expected 9 arguments for a", f.__name__
        print "Most likely you want to enter \"up<enter>l<enter>\" now to see what happened."
        raise Exception("Grammar Error")
    if args[0] == void:
        pass
    elif isinstance(args[0], tuple) and args[0][0] == primitive_type:
        pass
    elif isinstance(args[0], tuple) and args[0][0] == array:
        pass
    elif isinstance(args[0], tuple) and args[0][0] == scoped_id:
        pass
    else:
        print f.__name__+"():\n    \"\"\"%s\"\"\"\n" %f.__doc__.replace("\\n","\n").replace("\return","Returns").replace("\\c ","")
        print "**GRAMMAR ERROR in argument args[0] = %s"%repr(args[0])
        print "  Most likely you now want to enter \"up<enter>l<enter>\"\n into the debugger to see what happened.\n"
        raise Exception("Grammar Error")
    if isinstance(args[1], tuple) and args[1][0] == method_name:
        pass
    else:
        print f.__name__+"():\n    \"\"\"%s\"\"\"\n" %f.__doc__.replace("\\n","\n").replace("\return","Returns").replace("\\c ","")
        print "**GRAMMAR ERROR in argument args[1] = %s"%repr(args[1])
        print "  Most likely you now want to enter \"up<enter>l<enter>\"\n into the debugger to see what happened.\n"
        raise Exception("Grammar Error")
    if isinstance(args[2], list):
        for a in args[2]:
            if a == oneway:
                pass
            elif a == local:
                pass
            elif a == static:
                pass
            elif a == abstract:
                pass
            elif a == final:
                pass
            elif a == nonblocking:
                pass
            elif a == copy:
                pass
            else:
                print f.__name__+"():\n    \"\"\"%s\"\"\"\n" %f.__doc__.replace("\\n","\n").replace("\return","Returns").replace("\\c ","")
                print "**GRAMMAR ERROR in argument a = %s"%repr(a)
                print "  Most likely you now want to enter \"up<enter>l<enter>\"\n into the debugger to see what happened.\n"
                raise Exception("Grammar Error")
    else:
        print f.__name__+"():\n    \"\"\"%s\"\"\"\n" %f.__doc__.replace("\\n","\n").replace("\return","Returns").replace("\\c ","")
        print "**GRAMMAR ERROR in argument args[2] = %s"%repr(args[2])
        print "  Most likely you now want to enter \"up<enter>l<enter>\"\n into the debugger to see what happened.\n"
        raise Exception("Grammar Error")
    if isinstance(args[3], list):
        for a in args[3]:
            if isinstance(a, tuple) and a[0] == arg:
                pass
            elif isinstance(a, tuple) and a[0] == rarg:
                pass
            else:
                print f.__name__+"():\n    \"\"\"%s\"\"\"\n" %f.__doc__.replace("\\n","\n").replace("\return","Returns").replace("\\c ","")
                print "**GRAMMAR ERROR in argument a = %s"%repr(a)
                print "  Most likely you now want to enter \"up<enter>l<enter>\"\n into the debugger to see what happened.\n"
                raise Exception("Grammar Error")
    else:
        print f.__name__+"():\n    \"\"\"%s\"\"\"\n" %f.__doc__.replace("\\n","\n").replace("\return","Returns").replace("\\c ","")
        print "**GRAMMAR ERROR in argument args[3] = %s"%repr(args[3])
        print "  Most likely you now want to enter \"up<enter>l<enter>\"\n into the debugger to see what happened.\n"
        raise Exception("Grammar Error")
    if isinstance(args[4], list):
        for a in args[4]:
            if isinstance(a, tuple) and a[0] == except_:
                pass
            else:
                print f.__name__+"():\n    \"\"\"%s\"\"\"\n" %f.__doc__.replace("\\n","\n").replace("\return","Returns").replace("\\c ","")
                print "**GRAMMAR ERROR in argument a = %s"%repr(a)
                print "  Most likely you now want to enter \"up<enter>l<enter>\"\n into the debugger to see what happened.\n"
                raise Exception("Grammar Error")
    else:
        print f.__name__+"():\n    \"\"\"%s\"\"\"\n" %f.__doc__.replace("\\n","\n").replace("\return","Returns").replace("\\c ","")
        print "**GRAMMAR ERROR in argument args[4] = %s"%repr(args[4])
        print "  Most likely you now want to enter \"up<enter>l<enter>\"\n into the debugger to see what happened.\n"
        raise Exception("Grammar Error")
    if isinstance(args[5], list):
        for a in args[5]:
            if isinstance(a, tuple) and a[0] == from_:
                pass
            else:
                print f.__name__+"():\n    \"\"\"%s\"\"\"\n" %f.__doc__.replace("\\n","\n").replace("\return","Returns").replace("\\c ","")
                print "**GRAMMAR ERROR in argument a = %s"%repr(a)
                print "  Most likely you now want to enter \"up<enter>l<enter>\"\n into the debugger to see what happened.\n"
                raise Exception("Grammar Error")
    else:
        print f.__name__+"():\n    \"\"\"%s\"\"\"\n" %f.__doc__.replace("\\n","\n").replace("\return","Returns").replace("\\c ","")
        print "**GRAMMAR ERROR in argument args[5] = %s"%repr(args[5])
        print "  Most likely you now want to enter \"up<enter>l<enter>\"\n into the debugger to see what happened.\n"
        raise Exception("Grammar Error")
    if isinstance(args[6], list):
        for a in args[6]:
            if isinstance(a, tuple) and a[0] == require:
                pass
            else:
                print f.__name__+"():\n    \"\"\"%s\"\"\"\n" %f.__doc__.replace("\\n","\n").replace("\return","Returns").replace("\\c ","")
                print "**GRAMMAR ERROR in argument a = %s"%repr(a)
                print "  Most likely you now want to enter \"up<enter>l<enter>\"\n into the debugger to see what happened.\n"
                raise Exception("Grammar Error")
    else:
        print f.__name__+"():\n    \"\"\"%s\"\"\"\n" %f.__doc__.replace("\\n","\n").replace("\return","Returns").replace("\\c ","")
        print "**GRAMMAR ERROR in argument args[6] = %s"%repr(args[6])
        print "  Most likely you now want to enter \"up<enter>l<enter>\"\n into the debugger to see what happened.\n"
        raise Exception("Grammar Error")
    if isinstance(args[7], list):
        for a in args[7]:
            if isinstance(a, tuple) and a[0] == ensure:
                pass
            else:
                print f.__name__+"():\n    \"\"\"%s\"\"\"\n" %f.__doc__.replace("\\n","\n").replace("\return","Returns").replace("\\c ","")
                print "**GRAMMAR ERROR in argument a = %s"%repr(a)
                print "  Most likely you now want to enter \"up<enter>l<enter>\"\n into the debugger to see what happened.\n"
                raise Exception("Grammar Error")
    else:
        print f.__name__+"():\n    \"\"\"%s\"\"\"\n" %f.__doc__.replace("\\n","\n").replace("\return","Returns").replace("\\c ","")
        print "**GRAMMAR ERROR in argument args[7] = %s"%repr(args[7])
        print "  Most likely you now want to enter \"up<enter>l<enter>\"\n into the debugger to see what happened.\n"
        raise Exception("Grammar Error")
    if isinstance(args[8], PythonTypes.StringType):
        pass
    else:
        print f.__name__+"():\n    \"\"\"%s\"\"\"\n" %f.__doc__.replace("\\n","\n").replace("\return","Returns").replace("\\c ","")
        print "**GRAMMAR ERROR in argument args[8] = %s"%repr(args[8])
        print "  Most likely you now want to enter \"up<enter>l<enter>\"\n into the debugger to see what happened.\n"
        raise Exception("Grammar Error")
    return tuple(['method']+list(args))

# skipping \c Method_attr= (oneway|local|static|abstract|final|nonblocking|copy)
# skipping \c Arg= (\c Arg|\c Rarg)
def Except(*args):
    """
    Construct a "except" node. Valid arguments are 
    ([\c Scoped_id()])
    \return (\c "Except", [\c Scoped_id()])
    """
    f = Except
    if len(args) <> 1:
        print "**GRAMMAR ERROR: expected 1 arguments for a", f.__name__
        print "Most likely you want to enter \"up<enter>l<enter>\" now to see what happened."
        raise Exception("Grammar Error")
    if isinstance(args[0], list):
        for a in args[0]:
            if isinstance(a, tuple) and a[0] == scoped_id:
                pass
            else:
                print f.__name__+"():\n    \"\"\"%s\"\"\"\n" %f.__doc__.replace("\\n","\n").replace("\return","Returns").replace("\\c ","")
                print "**GRAMMAR ERROR in argument a = %s"%repr(a)
                print "  Most likely you now want to enter \"up<enter>l<enter>\"\n into the debugger to see what happened.\n"
                raise Exception("Grammar Error")
    else:
        print f.__name__+"():\n    \"\"\"%s\"\"\"\n" %f.__doc__.replace("\\n","\n").replace("\return","Returns").replace("\\c ","")
        print "**GRAMMAR ERROR in argument args[0] = %s"%repr(args[0])
        print "  Most likely you now want to enter \"up<enter>l<enter>\"\n into the debugger to see what happened.\n"
        raise Exception("Grammar Error")
    return tuple(['except']+list(args))

def From(*args):
    """
    Construct a "from" node. Valid arguments are 
    (\c Scoped_id())
    \return (\c "From", \c Scoped_id())
    """
    f = From
    if len(args) <> 1:
        print "**GRAMMAR ERROR: expected 1 arguments for a", f.__name__
        print "Most likely you want to enter \"up<enter>l<enter>\" now to see what happened."
        raise Exception("Grammar Error")
    if isinstance(args[0], tuple) and args[0][0] == scoped_id:
        pass
    else:
        print f.__name__+"():\n    \"\"\"%s\"\"\"\n" %f.__doc__.replace("\\n","\n").replace("\return","Returns").replace("\\c ","")
        print "**GRAMMAR ERROR in argument args[0] = %s"%repr(args[0])
        print "  Most likely you now want to enter \"up<enter>l<enter>\"\n into the debugger to see what happened.\n"
        raise Exception("Grammar Error")
    return tuple(['from']+list(args))

def Ensure(*args):
    """
    Construct a "ensure" node. Valid arguments are 
    ([\c Scoped_id()])
    \return (\c "Ensure", [\c Scoped_id()])
    """
    f = Ensure
    if len(args) <> 1:
        print "**GRAMMAR ERROR: expected 1 arguments for a", f.__name__
        print "Most likely you want to enter \"up<enter>l<enter>\" now to see what happened."
        raise Exception("Grammar Error")
    if isinstance(args[0], list):
        for a in args[0]:
            if isinstance(a, tuple) and a[0] == scoped_id:
                pass
            else:
                print f.__name__+"():\n    \"\"\"%s\"\"\"\n" %f.__doc__.replace("\\n","\n").replace("\return","Returns").replace("\\c ","")
                print "**GRAMMAR ERROR in argument a = %s"%repr(a)
                print "  Most likely you now want to enter \"up<enter>l<enter>\"\n into the debugger to see what happened.\n"
                raise Exception("Grammar Error")
    else:
        print f.__name__+"():\n    \"\"\"%s\"\"\"\n" %f.__doc__.replace("\\n","\n").replace("\return","Returns").replace("\\c ","")
        print "**GRAMMAR ERROR in argument args[0] = %s"%repr(args[0])
        print "  Most likely you now want to enter \"up<enter>l<enter>\"\n into the debugger to see what happened.\n"
        raise Exception("Grammar Error")
    return tuple(['ensure']+list(args))

def Method_name(*args):
    """
    Construct a "method_name" node. Valid arguments are 
    (\c Id(), \c Extension())
    \return (\c "Method_name", \c Id(), \c Extension())
    """
    f = Method_name
    if len(args) <> 2:
        print "**GRAMMAR ERROR: expected 2 arguments for a", f.__name__
        print "Most likely you want to enter \"up<enter>l<enter>\" now to see what happened."
        raise Exception("Grammar Error")
    if isinstance(args[0], PythonTypes.StringType):
        pass
    else:
        print f.__name__+"():\n    \"\"\"%s\"\"\"\n" %f.__doc__.replace("\\n","\n").replace("\return","Returns").replace("\\c ","")
        print "**GRAMMAR ERROR in argument args[0] = %s"%repr(args[0])
        print "  Most likely you now want to enter \"up<enter>l<enter>\"\n into the debugger to see what happened.\n"
        raise Exception("Grammar Error")
    if isinstance(args[1], PythonTypes.StringType):
        pass
    else:
        print f.__name__+"():\n    \"\"\"%s\"\"\"\n" %f.__doc__.replace("\\n","\n").replace("\return","Returns").replace("\\c ","")
        print "**GRAMMAR ERROR in argument args[1] = %s"%repr(args[1])
        print "  Most likely you now want to enter \"up<enter>l<enter>\"\n into the debugger to see what happened.\n"
        raise Exception("Grammar Error")
    return tuple(['method_name']+list(args))

def STR():
    return STR
# skipping \c Type= (\c Primitive_type|\c Array|\c Scoped_id)
def Assertion(*args):
    """
    Construct a "assertion" node. Valid arguments are 
    (\c Id(), \c AssertExpr())
    \return (\c "Assertion", \c Id(), \c AssertExpr())
    """
    f = Assertion
    if len(args) <> 2:
        print "**GRAMMAR ERROR: expected 2 arguments for a", f.__name__
        print "Most likely you want to enter \"up<enter>l<enter>\" now to see what happened."
        raise Exception("Grammar Error")
    if isinstance(args[0], PythonTypes.StringType):
        pass
    else:
        print f.__name__+"():\n    \"\"\"%s\"\"\"\n" %f.__doc__.replace("\\n","\n").replace("\return","Returns").replace("\\c ","")
        print "**GRAMMAR ERROR in argument args[0] = %s"%repr(args[0])
        print "  Most likely you now want to enter \"up<enter>l<enter>\"\n into the debugger to see what happened.\n"
        raise Exception("Grammar Error")
    if isinstance(args[1], tuple) and args[1][0] == infix_expr:
        pass
    elif isinstance(args[1], tuple) and args[1][0] == prefix_expr:
        pass
    elif isinstance(args[1], tuple) and args[1][0] == fn_eval:
        pass
    elif isinstance(args[1], tuple) and args[1][0] == var_ref:
        pass
    elif isinstance(args[1], PythonTypes.StringType):
        pass
    elif isinstance(args[1], PythonTypes.IntType):
        pass
    elif isinstance(args[1], PythonTypes.FloatType):
        pass
    elif isinstance(args[1], PythonTypes.StringType):
        pass
    elif args[1] == pure:
        pass
    elif args[1] == result:
        pass
    elif isinstance(args[1], tuple) and args[1][0] == complex:
        pass
    else:
        print f.__name__+"():\n    \"\"\"%s\"\"\"\n" %f.__doc__.replace("\\n","\n").replace("\return","Returns").replace("\\c ","")
        print "**GRAMMAR ERROR in argument args[1] = %s"%repr(args[1])
        print "  Most likely you now want to enter \"up<enter>l<enter>\"\n into the debugger to see what happened.\n"
        raise Exception("Grammar Error")
    return tuple(['assertion']+list(args))

# skipping \c AssertExpr= (\c Infix_expr|\c Prefix_expr|\c Fn_eval|\c Var_ref|\c Id|\c Literal)
# skipping \c Arg_attr= (copy|[STR])
# skipping \c Mode= (in|out|inout)
def Rarray(*args):
    """
    Construct a "rarray" node. Valid arguments are 
    (\c Primitive_type(), \c Dimension(), \c Id(), \c Extents())
    \return (\c "Rarray", \c Primitive_type(), \c Dimension(), \c Id(), \c Extents())
    """
    f = Rarray
    if len(args) <> 4:
        print "**GRAMMAR ERROR: expected 4 arguments for a", f.__name__
        print "Most likely you want to enter \"up<enter>l<enter>\" now to see what happened."
        raise Exception("Grammar Error")
    if isinstance(args[0], tuple) and args[0][0] == primitive_type:
        pass
    else:
        print f.__name__+"():\n    \"\"\"%s\"\"\"\n" %f.__doc__.replace("\\n","\n").replace("\return","Returns").replace("\\c ","")
        print "**GRAMMAR ERROR in argument args[0] = %s"%repr(args[0])
        print "  Most likely you now want to enter \"up<enter>l<enter>\"\n into the debugger to see what happened.\n"
        raise Exception("Grammar Error")
    if isinstance(args[1], PythonTypes.IntType):
        pass
    else:
        print f.__name__+"():\n    \"\"\"%s\"\"\"\n" %f.__doc__.replace("\\n","\n").replace("\return","Returns").replace("\\c ","")
        print "**GRAMMAR ERROR in argument args[1] = %s"%repr(args[1])
        print "  Most likely you now want to enter \"up<enter>l<enter>\"\n into the debugger to see what happened.\n"
        raise Exception("Grammar Error")
    if isinstance(args[2], PythonTypes.StringType):
        pass
    else:
        print f.__name__+"():\n    \"\"\"%s\"\"\"\n" %f.__doc__.replace("\\n","\n").replace("\return","Returns").replace("\\c ","")
        print "**GRAMMAR ERROR in argument args[2] = %s"%repr(args[2])
        print "  Most likely you now want to enter \"up<enter>l<enter>\"\n into the debugger to see what happened.\n"
        raise Exception("Grammar Error")
    if isinstance(args[3], PythonTypes.IntType):
        pass
    else:
        print f.__name__+"():\n    \"\"\"%s\"\"\"\n" %f.__doc__.replace("\\n","\n").replace("\return","Returns").replace("\\c ","")
        print "**GRAMMAR ERROR in argument args[3] = %s"%repr(args[3])
        print "  Most likely you now want to enter \"up<enter>l<enter>\"\n into the debugger to see what happened.\n"
        raise Exception("Grammar Error")
    return tuple(['rarray']+list(args))

def Array(*args):
    """
    Construct a "array" node. Valid arguments are 
    (\c Scalar_type(), \c Dimension(), \c Orientation())
    \return (\c "Array", \c Scalar_type(), \c Dimension(), \c Orientation())
    """
    f = Array
    if len(args) <> 3:
        print "**GRAMMAR ERROR: expected 3 arguments for a", f.__name__
        print "Most likely you want to enter \"up<enter>l<enter>\" now to see what happened."
        raise Exception("Grammar Error")
    if isinstance(args[0], tuple) and args[0][0] == primitive_type:
        pass
    elif isinstance(args[0], tuple) and args[0][0] == scoped_id:
        pass
    else:
        print f.__name__+"():\n    \"\"\"%s\"\"\"\n" %f.__doc__.replace("\\n","\n").replace("\return","Returns").replace("\\c ","")
        print "**GRAMMAR ERROR in argument args[0] = %s"%repr(args[0])
        print "  Most likely you now want to enter \"up<enter>l<enter>\"\n into the debugger to see what happened.\n"
        raise Exception("Grammar Error")
    if isinstance(args[1], PythonTypes.IntType):
        pass
    else:
        print f.__name__+"():\n    \"\"\"%s\"\"\"\n" %f.__doc__.replace("\\n","\n").replace("\return","Returns").replace("\\c ","")
        print "**GRAMMAR ERROR in argument args[1] = %s"%repr(args[1])
        print "  Most likely you now want to enter \"up<enter>l<enter>\"\n into the debugger to see what happened.\n"
        raise Exception("Grammar Error")
    if args[2] == row_major:
        pass
    elif args[2] == column_major:
        pass
    else:
        print f.__name__+"():\n    \"\"\"%s\"\"\"\n" %f.__doc__.replace("\\n","\n").replace("\return","Returns").replace("\\c ","")
        print "**GRAMMAR ERROR in argument args[2] = %s"%repr(args[2])
        print "  Most likely you now want to enter \"up<enter>l<enter>\"\n into the debugger to see what happened.\n"
        raise Exception("Grammar Error")
    return tuple(['array']+list(args))

def Primitive_type(*args):
    """
    Construct a "primitive_type" node. Valid arguments are 
    (Bool()
    |Char()
    |Int()
    |Long()
    |Float()
    |Double()
    |Fcomplex()
    |Dcomplex()
    |String()
    |Opaque())
    \return (\c "Primitive_type", Bool()
    |Char()
    |Int()
    |Long()
    |Float()
    |Double()
    |Fcomplex()
    |Dcomplex()
    |String()
    |Opaque())
    """
    f = Primitive_type
    if len(args) <> 1:
        print "**GRAMMAR ERROR: expected 1 arguments for a", f.__name__
        print "Most likely you want to enter \"up<enter>l<enter>\" now to see what happened."
        raise Exception("Grammar Error")
    if args[0] == bool:
        pass
    elif args[0] == char:
        pass
    elif args[0] == int:
        pass
    elif args[0] == long:
        pass
    elif args[0] == float:
        pass
    elif args[0] == double:
        pass
    elif args[0] == fcomplex:
        pass
    elif args[0] == dcomplex:
        pass
    elif args[0] == string:
        pass
    elif args[0] == opaque:
        pass
    else:
        print f.__name__+"():\n    \"\"\"%s\"\"\"\n" %f.__doc__.replace("\\n","\n").replace("\return","Returns").replace("\\c ","")
        print "**GRAMMAR ERROR in argument args[0] = %s"%repr(args[0])
        print "  Most likely you now want to enter \"up<enter>l<enter>\"\n into the debugger to see what happened.\n"
        raise Exception("Grammar Error")
    return tuple(['primitive_type']+list(args))

# skipping \c Scalar_type= (\c Primitive_type|\c Scoped_id)
def INT():
    return INT
# skipping \c Orientation= (row_major|column_major)
def INT():
    return INT
def INT():
    return INT
# skipping \c Bin_op= (log_or|log_and|eq|ne|bit_or|bit_and|bit_xor|lt|gt|lshift|rshift|plus|minus|times|divide|modulo|rem|pow)
# skipping \c Un_op= (is|log_not|bit_not)
# skipping \c Literal= (INT|FLOAT|STR|pure|result|\c Complex)
def Complex(*args):
    """
    Construct a "complex" node. Valid arguments are 
    (FLOAT(), FLOAT())
    \return (\c "Complex", FLOAT(), FLOAT())
    """
    f = Complex
    if len(args) <> 2:
        print "**GRAMMAR ERROR: expected 2 arguments for a", f.__name__
        print "Most likely you want to enter \"up<enter>l<enter>\" now to see what happened."
        raise Exception("Grammar Error")
    if isinstance(args[0], PythonTypes.FloatType):
        pass
    else:
        print f.__name__+"():\n    \"\"\"%s\"\"\"\n" %f.__doc__.replace("\\n","\n").replace("\return","Returns").replace("\\c ","")
        print "**GRAMMAR ERROR in argument args[0] = %s"%repr(args[0])
        print "  Most likely you now want to enter \"up<enter>l<enter>\"\n into the debugger to see what happened.\n"
        raise Exception("Grammar Error")
    if isinstance(args[1], PythonTypes.FloatType):
        pass
    else:
        print f.__name__+"():\n    \"\"\"%s\"\"\"\n" %f.__doc__.replace("\\n","\n").replace("\return","Returns").replace("\\c ","")
        print "**GRAMMAR ERROR in argument args[1] = %s"%repr(args[1])
        print "  Most likely you now want to enter \"up<enter>l<enter>\"\n into the debugger to see what happened.\n"
        raise Exception("Grammar Error")
    return tuple(['complex']+list(args))

def Enumerator(*args):
    """
    Construct a "enumerator" node. Valid arguments are 
    (\c Id())
    \return (\c "Enumerator", \c Id())
    """
    f = Enumerator
    if len(args) <> 1:
        print "**GRAMMAR ERROR: expected 1 arguments for a", f.__name__
        print "Most likely you want to enter \"up<enter>l<enter>\" now to see what happened."
        raise Exception("Grammar Error")
    if isinstance(args[0], PythonTypes.StringType):
        pass
    else:
        print f.__name__+"():\n    \"\"\"%s\"\"\"\n" %f.__doc__.replace("\\n","\n").replace("\return","Returns").replace("\\c ","")
        print "**GRAMMAR ERROR in argument args[0] = %s"%repr(args[0])
        print "  Most likely you now want to enter \"up<enter>l<enter>\"\n into the debugger to see what happened.\n"
        raise Exception("Grammar Error")
    return tuple(['enumerator']+list(args))

def Enumerator(*args):
    """
    Construct a "enumerator" node. Valid arguments are 
    (\c Id(), INT())
    \return (\c "Enumerator", \c Id(), INT())
    """
    f = Enumerator
    if len(args) <> 2:
        print "**GRAMMAR ERROR: expected 2 arguments for a", f.__name__
        print "Most likely you want to enter \"up<enter>l<enter>\" now to see what happened."
        raise Exception("Grammar Error")
    if isinstance(args[0], PythonTypes.StringType):
        pass
    else:
        print f.__name__+"():\n    \"\"\"%s\"\"\"\n" %f.__doc__.replace("\\n","\n").replace("\return","Returns").replace("\\c ","")
        print "**GRAMMAR ERROR in argument args[0] = %s"%repr(args[0])
        print "  Most likely you now want to enter \"up<enter>l<enter>\"\n into the debugger to see what happened.\n"
        raise Exception("Grammar Error")
    if isinstance(args[1], PythonTypes.IntType):
        pass
    else:
        print f.__name__+"():\n    \"\"\"%s\"\"\"\n" %f.__doc__.replace("\\n","\n").replace("\return","Returns").replace("\\c ","")
        print "**GRAMMAR ERROR in argument args[1] = %s"%repr(args[1])
        print "  Most likely you now want to enter \"up<enter>l<enter>\"\n into the debugger to see what happened.\n"
        raise Exception("Grammar Error")
    return tuple(['enumerator']+list(args))

def Implements(*args):
    """
    Construct a "implements" node. Valid arguments are 
    (\c Scoped_id())
    \return (\c "Implements", \c Scoped_id())
    """
    f = Implements
    if len(args) <> 1:
        print "**GRAMMAR ERROR: expected 1 arguments for a", f.__name__
        print "Most likely you want to enter \"up<enter>l<enter>\" now to see what happened."
        raise Exception("Grammar Error")
    if isinstance(args[0], tuple) and args[0][0] == scoped_id:
        pass
    else:
        print f.__name__+"():\n    \"\"\"%s\"\"\"\n" %f.__doc__.replace("\\n","\n").replace("\return","Returns").replace("\\c ","")
        print "**GRAMMAR ERROR in argument args[0] = %s"%repr(args[0])
        print "  Most likely you now want to enter \"up<enter>l<enter>\"\n into the debugger to see what happened.\n"
        raise Exception("Grammar Error")
    return tuple(['implements']+list(args))

def Implements_all(*args):
    """
    Construct a "implements_all" node. Valid arguments are 
    (\c Scoped_id())
    \return (\c "Implements_all", \c Scoped_id())
    """
    f = Implements_all
    if len(args) <> 1:
        print "**GRAMMAR ERROR: expected 1 arguments for a", f.__name__
        print "Most likely you want to enter \"up<enter>l<enter>\" now to see what happened."
        raise Exception("Grammar Error")
    if isinstance(args[0], tuple) and args[0][0] == scoped_id:
        pass
    else:
        print f.__name__+"():\n    \"\"\"%s\"\"\"\n" %f.__doc__.replace("\\n","\n").replace("\return","Returns").replace("\\c ","")
        print "**GRAMMAR ERROR in argument args[0] = %s"%repr(args[0])
        print "  Most likely you now want to enter \"up<enter>l<enter>\"\n into the debugger to see what happened.\n"
        raise Exception("Grammar Error")
    return tuple(['implements_all']+list(args))

def Arg(*args):
    """
    Construct a "arg" node. Valid arguments are 
    ([\c Arg_attr()], \c Mode(), \c Type_void(), \c Id())
    \return (\c "Arg", [\c Arg_attr()], \c Mode(), \c Type_void(), \c Id())
    """
    f = Arg
    if len(args) <> 4:
        print "**GRAMMAR ERROR: expected 4 arguments for a", f.__name__
        print "Most likely you want to enter \"up<enter>l<enter>\" now to see what happened."
        raise Exception("Grammar Error")
    if isinstance(args[0], list):
        for a in args[0]:
            if a == copy:
                pass
            elif isinstance(a, list):
                for a in a:
                    if isinstance(a, PythonTypes.StringType):
                        pass
                    else:
                        print f.__name__+"():\n    \"\"\"%s\"\"\"\n" %f.__doc__.replace("\\n","\n").replace("\return","Returns").replace("\\c ","")
                        print "**GRAMMAR ERROR in argument a = %s"%repr(a)
                        print "  Most likely you now want to enter \"up<enter>l<enter>\"\n into the debugger to see what happened.\n"
                        raise Exception("Grammar Error")
            else:
                print f.__name__+"():\n    \"\"\"%s\"\"\"\n" %f.__doc__.replace("\\n","\n").replace("\return","Returns").replace("\\c ","")
                print "**GRAMMAR ERROR in argument a = %s"%repr(a)
                print "  Most likely you now want to enter \"up<enter>l<enter>\"\n into the debugger to see what happened.\n"
                raise Exception("Grammar Error")
    else:
        print f.__name__+"():\n    \"\"\"%s\"\"\"\n" %f.__doc__.replace("\\n","\n").replace("\return","Returns").replace("\\c ","")
        print "**GRAMMAR ERROR in argument args[0] = %s"%repr(args[0])
        print "  Most likely you now want to enter \"up<enter>l<enter>\"\n into the debugger to see what happened.\n"
        raise Exception("Grammar Error")
    if args[1] == in_:
        pass
    elif args[1] == out:
        pass
    elif args[1] == inout:
        pass
    else:
        print f.__name__+"():\n    \"\"\"%s\"\"\"\n" %f.__doc__.replace("\\n","\n").replace("\return","Returns").replace("\\c ","")
        print "**GRAMMAR ERROR in argument args[1] = %s"%repr(args[1])
        print "  Most likely you now want to enter \"up<enter>l<enter>\"\n into the debugger to see what happened.\n"
        raise Exception("Grammar Error")
    if args[2] == void:
        pass
    elif isinstance(args[2], tuple) and args[2][0] == primitive_type:
        pass
    elif isinstance(args[2], tuple) and args[2][0] == array:
        pass
    elif isinstance(args[2], tuple) and args[2][0] == scoped_id:
        pass
    else:
        print f.__name__+"():\n    \"\"\"%s\"\"\"\n" %f.__doc__.replace("\\n","\n").replace("\return","Returns").replace("\\c ","")
        print "**GRAMMAR ERROR in argument args[2] = %s"%repr(args[2])
        print "  Most likely you now want to enter \"up<enter>l<enter>\"\n into the debugger to see what happened.\n"
        raise Exception("Grammar Error")
    if isinstance(args[3], PythonTypes.StringType):
        pass
    else:
        print f.__name__+"():\n    \"\"\"%s\"\"\"\n" %f.__doc__.replace("\\n","\n").replace("\return","Returns").replace("\\c ","")
        print "**GRAMMAR ERROR in argument args[3] = %s"%repr(args[3])
        print "  Most likely you now want to enter \"up<enter>l<enter>\"\n into the debugger to see what happened.\n"
        raise Exception("Grammar Error")
    return tuple(['arg']+list(args))

def Rarg(*args):
    """
    Construct a "rarg" node. Valid arguments are 
    ([\c Arg_attr()], \c Mode(), \c Rarray())
    \return (\c "Rarg", [\c Arg_attr()], \c Mode(), \c Rarray())
    """
    f = Rarg
    if len(args) <> 3:
        print "**GRAMMAR ERROR: expected 3 arguments for a", f.__name__
        print "Most likely you want to enter \"up<enter>l<enter>\" now to see what happened."
        raise Exception("Grammar Error")
    if isinstance(args[0], list):
        for a in args[0]:
            if a == copy:
                pass
            elif isinstance(a, list):
                for a in a:
                    if isinstance(a, PythonTypes.StringType):
                        pass
                    else:
                        print f.__name__+"():\n    \"\"\"%s\"\"\"\n" %f.__doc__.replace("\\n","\n").replace("\return","Returns").replace("\\c ","")
                        print "**GRAMMAR ERROR in argument a = %s"%repr(a)
                        print "  Most likely you now want to enter \"up<enter>l<enter>\"\n into the debugger to see what happened.\n"
                        raise Exception("Grammar Error")
            else:
                print f.__name__+"():\n    \"\"\"%s\"\"\"\n" %f.__doc__.replace("\\n","\n").replace("\return","Returns").replace("\\c ","")
                print "**GRAMMAR ERROR in argument a = %s"%repr(a)
                print "  Most likely you now want to enter \"up<enter>l<enter>\"\n into the debugger to see what happened.\n"
                raise Exception("Grammar Error")
    else:
        print f.__name__+"():\n    \"\"\"%s\"\"\"\n" %f.__doc__.replace("\\n","\n").replace("\return","Returns").replace("\\c ","")
        print "**GRAMMAR ERROR in argument args[0] = %s"%repr(args[0])
        print "  Most likely you now want to enter \"up<enter>l<enter>\"\n into the debugger to see what happened.\n"
        raise Exception("Grammar Error")
    if args[1] == in_:
        pass
    elif args[1] == out:
        pass
    elif args[1] == inout:
        pass
    else:
        print f.__name__+"():\n    \"\"\"%s\"\"\"\n" %f.__doc__.replace("\\n","\n").replace("\return","Returns").replace("\\c ","")
        print "**GRAMMAR ERROR in argument args[1] = %s"%repr(args[1])
        print "  Most likely you now want to enter \"up<enter>l<enter>\"\n into the debugger to see what happened.\n"
        raise Exception("Grammar Error")
    if isinstance(args[2], tuple) and args[2][0] == rarray:
        pass
    else:
        print f.__name__+"():\n    \"\"\"%s\"\"\"\n" %f.__doc__.replace("\\n","\n").replace("\return","Returns").replace("\\c ","")
        print "**GRAMMAR ERROR in argument args[2] = %s"%repr(args[2])
        print "  Most likely you now want to enter \"up<enter>l<enter>\"\n into the debugger to see what happened.\n"
        raise Exception("Grammar Error")
    return tuple(['rarg']+list(args))

def Custom_attribute(*args):
    """
    Construct a "custom_attribute" node. Valid arguments are 
    (STR())
    \return (\c "Custom_attribute", STR())
    """
    f = Custom_attribute
    if len(args) <> 1:
        print "**GRAMMAR ERROR: expected 1 arguments for a", f.__name__
        print "Most likely you want to enter \"up<enter>l<enter>\" now to see what happened."
        raise Exception("Grammar Error")
    if isinstance(args[0], PythonTypes.StringType):
        pass
    else:
        print f.__name__+"():\n    \"\"\"%s\"\"\"\n" %f.__doc__.replace("\\n","\n").replace("\return","Returns").replace("\\c ","")
        print "**GRAMMAR ERROR in argument args[0] = %s"%repr(args[0])
        print "  Most likely you now want to enter \"up<enter>l<enter>\"\n into the debugger to see what happened.\n"
        raise Exception("Grammar Error")
    return tuple(['custom_attribute']+list(args))

def Custom_attribute_assoc(*args):
    """
    Construct a "custom_attribute_assoc" node. Valid arguments are 
    (STR(), STR())
    \return (\c "Custom_attribute_assoc", STR(), STR())
    """
    f = Custom_attribute_assoc
    if len(args) <> 2:
        print "**GRAMMAR ERROR: expected 2 arguments for a", f.__name__
        print "Most likely you want to enter \"up<enter>l<enter>\" now to see what happened."
        raise Exception("Grammar Error")
    if isinstance(args[0], PythonTypes.StringType):
        pass
    else:
        print f.__name__+"():\n    \"\"\"%s\"\"\"\n" %f.__doc__.replace("\\n","\n").replace("\return","Returns").replace("\\c ","")
        print "**GRAMMAR ERROR in argument args[0] = %s"%repr(args[0])
        print "  Most likely you now want to enter \"up<enter>l<enter>\"\n into the debugger to see what happened.\n"
        raise Exception("Grammar Error")
    if isinstance(args[1], PythonTypes.StringType):
        pass
    else:
        print f.__name__+"():\n    \"\"\"%s\"\"\"\n" %f.__doc__.replace("\\n","\n").replace("\return","Returns").replace("\\c ","")
        print "**GRAMMAR ERROR in argument args[1] = %s"%repr(args[1])
        print "  Most likely you now want to enter \"up<enter>l<enter>\"\n into the debugger to see what happened.\n"
        raise Exception("Grammar Error")
    return tuple(['custom_attribute_assoc']+list(args))

def Infix_expr(*args):
    """
    Construct a "infix_expr" node. Valid arguments are 
    (\c Bin_op(), \c AssertExpr(), \c AssertExpr())
    \return (\c "Infix_expr", \c Bin_op(), \c AssertExpr(), \c AssertExpr())
    """
    f = Infix_expr
    if len(args) <> 3:
        print "**GRAMMAR ERROR: expected 3 arguments for a", f.__name__
        print "Most likely you want to enter \"up<enter>l<enter>\" now to see what happened."
        raise Exception("Grammar Error")
    if args[0] == log_or:
        pass
    elif args[0] == log_and:
        pass
    elif args[0] == eq:
        pass
    elif args[0] == ne:
        pass
    elif args[0] == bit_or:
        pass
    elif args[0] == bit_and:
        pass
    elif args[0] == bit_xor:
        pass
    elif args[0] == lt:
        pass
    elif args[0] == gt:
        pass
    elif args[0] == lshift:
        pass
    elif args[0] == rshift:
        pass
    elif args[0] == plus:
        pass
    elif args[0] == minus:
        pass
    elif args[0] == times:
        pass
    elif args[0] == divide:
        pass
    elif args[0] == modulo:
        pass
    elif args[0] == rem:
        pass
    elif args[0] == pow:
        pass
    else:
        print f.__name__+"():\n    \"\"\"%s\"\"\"\n" %f.__doc__.replace("\\n","\n").replace("\return","Returns").replace("\\c ","")
        print "**GRAMMAR ERROR in argument args[0] = %s"%repr(args[0])
        print "  Most likely you now want to enter \"up<enter>l<enter>\"\n into the debugger to see what happened.\n"
        raise Exception("Grammar Error")
    if isinstance(args[1], tuple) and args[1][0] == infix_expr:
        pass
    elif isinstance(args[1], tuple) and args[1][0] == prefix_expr:
        pass
    elif isinstance(args[1], tuple) and args[1][0] == fn_eval:
        pass
    elif isinstance(args[1], tuple) and args[1][0] == var_ref:
        pass
    elif isinstance(args[1], PythonTypes.StringType):
        pass
    elif isinstance(args[1], PythonTypes.IntType):
        pass
    elif isinstance(args[1], PythonTypes.FloatType):
        pass
    elif isinstance(args[1], PythonTypes.StringType):
        pass
    elif args[1] == pure:
        pass
    elif args[1] == result:
        pass
    elif isinstance(args[1], tuple) and args[1][0] == complex:
        pass
    else:
        print f.__name__+"():\n    \"\"\"%s\"\"\"\n" %f.__doc__.replace("\\n","\n").replace("\return","Returns").replace("\\c ","")
        print "**GRAMMAR ERROR in argument args[1] = %s"%repr(args[1])
        print "  Most likely you now want to enter \"up<enter>l<enter>\"\n into the debugger to see what happened.\n"
        raise Exception("Grammar Error")
    if isinstance(args[2], tuple) and args[2][0] == infix_expr:
        pass
    elif isinstance(args[2], tuple) and args[2][0] == prefix_expr:
        pass
    elif isinstance(args[2], tuple) and args[2][0] == fn_eval:
        pass
    elif isinstance(args[2], tuple) and args[2][0] == var_ref:
        pass
    elif isinstance(args[2], PythonTypes.StringType):
        pass
    elif isinstance(args[2], PythonTypes.IntType):
        pass
    elif isinstance(args[2], PythonTypes.FloatType):
        pass
    elif isinstance(args[2], PythonTypes.StringType):
        pass
    elif args[2] == pure:
        pass
    elif args[2] == result:
        pass
    elif isinstance(args[2], tuple) and args[2][0] == complex:
        pass
    else:
        print f.__name__+"():\n    \"\"\"%s\"\"\"\n" %f.__doc__.replace("\\n","\n").replace("\return","Returns").replace("\\c ","")
        print "**GRAMMAR ERROR in argument args[2] = %s"%repr(args[2])
        print "  Most likely you now want to enter \"up<enter>l<enter>\"\n into the debugger to see what happened.\n"
        raise Exception("Grammar Error")
    return tuple(['infix_expr']+list(args))

def Prefix_expr(*args):
    """
    Construct a "prefix_expr" node. Valid arguments are 
    (\c Un_op(), \c AssertExpr())
    \return (\c "Prefix_expr", \c Un_op(), \c AssertExpr())
    """
    f = Prefix_expr
    if len(args) <> 2:
        print "**GRAMMAR ERROR: expected 2 arguments for a", f.__name__
        print "Most likely you want to enter \"up<enter>l<enter>\" now to see what happened."
        raise Exception("Grammar Error")
    if args[0] == is_:
        pass
    elif args[0] == log_not:
        pass
    elif args[0] == bit_not:
        pass
    else:
        print f.__name__+"():\n    \"\"\"%s\"\"\"\n" %f.__doc__.replace("\\n","\n").replace("\return","Returns").replace("\\c ","")
        print "**GRAMMAR ERROR in argument args[0] = %s"%repr(args[0])
        print "  Most likely you now want to enter \"up<enter>l<enter>\"\n into the debugger to see what happened.\n"
        raise Exception("Grammar Error")
    if isinstance(args[1], tuple) and args[1][0] == infix_expr:
        pass
    elif isinstance(args[1], tuple) and args[1][0] == prefix_expr:
        pass
    elif isinstance(args[1], tuple) and args[1][0] == fn_eval:
        pass
    elif isinstance(args[1], tuple) and args[1][0] == var_ref:
        pass
    elif isinstance(args[1], PythonTypes.StringType):
        pass
    elif isinstance(args[1], PythonTypes.IntType):
        pass
    elif isinstance(args[1], PythonTypes.FloatType):
        pass
    elif isinstance(args[1], PythonTypes.StringType):
        pass
    elif args[1] == pure:
        pass
    elif args[1] == result:
        pass
    elif isinstance(args[1], tuple) and args[1][0] == complex:
        pass
    else:
        print f.__name__+"():\n    \"\"\"%s\"\"\"\n" %f.__doc__.replace("\\n","\n").replace("\return","Returns").replace("\\c ","")
        print "**GRAMMAR ERROR in argument args[1] = %s"%repr(args[1])
        print "  Most likely you now want to enter \"up<enter>l<enter>\"\n into the debugger to see what happened.\n"
        raise Exception("Grammar Error")
    return tuple(['prefix_expr']+list(args))

def Fn_eval(*args):
    """
    Construct a "fn_eval" node. Valid arguments are 
    (\c Id(), [\c Arg()])
    \return (\c "Fn_eval", \c Id(), [\c Arg()])
    """
    f = Fn_eval
    if len(args) <> 2:
        print "**GRAMMAR ERROR: expected 2 arguments for a", f.__name__
        print "Most likely you want to enter \"up<enter>l<enter>\" now to see what happened."
        raise Exception("Grammar Error")
    if isinstance(args[0], PythonTypes.StringType):
        pass
    else:
        print f.__name__+"():\n    \"\"\"%s\"\"\"\n" %f.__doc__.replace("\\n","\n").replace("\return","Returns").replace("\\c ","")
        print "**GRAMMAR ERROR in argument args[0] = %s"%repr(args[0])
        print "  Most likely you now want to enter \"up<enter>l<enter>\"\n into the debugger to see what happened.\n"
        raise Exception("Grammar Error")
    if isinstance(args[1], list):
        for a in args[1]:
            if isinstance(a, tuple) and a[0] == arg:
                pass
            elif isinstance(a, tuple) and a[0] == rarg:
                pass
            else:
                print f.__name__+"():\n    \"\"\"%s\"\"\"\n" %f.__doc__.replace("\\n","\n").replace("\return","Returns").replace("\\c ","")
                print "**GRAMMAR ERROR in argument a = %s"%repr(a)
                print "  Most likely you now want to enter \"up<enter>l<enter>\"\n into the debugger to see what happened.\n"
                raise Exception("Grammar Error")
    else:
        print f.__name__+"():\n    \"\"\"%s\"\"\"\n" %f.__doc__.replace("\\n","\n").replace("\return","Returns").replace("\\c ","")
        print "**GRAMMAR ERROR in argument args[1] = %s"%repr(args[1])
        print "  Most likely you now want to enter \"up<enter>l<enter>\"\n into the debugger to see what happened.\n"
        raise Exception("Grammar Error")
    return tuple(['fn_eval']+list(args))

def Var_ref(*args):
    """
    Construct a "var_ref" node. Valid arguments are 
    (\c Id())
    \return (\c "Var_ref", \c Id())
    """
    f = Var_ref
    if len(args) <> 1:
        print "**GRAMMAR ERROR: expected 1 arguments for a", f.__name__
        print "Most likely you want to enter \"up<enter>l<enter>\" now to see what happened."
        raise Exception("Grammar Error")
    if isinstance(args[0], PythonTypes.StringType):
        pass
    else:
        print f.__name__+"():\n    \"\"\"%s\"\"\"\n" %f.__doc__.replace("\\n","\n").replace("\return","Returns").replace("\\c ","")
        print "**GRAMMAR ERROR in argument args[0] = %s"%repr(args[0])
        print "  Most likely you now want to enter \"up<enter>l<enter>\"\n into the debugger to see what happened.\n"
        raise Exception("Grammar Error")
    return tuple(['var_ref']+list(args))

 ## sidl primitive types
pt_bool = Primitive_type(bool)
pt_bool     = Primitive_type(bool)
pt_char     = Primitive_type(char)
pt_int	     = Primitive_type(int)
pt_long     = Primitive_type(long)
pt_float    = Primitive_type(float)
pt_double   = Primitive_type(double)
pt_fcomplex = Primitive_type(fcomplex)
pt_dcomplex = Primitive_type(dcomplex)
pt_string   = Primitive_type(string)
pt_opaque   = Primitive_type(opaque)
def visit_hierarchy(base_class, visit_func, symbol_table, items_visited = []):
    """
    Visit all parent classes and implemented interfaces of
    \c base_class exactly once and invoke visit_func on each
    sidl.class/sidl.interface node.
 
    \arg items_visited         An optional list of nodes
                               to exclude from visiting.
 			       Contains the list of visited
 			       nodes after return.
    """
 
    def h(items_visited, base):
 
 	visit_func(base)
 	items_visited.append(base[1])
 
 	sidl_def = symbol_table[base[1]]
 	if sidl_def:
 	    if class_ == sidl_def[0]:
 		parent_sym = sidl_def[2]
 		if parent_sym and parent_sym[1] not in items_visited:
 		    h(items_visited, parent_sym)
 		for loop_impls in sidl_def[3]:
 		    loop_intfs = loop_impls[1]
 		    for intf_sym in loop_intfs:
 			if intf_sym and intf_sym[1] not in items_visited:
 			    h(items_visited, intf_sym)
 	    elif interface == sidl_def[0]:
 		for parent_intf in sidl_def[2]:
 		    if parent_intf and parent_intf[1] not in items_visited:
 			h(items_visited, parent_intf)
 			    
    if base_class and base_class[1] not in items_visited:
 	h(items_visited, base_class)
def class_id(c): return c[1]
def class_extends(c): return c[2]
def class_implements(c): return c[3]
def class_invariants(c): return c[4]
def class_methods(c): return c[5]
