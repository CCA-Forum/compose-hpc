#!/usr/bin/env python
# -*- python -*-
## @package sidl
# Grammar for the SIDL intermediate representation (IR).
# This is NOT a grammar for SIDL, the language.
#
# Please report bugs to <adrian@llnl.gov>.
#
# \authors <pre>
#
# Copyright (c) 2011, Lawrence Livermore National Security, LLC.
# Produced at the Lawrence Livermore National Laboratory
# Written by Adrian Prantl <adrian@llnl.gov>.
#
# LLNL-CODE-473891.
# All rights reserved.
#
# This file is part of BRAID. For details, see
# http://compose-hpc.sourceforge.net/.
# Please read the COPYRIGHT file for Our Notice and
# for the BSD License.
#
# </pre>
#
#
# <h2>Grammar definition</h2>
#
#\verbatim
# 
# [
#   _File = file([Require], [Import], [User_type]),
#   Version = version('STR' | 'FLOAT' | 'INT'),
#   Require = require(Scoped_id, Version),
#   Import = import(Scoped_id, Version),
#   Package = package(Id, Version, [User_type], Doc_comment),
#   User_type = user_type([(Type_attr|Custom_attr)], Cipse),
#   Cipse = ( Class
# 	  | Interface
# 	  | Package
# 	  | Struct
# 	  | Enum ),
#   Type_attr = (final | abstract),
#   Id = 'STR',
#   Doc_comment = 'STR',
#   Enum = enum(Id, [Enumerator], Doc_comment),
#   Enumerator = ( enumerator(Id) | enumerator(Id, 'INT')),
#   Struct = struct(Scoped_id, [Struct_item]),
#   Struct_item = struct_item(Type_void, Id),
#   Class = class(Id, [Extends], [Implements], [Invariant], [Method], Doc_comment),
#   Interface = interface(Id, [Extends], [Invariant], [Method], Doc_comment),
#   Implements = ( implements(Scoped_id)
# 	       | implements_all(Scoped_id)),
#   Method = method(Type_void, Method_name, [Method_attr], [Arg],
# 		  [Except], [From], [Require], [Ensure], Doc_comment),
#   Method_name = method_name(Id, Extension),
#   Extension = 'STR',
#   Type_void = ( void | Type ),
#   Method_attr = ( oneway
# 		| local
# 		| static
# 		| abstract
# 		| final
# 		| nonblocking
# 		| copy ),
#   From = from(Scoped_id),
#   Invariant = invariant(Assertion),
#   Assertion = assertion(Id, AssertExpr),
#   Except = except([Scoped_id]),
#   Ensure = ensure([Scoped_id]),
#   Extends = extends([Scoped_id]),
#   Arg = ( arg([Arg_attr], Mode, Type_void, Id)
# 	| rarg([Arg_attr], Mode, Rarray) ),
#   Arg_attr = (copy | ['STR']),
#   Custom_attr = ( custom_attribute('STR')
# 		| custom_attribute_assoc('STR', 'STR')
# 		),
#   Mode = (in | out | inout),
#   Type = (Primitive_type | Array | Scoped_id),
#   Primitive_type = primitive_type(
#       bool|char|int|long|float|double|fcomplex|dcomplex|string|opaque),
#   Array = array(Scalar_type, Dimension, Orientation),
#   Scalar_type = (Primitive_type|Scoped_id),
#   Dimension = 'INT',
#   Orientation = (row_major|column_major),
#   Rarray = rarray(Primitive_type, Dimension, Id, Extents),
#   Extents = SimpleIntExpression,
#   SimpleIntExpression = 'INT', % resolved by the parser?
#   AssertExpr = ( infix_expr(Bin_op, AssertExpr, AssertExpr)
# 	       | prefix_expr(Un_op, AssertExpr)
# 	       | fn_eval(Id, [Arg])
# 	       | var_ref(Id)
# 	       | Id
# 	       | Literal
# 	       ),
#   Bin_op = (log_or|log_and|eq|ne|bit_or|bit_and|bit_xor|lt|gt|lshift|rshift
# 	  |plus|minus|times|divide|modulo|rem|pow),
#   Un_op = ( is|log_not|bit_not ),
#   Scoped_id = scoped_id([Id], Extension),
#   Literal = ('INT' | 'FLOAT' | 'STR' | pure | result | Complex),
#   Complex = complex('FLOAT', 'FLOAT')
# ].
#\endverbatim


# Automatically generated by GRAMOLA.
#     ### ### #### ### ###
#     ### DO NOT EDIT! ###
#     ### ### #### ### ###
import types as PythonTypes


## Token definitions

abstract = 'abstract'
arg = 'arg'
array = 'array'
assertion = 'assertion'
bit_and = 'bit_and'
bit_not = 'bit_not'
bit_or = 'bit_or'
bit_xor = 'bit_xor'
bool = 'bool'
char = 'char'
class_ = 'class'
column_major = 'column_major'
complex = 'complex'
copy = 'copy'
custom_attribute = 'custom_attribute'
custom_attribute_assoc = 'custom_attribute_assoc'
dcomplex = 'dcomplex'
divide = 'divide'
double = 'double'
ensure = 'ensure'
enum = 'enum'
enumerator = 'enumerator'
eq = 'eq'
except_ = 'except'
extends = 'extends'
fcomplex = 'fcomplex'
file = 'file'
final = 'final'
float = 'float'
fn_eval = 'fn_eval'
from_ = 'from'
gt = 'gt'
implements = 'implements'
implements_all = 'implements_all'
import_ = 'import'
in_ = 'in'
infix_expr = 'infix_expr'
inout = 'inout'
int = 'int'
interface = 'interface'
invariant = 'invariant'
is_ = 'is'
local = 'local'
log_and = 'log_and'
log_not = 'log_not'
log_or = 'log_or'
long = 'long'
lshift = 'lshift'
lt = 'lt'
method = 'method'
method_name = 'method_name'
minus = 'minus'
modulo = 'modulo'
ne = 'ne'
nonblocking = 'nonblocking'
oneway = 'oneway'
opaque = 'opaque'
out = 'out'
package = 'package'
plus = 'plus'
pow = 'pow'
prefix_expr = 'prefix_expr'
primitive_type = 'primitive_type'
pure = 'pure'
rarg = 'rarg'
rarray = 'rarray'
rem = 'rem'
require = 'require'
result = 'result'
row_major = 'row_major'
rshift = 'rshift'
scoped_id = 'scoped_id'
static = 'static'
string = 'string'
struct = 'struct'
struct_item = 'struct_item'
times = 'times'
user_type = 'user_type'
var_ref = 'var_ref'
version = 'version'
void = 'void'


## Constructor definitions

def Require(*args):
    """
    Construct a "require" node. Valid arguments are 
    (\c Scoped_id(), \c Version())
    \return (\c "Require", \c Scoped_id(), \c Version())
    """
    f = Require
    if len(args) <> 2:
        print "**GRAMMAR ERROR: expected 2 arguments for a", f.__name__
        print "Most likely you want to enter \"up<enter>l<enter>\" now to see what happened."
        raise Exception("Grammar Error")
    if isinstance(args[0], tuple) and args[0][0] == scoped_id:
        pass
    else:
        print f.__name__+"():\n    \"\"\"%s\"\"\"\n" %f.__doc__.replace("\\n","\n").replace("\return","Returns").replace("\\c ","")
        print "**GRAMMAR ERROR in argument args[0] = %s"%repr(args[0])
        print "  Most likely you now want to enter \"up<enter>l<enter>\"\n into the debugger to see what happened.\n"
        raise Exception("Grammar Error")
    if isinstance(args[1], tuple) and args[1][0] == version:
        pass
    else:
        print f.__name__+"():\n    \"\"\"%s\"\"\"\n" %f.__doc__.replace("\\n","\n").replace("\return","Returns").replace("\\c ","")
        print "**GRAMMAR ERROR in argument args[1] = %s"%repr(args[1])
        print "  Most likely you now want to enter \"up<enter>l<enter>\"\n into the debugger to see what happened.\n"
        raise Exception("Grammar Error")
    return tuple(['require']+list(args))

def Import(*args):
    """
    Construct a "import" node. Valid arguments are 
    (\c Scoped_id(), \c Version())
    \return (\c "Import", \c Scoped_id(), \c Version())
    """
    f = Import
    if len(args) <> 2:
        print "**GRAMMAR ERROR: expected 2 arguments for a", f.__name__
        print "Most likely you want to enter \"up<enter>l<enter>\" now to see what happened."
        raise Exception("Grammar Error")
    if isinstance(args[0], tuple) and args[0][0] == scoped_id:
        pass
    else:
        print f.__name__+"():\n    \"\"\"%s\"\"\"\n" %f.__doc__.replace("\\n","\n").replace("\return","Returns").replace("\\c ","")
        print "**GRAMMAR ERROR in argument args[0] = %s"%repr(args[0])
        print "  Most likely you now want to enter \"up<enter>l<enter>\"\n into the debugger to see what happened.\n"
        raise Exception("Grammar Error")
    if isinstance(args[1], tuple) and args[1][0] == version:
        pass
    else:
        print f.__name__+"():\n    \"\"\"%s\"\"\"\n" %f.__doc__.replace("\\n","\n").replace("\return","Returns").replace("\\c ","")
        print "**GRAMMAR ERROR in argument args[1] = %s"%repr(args[1])
        print "  Most likely you now want to enter \"up<enter>l<enter>\"\n into the debugger to see what happened.\n"
        raise Exception("Grammar Error")
    return tuple(['import']+list(args))

def User_type(*args):
    """
    Construct a "user_type" node. Valid arguments are 
    ([\c Type_attr()
    |\c Custom_attr()], \c Cipse())
    \return (\c "User_type", [\c Type_attr()
    |\c Custom_attr()], \c Cipse())
    """
    f = User_type
    if len(args) <> 2:
        print "**GRAMMAR ERROR: expected 2 arguments for a", f.__name__
        print "Most likely you want to enter \"up<enter>l<enter>\" now to see what happened."
        raise Exception("Grammar Error")
    if isinstance(args[0], list):
        for a in args[0]:
            if a == final:
                pass
            elif a == abstract:
                pass
            elif isinstance(a, tuple) and a[0] == custom_attribute:
                pass
            elif isinstance(a, tuple) and a[0] == custom_attribute_assoc:
                pass
            else:
                print f.__name__+"():\n    \"\"\"%s\"\"\"\n" %f.__doc__.replace("\\n","\n").replace("\return","Returns").replace("\\c ","")
                print "**GRAMMAR ERROR in argument a = %s"%repr(a)
                print "  Most likely you now want to enter \"up<enter>l<enter>\"\n into the debugger to see what happened.\n"
                raise Exception("Grammar Error")
    else:
        print f.__name__+"():\n    \"\"\"%s\"\"\"\n" %f.__doc__.replace("\\n","\n").replace("\return","Returns").replace("\\c ","")
        print "**GRAMMAR ERROR in argument args[0] = %s"%repr(args[0])
        print "  Most likely you now want to enter \"up<enter>l<enter>\"\n into the debugger to see what happened.\n"
        raise Exception("Grammar Error")
    if isinstance(args[1], tuple) and args[1][0] == class_:
        pass
    elif isinstance(args[1], tuple) and args[1][0] == interface:
        pass
    elif isinstance(args[1], tuple) and args[1][0] == package:
        pass
    elif isinstance(args[1], tuple) and args[1][0] == struct:
        pass
    elif isinstance(args[1], tuple) and args[1][0] == enum:
        pass
    else:
        print f.__name__+"():\n    \"\"\"%s\"\"\"\n" %f.__doc__.replace("\\n","\n").replace("\return","Returns").replace("\\c ","")
        print "**GRAMMAR ERROR in argument args[1] = %s"%repr(args[1])
        print "  Most likely you now want to enter \"up<enter>l<enter>\"\n into the debugger to see what happened.\n"
        raise Exception("Grammar Error")
    return tuple(['user_type']+list(args))

def File(*args):
    """
    Construct a "file" node. Valid arguments are 
    ([\c Require()], [\c Import()], [\c User_type()])
    \return (\c "_File", [\c Require()], [\c Import()], [\c User_type()])
    """
    f = File
    if len(args) <> 3:
        print "**GRAMMAR ERROR: expected 3 arguments for a", f.__name__
        print "Most likely you want to enter \"up<enter>l<enter>\" now to see what happened."
        raise Exception("Grammar Error")
    if isinstance(args[0], list):
        for a in args[0]:
            if isinstance(a, tuple) and a[0] == require:
                pass
            else:
                print f.__name__+"():\n    \"\"\"%s\"\"\"\n" %f.__doc__.replace("\\n","\n").replace("\return","Returns").replace("\\c ","")
                print "**GRAMMAR ERROR in argument a = %s"%repr(a)
                print "  Most likely you now want to enter \"up<enter>l<enter>\"\n into the debugger to see what happened.\n"
                raise Exception("Grammar Error")
    else:
        print f.__name__+"():\n    \"\"\"%s\"\"\"\n" %f.__doc__.replace("\\n","\n").replace("\return","Returns").replace("\\c ","")
        print "**GRAMMAR ERROR in argument args[0] = %s"%repr(args[0])
        print "  Most likely you now want to enter \"up<enter>l<enter>\"\n into the debugger to see what happened.\n"
        raise Exception("Grammar Error")
    if isinstance(args[1], list):
        for a in args[1]:
            if isinstance(a, tuple) and a[0] == import_:
                pass
            else:
                print f.__name__+"():\n    \"\"\"%s\"\"\"\n" %f.__doc__.replace("\\n","\n").replace("\return","Returns").replace("\\c ","")
                print "**GRAMMAR ERROR in argument a = %s"%repr(a)
                print "  Most likely you now want to enter \"up<enter>l<enter>\"\n into the debugger to see what happened.\n"
                raise Exception("Grammar Error")
    else:
        print f.__name__+"():\n    \"\"\"%s\"\"\"\n" %f.__doc__.replace("\\n","\n").replace("\return","Returns").replace("\\c ","")
        print "**GRAMMAR ERROR in argument args[1] = %s"%repr(args[1])
        print "  Most likely you now want to enter \"up<enter>l<enter>\"\n into the debugger to see what happened.\n"
        raise Exception("Grammar Error")
    if isinstance(args[2], list):
        for a in args[2]:
            if isinstance(a, tuple) and a[0] == user_type:
                pass
            else:
                print f.__name__+"():\n    \"\"\"%s\"\"\"\n" %f.__doc__.replace("\\n","\n").replace("\return","Returns").replace("\\c ","")
                print "**GRAMMAR ERROR in argument a = %s"%repr(a)
                print "  Most likely you now want to enter \"up<enter>l<enter>\"\n into the debugger to see what happened.\n"
                raise Exception("Grammar Error")
    else:
        print f.__name__+"():\n    \"\"\"%s\"\"\"\n" %f.__doc__.replace("\\n","\n").replace("\return","Returns").replace("\\c ","")
        print "**GRAMMAR ERROR in argument args[2] = %s"%repr(args[2])
        print "  Most likely you now want to enter \"up<enter>l<enter>\"\n into the debugger to see what happened.\n"
        raise Exception("Grammar Error")
    return tuple(['file']+list(args))

def Version(*args):
    """
    Construct a "version" node. Valid arguments are 
    (STR()
    |FLOAT()
    |INT())
    \return (\c "Version", STR()
    |FLOAT()
    |INT())
    """
    f = Version
    if len(args) <> 1:
        print "**GRAMMAR ERROR: expected 1 arguments for a", f.__name__
        print "Most likely you want to enter \"up<enter>l<enter>\" now to see what happened."
        raise Exception("Grammar Error")
    if isinstance(args[0], PythonTypes.StringType):
        pass
    elif isinstance(args[0], PythonTypes.FloatType):
        pass
    elif isinstance(args[0], PythonTypes.IntType):
        pass
    else:
        print f.__name__+"():\n    \"\"\"%s\"\"\"\n" %f.__doc__.replace("\\n","\n").replace("\return","Returns").replace("\\c ","")
        print "**GRAMMAR ERROR in argument args[0] = %s"%repr(args[0])
        print "  Most likely you now want to enter \"up<enter>l<enter>\"\n into the debugger to see what happened.\n"
        raise Exception("Grammar Error")
    return tuple(['version']+list(args))

def Scoped_id(*args):
    """
    Construct a "scoped_id" node. Valid arguments are 
    ([\c Id()], \c Extension())
    \return (\c "Scoped_id", [\c Id()], \c Extension())
    """
    f = Scoped_id
    if len(args) <> 2:
        print "**GRAMMAR ERROR: expected 2 arguments for a", f.__name__
        print "Most likely you want to enter \"up<enter>l<enter>\" now to see what happened."
        raise Exception("Grammar Error")
    if isinstance(args[0], list):
        for a in args[0]:
            if isinstance(a, PythonTypes.StringType):
                pass
            else:
                print f.__name__+"():\n    \"\"\"%s\"\"\"\n" %f.__doc__.replace("\\n","\n").replace("\return","Returns").replace("\\c ","")
                print "**GRAMMAR ERROR in argument a = %s"%repr(a)
                print "  Most likely you now want to enter \"up<enter>l<enter>\"\n into the debugger to see what happened.\n"
                raise Exception("Grammar Error")
    else:
        print f.__name__+"():\n    \"\"\"%s\"\"\"\n" %f.__doc__.replace("\\n","\n").replace("\return","Returns").replace("\\c ","")
        print "**GRAMMAR ERROR in argument args[0] = %s"%repr(args[0])
        print "  Most likely you now want to enter \"up<enter>l<enter>\"\n into the debugger to see what happened.\n"
        raise Exception("Grammar Error")
    if isinstance(args[1], PythonTypes.StringType):
        pass
    else:
        print f.__name__+"():\n    \"\"\"%s\"\"\"\n" %f.__doc__.replace("\\n","\n").replace("\return","Returns").replace("\\c ","")
        print "**GRAMMAR ERROR in argument args[1] = %s"%repr(args[1])
        print "  Most likely you now want to enter \"up<enter>l<enter>\"\n into the debugger to see what happened.\n"
        raise Exception("Grammar Error")
    return tuple(['scoped_id']+list(args))

def STR():
    return STR
def STR():
    return STR
def Package(*args):
    """
    Construct a "package" node. Valid arguments are 
    (\c Id(), \c Version(), [\c User_type()], \c Doc_comment())
    \return (\c "Package", \c Id(), \c Version(), [\c User_type()], \c Doc_comment())
    """
    f = Package
    if len(args) <> 4:
        print "**GRAMMAR ERROR: expected 4 arguments for a", f.__name__
        print "Most likely you want to enter \"up<enter>l<enter>\" now to see what happened."
        raise Exception("Grammar Error")
    if isinstance(args[0], PythonTypes.StringType):
        pass
    else:
        print f.__name__+"():\n    \"\"\"%s\"\"\"\n" %f.__doc__.replace("\\n","\n").replace("\return","Returns").replace("\\c ","")
        print "**GRAMMAR ERROR in argument args[0] = %s"%repr(args[0])
        print "  Most likely you now want to enter \"up<enter>l<enter>\"\n into the debugger to see what happened.\n"
        raise Exception("Grammar Error")
    if isinstance(args[1], tuple) and args[1][0] == version:
        pass
    else:
        print f.__name__+"():\n    \"\"\"%s\"\"\"\n" %f.__doc__.replace("\\n","\n").replace("\return","Returns").replace("\\c ","")
        print "**GRAMMAR ERROR in argument args[1] = %s"%repr(args[1])
        print "  Most likely you now want to enter \"up<enter>l<enter>\"\n into the debugger to see what happened.\n"
        raise Exception("Grammar Error")
    if isinstance(args[2], list):
        for a in args[2]:
            if isinstance(a, tuple) and a[0] == user_type:
                pass
            else:
                print f.__name__+"():\n    \"\"\"%s\"\"\"\n" %f.__doc__.replace("\\n","\n").replace("\return","Returns").replace("\\c ","")
                print "**GRAMMAR ERROR in argument a = %s"%repr(a)
                print "  Most likely you now want to enter \"up<enter>l<enter>\"\n into the debugger to see what happened.\n"
                raise Exception("Grammar Error")
    else:
        print f.__name__+"():\n    \"\"\"%s\"\"\"\n" %f.__doc__.replace("\\n","\n").replace("\return","Returns").replace("\\c ","")
        print "**GRAMMAR ERROR in argument args[2] = %s"%repr(args[2])
        print "  Most likely you now want to enter \"up<enter>l<enter>\"\n into the debugger to see what happened.\n"
        raise Exception("Grammar Error")
    if isinstance(args[3], PythonTypes.StringType):
        pass
    else:
        print f.__name__+"():\n    \"\"\"%s\"\"\"\n" %f.__doc__.replace("\\n","\n").replace("\return","Returns").replace("\\c ","")
        print "**GRAMMAR ERROR in argument args[3] = %s"%repr(args[3])
        print "  Most likely you now want to enter \"up<enter>l<enter>\"\n into the debugger to see what happened.\n"
        raise Exception("Grammar Error")
    return tuple(['package']+list(args))

# skipping \c Type_attr= (final|abstract)
# skipping \c Custom_attr= (\c Custom_attribute|\c Custom_attribute_assoc)
# skipping \c Cipse= (\c Class|\c Interface|\c Package|\c Struct|\c Enum)
def Struct(*args):
    """
    Construct a "struct" node. Valid arguments are 
    (\c Scoped_id(), [\c Struct_item()])
    \return (\c "Struct", \c Scoped_id(), [\c Struct_item()])
    """
    f = Struct
    if len(args) <> 2:
        print "**GRAMMAR ERROR: expected 2 arguments for a", f.__name__
        print "Most likely you want to enter \"up<enter>l<enter>\" now to see what happened."
        raise Exception("Grammar Error")
    if isinstance(args[0], tuple) and args[0][0] == scoped_id:
        pass
    else:
        print f.__name__+"():\n    \"\"\"%s\"\"\"\n" %f.__doc__.replace("\\n","\n").replace("\return","Returns").replace("\\c ","")
        print "**GRAMMAR ERROR in argument args[0] = %s"%repr(args[0])
        print "  Most likely you now want to enter \"up<enter>l<enter>\"\n into the debugger to see what happened.\n"
        raise Exception("Grammar Error")
    if isinstance(args[1], list):
        for a in args[1]:
            if isinstance(a, tuple) and a[0] == struct_item:
                pass
            else:
                print f.__name__+"():\n    \"\"\"%s\"\"\"\n" %f.__doc__.replace("\\n","\n").replace("\return","Returns").replace("\\c ","")
                print "**GRAMMAR ERROR in argument a = %s"%repr(a)
                print "  Most likely you now want to enter \"up<enter>l<enter>\"\n into the debugger to see what happened.\n"
                raise Exception("Grammar Error")
    else:
        print f.__name__+"():\n    \"\"\"%s\"\"\"\n" %f.__doc__.replace("\\n","\n").replace("\return","Returns").replace("\\c ","")
        print "**GRAMMAR ERROR in argument args[1] = %s"%repr(args[1])
        print "  Most likely you now want to enter \"up<enter>l<enter>\"\n into the debugger to see what happened.\n"
        raise Exception("Grammar Error")
    return tuple(['struct']+list(args))

def Enum(*args):
    """
    Construct a "enum" node. Valid arguments are 
    (\c Id(), [\c Enumerator()], \c Doc_comment())
    \return (\c "Enum", \c Id(), [\c Enumerator()], \c Doc_comment())
    """
    f = Enum
    if len(args) <> 3:
        print "**GRAMMAR ERROR: expected 3 arguments for a", f.__name__
        print "Most likely you want to enter \"up<enter>l<enter>\" now to see what happened."
        raise Exception("Grammar Error")
    if isinstance(args[0], PythonTypes.StringType):
        pass
    else:
        print f.__name__+"():\n    \"\"\"%s\"\"\"\n" %f.__doc__.replace("\\n","\n").replace("\return","Returns").replace("\\c ","")
        print "**GRAMMAR ERROR in argument args[0] = %s"%repr(args[0])
        print "  Most likely you now want to enter \"up<enter>l<enter>\"\n into the debugger to see what happened.\n"
        raise Exception("Grammar Error")
    if isinstance(args[1], list):
        for a in args[1]:
            if isinstance(a, tuple) and a[0] == enumerator:
                pass
            elif isinstance(a, tuple) and a[0] == enumerator:
                pass
            else:
                print f.__name__+"():\n    \"\"\"%s\"\"\"\n" %f.__doc__.replace("\\n","\n").replace("\return","Returns").replace("\\c ","")
                print "**GRAMMAR ERROR in argument a = %s"%repr(a)
                print "  Most likely you now want to enter \"up<enter>l<enter>\"\n into the debugger to see what happened.\n"
                raise Exception("Grammar Error")
    else:
        print f.__name__+"():\n    \"\"\"%s\"\"\"\n" %f.__doc__.replace("\\n","\n").replace("\return","Returns").replace("\\c ","")
        print "**GRAMMAR ERROR in argument args[1] = %s"%repr(args[1])
        print "  Most likely you now want to enter \"up<enter>l<enter>\"\n into the debugger to see what happened.\n"
        raise Exception("Grammar Error")
    if isinstance(args[2], PythonTypes.StringType):
        pass
    else:
        print f.__name__+"():\n    \"\"\"%s\"\"\"\n" %f.__doc__.replace("\\n","\n").replace("\return","Returns").replace("\\c ","")
        print "**GRAMMAR ERROR in argument args[2] = %s"%repr(args[2])
        print "  Most likely you now want to enter \"up<enter>l<enter>\"\n into the debugger to see what happened.\n"
        raise Exception("Grammar Error")
    return tuple(['enum']+list(args))

def Interface(*args):
    """
    Construct a "interface" node. Valid arguments are 
    (\c Id(), [\c Extends()], [\c Invariant()], [\c Method()], \c Doc_comment())
    \return (\c "Interface", \c Id(), [\c Extends()], [\c Invariant()], [\c Method()], \c Doc_comment())
    """
    f = Interface
    if len(args) <> 5:
        print "**GRAMMAR ERROR: expected 5 arguments for a", f.__name__
        print "Most likely you want to enter \"up<enter>l<enter>\" now to see what happened."
        raise Exception("Grammar Error")
    if isinstance(args[0], PythonTypes.StringType):
        pass
    else:
        print f.__name__+"():\n    \"\"\"%s\"\"\"\n" %f.__doc__.replace("\\n","\n").replace("\return","Returns").replace("\\c ","")
        print "**GRAMMAR ERROR in argument args[0] = %s"%repr(args[0])
        print "  Most likely you now want to enter \"up<enter>l<enter>\"\n into the debugger to see what happened.\n"
        raise Exception("Grammar Error")
    if isinstance(args[1], list):
        for a in args[1]:
            if isinstance(a, tuple) and a[0] == extends:
                pass
            else:
                print f.__name__+"():\n    \"\"\"%s\"\"\"\n" %f.__doc__.replace("\\n","\n").replace("\return","Returns").replace("\\c ","")
                print "**GRAMMAR ERROR in argument a = %s"%repr(a)
                print "  Most likely you now want to enter \"up<enter>l<enter>\"\n into the debugger to see what happened.\n"
                raise Exception("Grammar Error")
    else:
        print f.__name__+"():\n    \"\"\"%s\"\"\"\n" %f.__doc__.replace("\\n","\n").replace("\return","Returns").replace("\\c ","")
        print "**GRAMMAR ERROR in argument args[1] = %s"%repr(args[1])
        print "  Most likely you now want to enter \"up<enter>l<enter>\"\n into the debugger to see what happened.\n"
        raise Exception("Grammar Error")
    if isinstance(args[2], list):
        for a in args[2]:
            if isinstance(a, tuple) and a[0] == invariant:
                pass
            else:
                print f.__name__+"():\n    \"\"\"%s\"\"\"\n" %f.__doc__.replace("\\n","\n").replace("\return","Returns").replace("\\c ","")
                print "**GRAMMAR ERROR in argument a = %s"%repr(a)
                print "  Most likely you now want to enter \"up<enter>l<enter>\"\n into the debugger to see what happened.\n"
                raise Exception("Grammar Error")
    else:
        print f.__name__+"():\n    \"\"\"%s\"\"\"\n" %f.__doc__.replace("\\n","\n").replace("\return","Returns").replace("\\c ","")
        print "**GRAMMAR ERROR in argument args[2] = %s"%repr(args[2])
        print "  Most likely you now want to enter \"up<enter>l<enter>\"\n into the debugger to see what happened.\n"
        raise Exception("Grammar Error")
    if isinstance(args[3], list):
        for a in args[3]:
            if isinstance(a, tuple) and a[0] == method:
                pass
            else:
                print f.__name__+"():\n    \"\"\"%s\"\"\"\n" %f.__doc__.replace("\\n","\n").replace("\return","Returns").replace("\\c ","")
                print "**GRAMMAR ERROR in argument a = %s"%repr(a)
                print "  Most likely you now want to enter \"up<enter>l<enter>\"\n into the debugger to see what happened.\n"
                raise Exception("Grammar Error")
    else:
        print f.__name__+"():\n    \"\"\"%s\"\"\"\n" %f.__doc__.replace("\\n","\n").replace("\return","Returns").replace("\\c ","")
        print "**GRAMMAR ERROR in argument args[3] = %s"%repr(args[3])
        print "  Most likely you now want to enter \"up<enter>l<enter>\"\n into the debugger to see what happened.\n"
        raise Exception("Grammar Error")
    if isinstance(args[4], PythonTypes.StringType):
        pass
    else:
        print f.__name__+"():\n    \"\"\"%s\"\"\"\n" %f.__doc__.replace("\\n","\n").replace("\return","Returns").replace("\\c ","")
        print "**GRAMMAR ERROR in argument args[4] = %s"%repr(args[4])
        print "  Most likely you now want to enter \"up<enter>l<enter>\"\n into the debugger to see what happened.\n"
        raise Exception("Grammar Error")
    return tuple(['interface']+list(args))

def Class(*args):
    """
    Construct a "class" node. Valid arguments are 
    (\c Id(), [\c Extends()], [\c Implements()], [\c Invariant()], [\c Method()], \c Doc_comment())
    \return (\c "Class", \c Id(), [\c Extends()], [\c Implements()], [\c Invariant()], [\c Method()], \c Doc_comment())
    """
    f = Class
    if len(args) <> 6:
        print "**GRAMMAR ERROR: expected 6 arguments for a", f.__name__
        print "Most likely you want to enter \"up<enter>l<enter>\" now to see what happened."
        raise Exception("Grammar Error")
    if isinstance(args[0], PythonTypes.StringType):
        pass
    else:
        print f.__name__+"():\n    \"\"\"%s\"\"\"\n" %f.__doc__.replace("\\n","\n").replace("\return","Returns").replace("\\c ","")
        print "**GRAMMAR ERROR in argument args[0] = %s"%repr(args[0])
        print "  Most likely you now want to enter \"up<enter>l<enter>\"\n into the debugger to see what happened.\n"
        raise Exception("Grammar Error")
    if isinstance(args[1], list):
        for a in args[1]:
            if isinstance(a, tuple) and a[0] == extends:
                pass
            else:
                print f.__name__+"():\n    \"\"\"%s\"\"\"\n" %f.__doc__.replace("\\n","\n").replace("\return","Returns").replace("\\c ","")
                print "**GRAMMAR ERROR in argument a = %s"%repr(a)
                print "  Most likely you now want to enter \"up<enter>l<enter>\"\n into the debugger to see what happened.\n"
                raise Exception("Grammar Error")
    else:
        print f.__name__+"():\n    \"\"\"%s\"\"\"\n" %f.__doc__.replace("\\n","\n").replace("\return","Returns").replace("\\c ","")
        print "**GRAMMAR ERROR in argument args[1] = %s"%repr(args[1])
        print "  Most likely you now want to enter \"up<enter>l<enter>\"\n into the debugger to see what happened.\n"
        raise Exception("Grammar Error")
    if isinstance(args[2], list):
        for a in args[2]:
            if isinstance(a, tuple) and a[0] == implements:
                pass
            elif isinstance(a, tuple) and a[0] == implements_all:
                pass
            else:
                print f.__name__+"():\n    \"\"\"%s\"\"\"\n" %f.__doc__.replace("\\n","\n").replace("\return","Returns").replace("\\c ","")
                print "**GRAMMAR ERROR in argument a = %s"%repr(a)
                print "  Most likely you now want to enter \"up<enter>l<enter>\"\n into the debugger to see what happened.\n"
                raise Exception("Grammar Error")
    else:
        print f.__name__+"():\n    \"\"\"%s\"\"\"\n" %f.__doc__.replace("\\n","\n").replace("\return","Returns").replace("\\c ","")
        print "**GRAMMAR ERROR in argument args[2] = %s"%repr(args[2])
        print "  Most likely you now want to enter \"up<enter>l<enter>\"\n into the debugger to see what happened.\n"
        raise Exception("Grammar Error")
    if isinstance(args[3], list):
        for a in args[3]:
            if isinstance(a, tuple) and a[0] == invariant:
                pass
            else:
                print f.__name__+"():\n    \"\"\"%s\"\"\"\n" %f.__doc__.replace("\\n","\n").replace("\return","Returns").replace("\\c ","")
                print "**GRAMMAR ERROR in argument a = %s"%repr(a)
                print "  Most likely you now want to enter \"up<enter>l<enter>\"\n into the debugger to see what happened.\n"
                raise Exception("Grammar Error")
    else:
        print f.__name__+"():\n    \"\"\"%s\"\"\"\n" %f.__doc__.replace("\\n","\n").replace("\return","Returns").replace("\\c ","")
        print "**GRAMMAR ERROR in argument args[3] = %s"%repr(args[3])
        print "  Most likely you now want to enter \"up<enter>l<enter>\"\n into the debugger to see what happened.\n"
        raise Exception("Grammar Error")
    if isinstance(args[4], list):
        for a in args[4]:
            if isinstance(a, tuple) and a[0] == method:
                pass
            else:
                print f.__name__+"():\n    \"\"\"%s\"\"\"\n" %f.__doc__.replace("\\n","\n").replace("\return","Returns").replace("\\c ","")
                print "**GRAMMAR ERROR in argument a = %s"%repr(a)
                print "  Most likely you now want to enter \"up<enter>l<enter>\"\n into the debugger to see what happened.\n"
                raise Exception("Grammar Error")
    else:
        print f.__name__+"():\n    \"\"\"%s\"\"\"\n" %f.__doc__.replace("\\n","\n").replace("\return","Returns").replace("\\c ","")
        print "**GRAMMAR ERROR in argument args[4] = %s"%repr(args[4])
        print "  Most likely you now want to enter \"up<enter>l<enter>\"\n into the debugger to see what happened.\n"
        raise Exception("Grammar Error")
    if isinstance(args[5], PythonTypes.StringType):
        pass
    else:
        print f.__name__+"():\n    \"\"\"%s\"\"\"\n" %f.__doc__.replace("\\n","\n").replace("\return","Returns").replace("\\c ","")
        print "**GRAMMAR ERROR in argument args[5] = %s"%repr(args[5])
        print "  Most likely you now want to enter \"up<enter>l<enter>\"\n into the debugger to see what happened.\n"
        raise Exception("Grammar Error")
    return tuple(['class']+list(args))

# skipping \c Enumerator= (\c Enumerator|\c Enumerator)
def Struct_item(*args):
    """
    Construct a "struct_item" node. Valid arguments are 
    (\c Type_void(), \c Id())
    \return (\c "Struct_item", \c Type_void(), \c Id())
    """
    f = Struct_item
    if len(args) <> 2:
        print "**GRAMMAR ERROR: expected 2 arguments for a", f.__name__
        print "Most likely you want to enter \"up<enter>l<enter>\" now to see what happened."
        raise Exception("Grammar Error")
    if args[0] == void:
        pass
    elif isinstance(args[0], tuple) and args[0][0] == primitive_type:
        pass
    elif isinstance(args[0], tuple) and args[0][0] == array:
        pass
    elif isinstance(args[0], tuple) and args[0][0] == scoped_id:
        pass
    else:
        print f.__name__+"():\n    \"\"\"%s\"\"\"\n" %f.__doc__.replace("\\n","\n").replace("\return","Returns").replace("\\c ","")
        print "**GRAMMAR ERROR in argument args[0] = %s"%repr(args[0])
        print "  Most likely you now want to enter \"up<enter>l<enter>\"\n into the debugger to see what happened.\n"
        raise Exception("Grammar Error")
    if isinstance(args[1], PythonTypes.StringType):
        pass
    else:
        print f.__name__+"():\n    \"\"\"%s\"\"\"\n" %f.__doc__.replace("\\n","\n").replace("\return","Returns").replace("\\c ","")
        print "**GRAMMAR ERROR in argument args[1] = %s"%repr(args[1])
        print "  Most likely you now want to enter \"up<enter>l<enter>\"\n into the debugger to see what happened.\n"
        raise Exception("Grammar Error")
    return tuple(['struct_item']+list(args))

# skipping \c Type_void= (void|\c Type)
def Extends(*args):
    """
    Construct a "extends" node. Valid arguments are 
    ([\c Scoped_id()])
    \return (\c "Extends", [\c Scoped_id()])
    """
    f = Extends
    if len(args) <> 1:
        print "**GRAMMAR ERROR: expected 1 arguments for a", f.__name__
        print "Most likely you want to enter \"up<enter>l<enter>\" now to see what happened."
        raise Exception("Grammar Error")
    if isinstance(args[0], list):
        for a in args[0]:
            if isinstance(a, tuple) and a[0] == scoped_id:
                pass
            else:
                print f.__name__+"():\n    \"\"\"%s\"\"\"\n" %f.__doc__.replace("\\n","\n").replace("\return","Returns").replace("\\c ","")
                print "**GRAMMAR ERROR in argument a = %s"%repr(a)
                print "  Most likely you now want to enter \"up<enter>l<enter>\"\n into the debugger to see what happened.\n"
                raise Exception("Grammar Error")
    else:
        print f.__name__+"():\n    \"\"\"%s\"\"\"\n" %f.__doc__.replace("\\n","\n").replace("\return","Returns").replace("\\c ","")
        print "**GRAMMAR ERROR in argument args[0] = %s"%repr(args[0])
        print "  Most likely you now want to enter \"up<enter>l<enter>\"\n into the debugger to see what happened.\n"
        raise Exception("Grammar Error")
    return tuple(['extends']+list(args))

# skipping \c Implements= (\c Implements|\c Implements_all)
def Invariant(*args):
    """
    Construct a "invariant" node. Valid arguments are 
    (\c Assertion())
    \return (\c "Invariant", \c Assertion())
    """
    f = Invariant
    if len(args) <> 1:
        print "**GRAMMAR ERROR: expected 1 arguments for a", f.__name__
        print "Most likely you want to enter \"up<enter>l<enter>\" now to see what happened."
        raise Exception("Grammar Error")
    if isinstance(args[0], tuple) and args[0][0] == assertion:
        pass
    else:
        print f.__name__+"():\n    \"\"\"%s\"\"\"\n" %f.__doc__.replace("\\n","\n").replace("\return","Returns").replace("\\c ","")
        print "**GRAMMAR ERROR in argument args[0] = %s"%repr(args[0])
        print "  Most likely you now want to enter \"up<enter>l<enter>\"\n into the debugger to see what happened.\n"
        raise Exception("Grammar Error")
    return tuple(['invariant']+list(args))

def Method(*args):
    """
    Construct a "method" node. Valid arguments are 
    (\c Type_void(), \c Method_name(), [\c Method_attr()], [\c Arg()], [\c Except()], [\c From()], [\c Require()], [\c Ensure()], \c Doc_comment())
    \return (\c "Method", \c Type_void(), \c Method_name(), [\c Method_attr()], [\c Arg()], [\c Except()], [\c From()], [\c Require()], [\c Ensure()], \c Doc_comment())
    """
    f = Method
    if len(args) <> 9:
        print "**GRAMMAR ERROR: expected 9 arguments for a", f.__name__
        print "Most likely you want to enter \"up<enter>l<enter>\" now to see what happened."
        raise Exception("Grammar Error")
    if args[0] == void:
        pass
    elif isinstance(args[0], tuple) and args[0][0] == primitive_type:
        pass
    elif isinstance(args[0], tuple) and args[0][0] == array:
        pass
    elif isinstance(args[0], tuple) and args[0][0] == scoped_id:
        pass
    else:
        print f.__name__+"():\n    \"\"\"%s\"\"\"\n" %f.__doc__.replace("\\n","\n").replace("\return","Returns").replace("\\c ","")
        print "**GRAMMAR ERROR in argument args[0] = %s"%repr(args[0])
        print "  Most likely you now want to enter \"up<enter>l<enter>\"\n into the debugger to see what happened.\n"
        raise Exception("Grammar Error")
    if isinstance(args[1], tuple) and args[1][0] == method_name:
        pass
    else:
        print f.__name__+"():\n    \"\"\"%s\"\"\"\n" %f.__doc__.replace("\\n","\n").replace("\return","Returns").replace("\\c ","")
        print "**GRAMMAR ERROR in argument args[1] = %s"%repr(args[1])
        print "  Most likely you now want to enter \"up<enter>l<enter>\"\n into the debugger to see what happened.\n"
        raise Exception("Grammar Error")
    if isinstance(args[2], list):
        for a in args[2]:
            if a == oneway:
                pass
            elif a == local:
                pass
            elif a == static:
                pass
            elif a == abstract:
                pass
            elif a == final:
                pass
            elif a == nonblocking:
                pass
            elif a == copy:
                pass
            else:
                print f.__name__+"():\n    \"\"\"%s\"\"\"\n" %f.__doc__.replace("\\n","\n").replace("\return","Returns").replace("\\c ","")
                print "**GRAMMAR ERROR in argument a = %s"%repr(a)
                print "  Most likely you now want to enter \"up<enter>l<enter>\"\n into the debugger to see what happened.\n"
                raise Exception("Grammar Error")
    else:
        print f.__name__+"():\n    \"\"\"%s\"\"\"\n" %f.__doc__.replace("\\n","\n").replace("\return","Returns").replace("\\c ","")
        print "**GRAMMAR ERROR in argument args[2] = %s"%repr(args[2])
        print "  Most likely you now want to enter \"up<enter>l<enter>\"\n into the debugger to see what happened.\n"
        raise Exception("Grammar Error")
    if isinstance(args[3], list):
        for a in args[3]:
            if isinstance(a, tuple) and a[0] == arg:
                pass
            elif isinstance(a, tuple) and a[0] == rarg:
                pass
            else:
                print f.__name__+"():\n    \"\"\"%s\"\"\"\n" %f.__doc__.replace("\\n","\n").replace("\return","Returns").replace("\\c ","")
                print "**GRAMMAR ERROR in argument a = %s"%repr(a)
                print "  Most likely you now want to enter \"up<enter>l<enter>\"\n into the debugger to see what happened.\n"
                raise Exception("Grammar Error")
    else:
        print f.__name__+"():\n    \"\"\"%s\"\"\"\n" %f.__doc__.replace("\\n","\n").replace("\return","Returns").replace("\\c ","")
        print "**GRAMMAR ERROR in argument args[3] = %s"%repr(args[3])
        print "  Most likely you now want to enter \"up<enter>l<enter>\"\n into the debugger to see what happened.\n"
        raise Exception("Grammar Error")
    if isinstance(args[4], list):
        for a in args[4]:
            if isinstance(a, tuple) and a[0] == except_:
                pass
            else:
                print f.__name__+"():\n    \"\"\"%s\"\"\"\n" %f.__doc__.replace("\\n","\n").replace("\return","Returns").replace("\\c ","")
                print "**GRAMMAR ERROR in argument a = %s"%repr(a)
                print "  Most likely you now want to enter \"up<enter>l<enter>\"\n into the debugger to see what happened.\n"
                raise Exception("Grammar Error")
    else:
        print f.__name__+"():\n    \"\"\"%s\"\"\"\n" %f.__doc__.replace("\\n","\n").replace("\return","Returns").replace("\\c ","")
        print "**GRAMMAR ERROR in argument args[4] = %s"%repr(args[4])
        print "  Most likely you now want to enter \"up<enter>l<enter>\"\n into the debugger to see what happened.\n"
        raise Exception("Grammar Error")
    if isinstance(args[5], list):
        for a in args[5]:
            if isinstance(a, tuple) and a[0] == from_:
                pass
            else:
                print f.__name__+"():\n    \"\"\"%s\"\"\"\n" %f.__doc__.replace("\\n","\n").replace("\return","Returns").replace("\\c ","")
                print "**GRAMMAR ERROR in argument a = %s"%repr(a)
                print "  Most likely you now want to enter \"up<enter>l<enter>\"\n into the debugger to see what happened.\n"
                raise Exception("Grammar Error")
    else:
        print f.__name__+"():\n    \"\"\"%s\"\"\"\n" %f.__doc__.replace("\\n","\n").replace("\return","Returns").replace("\\c ","")
        print "**GRAMMAR ERROR in argument args[5] = %s"%repr(args[5])
        print "  Most likely you now want to enter \"up<enter>l<enter>\"\n into the debugger to see what happened.\n"
        raise Exception("Grammar Error")
    if isinstance(args[6], list):
        for a in args[6]:
            if isinstance(a, tuple) and a[0] == require:
                pass
            else:
                print f.__name__+"():\n    \"\"\"%s\"\"\"\n" %f.__doc__.replace("\\n","\n").replace("\return","Returns").replace("\\c ","")
                print "**GRAMMAR ERROR in argument a = %s"%repr(a)
                print "  Most likely you now want to enter \"up<enter>l<enter>\"\n into the debugger to see what happened.\n"
                raise Exception("Grammar Error")
    else:
        print f.__name__+"():\n    \"\"\"%s\"\"\"\n" %f.__doc__.replace("\\n","\n").replace("\return","Returns").replace("\\c ","")
        print "**GRAMMAR ERROR in argument args[6] = %s"%repr(args[6])
        print "  Most likely you now want to enter \"up<enter>l<enter>\"\n into the debugger to see what happened.\n"
        raise Exception("Grammar Error")
    if isinstance(args[7], list):
        for a in args[7]:
            if isinstance(a, tuple) and a[0] == ensure:
                pass
            else:
                print f.__name__+"():\n    \"\"\"%s\"\"\"\n" %f.__doc__.replace("\\n","\n").replace("\return","Returns").replace("\\c ","")
                print "**GRAMMAR ERROR in argument a = %s"%repr(a)
                print "  Most likely you now want to enter \"up<enter>l<enter>\"\n into the debugger to see what happened.\n"
                raise Exception("Grammar Error")
    else:
        print f.__name__+"():\n    \"\"\"%s\"\"\"\n" %f.__doc__.replace("\\n","\n").replace("\return","Returns").replace("\\c ","")
        print "**GRAMMAR ERROR in argument args[7] = %s"%repr(args[7])
        print "  Most likely you now want to enter \"up<enter>l<enter>\"\n into the debugger to see what happened.\n"
        raise Exception("Grammar Error")
    if isinstance(args[8], PythonTypes.StringType):
        pass
    else:
        print f.__name__+"():\n    \"\"\"%s\"\"\"\n" %f.__doc__.replace("\\n","\n").replace("\return","Returns").replace("\\c ","")
        print "**GRAMMAR ERROR in argument args[8] = %s"%repr(args[8])
        print "  Most likely you now want to enter \"up<enter>l<enter>\"\n into the debugger to see what happened.\n"
        raise Exception("Grammar Error")
    return tuple(['method']+list(args))

# skipping \c Method_attr= (oneway|local|static|abstract|final|nonblocking|copy)
# skipping \c Arg= (\c Arg|\c Rarg)
def Except(*args):
    """
    Construct a "except" node. Valid arguments are 
    ([\c Scoped_id()])
    \return (\c "Except", [\c Scoped_id()])
    """
    f = Except
    if len(args) <> 1:
        print "**GRAMMAR ERROR: expected 1 arguments for a", f.__name__
        print "Most likely you want to enter \"up<enter>l<enter>\" now to see what happened."
        raise Exception("Grammar Error")
    if isinstance(args[0], list):
        for a in args[0]:
            if isinstance(a, tuple) and a[0] == scoped_id:
                pass
            else:
                print f.__name__+"():\n    \"\"\"%s\"\"\"\n" %f.__doc__.replace("\\n","\n").replace("\return","Returns").replace("\\c ","")
                print "**GRAMMAR ERROR in argument a = %s"%repr(a)
                print "  Most likely you now want to enter \"up<enter>l<enter>\"\n into the debugger to see what happened.\n"
                raise Exception("Grammar Error")
    else:
        print f.__name__+"():\n    \"\"\"%s\"\"\"\n" %f.__doc__.replace("\\n","\n").replace("\return","Returns").replace("\\c ","")
        print "**GRAMMAR ERROR in argument args[0] = %s"%repr(args[0])
        print "  Most likely you now want to enter \"up<enter>l<enter>\"\n into the debugger to see what happened.\n"
        raise Exception("Grammar Error")
    return tuple(['except']+list(args))

def From(*args):
    """
    Construct a "from" node. Valid arguments are 
    (\c Scoped_id())
    \return (\c "From", \c Scoped_id())
    """
    f = From
    if len(args) <> 1:
        print "**GRAMMAR ERROR: expected 1 arguments for a", f.__name__
        print "Most likely you want to enter \"up<enter>l<enter>\" now to see what happened."
        raise Exception("Grammar Error")
    if isinstance(args[0], tuple) and args[0][0] == scoped_id:
        pass
    else:
        print f.__name__+"():\n    \"\"\"%s\"\"\"\n" %f.__doc__.replace("\\n","\n").replace("\return","Returns").replace("\\c ","")
        print "**GRAMMAR ERROR in argument args[0] = %s"%repr(args[0])
        print "  Most likely you now want to enter \"up<enter>l<enter>\"\n into the debugger to see what happened.\n"
        raise Exception("Grammar Error")
    return tuple(['from']+list(args))

def Ensure(*args):
    """
    Construct a "ensure" node. Valid arguments are 
    ([\c Scoped_id()])
    \return (\c "Ensure", [\c Scoped_id()])
    """
    f = Ensure
    if len(args) <> 1:
        print "**GRAMMAR ERROR: expected 1 arguments for a", f.__name__
        print "Most likely you want to enter \"up<enter>l<enter>\" now to see what happened."
        raise Exception("Grammar Error")
    if isinstance(args[0], list):
        for a in args[0]:
            if isinstance(a, tuple) and a[0] == scoped_id:
                pass
            else:
                print f.__name__+"():\n    \"\"\"%s\"\"\"\n" %f.__doc__.replace("\\n","\n").replace("\return","Returns").replace("\\c ","")
                print "**GRAMMAR ERROR in argument a = %s"%repr(a)
                print "  Most likely you now want to enter \"up<enter>l<enter>\"\n into the debugger to see what happened.\n"
                raise Exception("Grammar Error")
    else:
        print f.__name__+"():\n    \"\"\"%s\"\"\"\n" %f.__doc__.replace("\\n","\n").replace("\return","Returns").replace("\\c ","")
        print "**GRAMMAR ERROR in argument args[0] = %s"%repr(args[0])
        print "  Most likely you now want to enter \"up<enter>l<enter>\"\n into the debugger to see what happened.\n"
        raise Exception("Grammar Error")
    return tuple(['ensure']+list(args))

def Method_name(*args):
    """
    Construct a "method_name" node. Valid arguments are 
    (\c Id(), \c Extension())
    \return (\c "Method_name", \c Id(), \c Extension())
    """
    f = Method_name
    if len(args) <> 2:
        print "**GRAMMAR ERROR: expected 2 arguments for a", f.__name__
        print "Most likely you want to enter \"up<enter>l<enter>\" now to see what happened."
        raise Exception("Grammar Error")
    if isinstance(args[0], PythonTypes.StringType):
        pass
    else:
        print f.__name__+"():\n    \"\"\"%s\"\"\"\n" %f.__doc__.replace("\\n","\n").replace("\return","Returns").replace("\\c ","")
        print "**GRAMMAR ERROR in argument args[0] = %s"%repr(args[0])
        print "  Most likely you now want to enter \"up<enter>l<enter>\"\n into the debugger to see what happened.\n"
        raise Exception("Grammar Error")
    if isinstance(args[1], PythonTypes.StringType):
        pass
    else:
        print f.__name__+"():\n    \"\"\"%s\"\"\"\n" %f.__doc__.replace("\\n","\n").replace("\return","Returns").replace("\\c ","")
        print "**GRAMMAR ERROR in argument args[1] = %s"%repr(args[1])
        print "  Most likely you now want to enter \"up<enter>l<enter>\"\n into the debugger to see what happened.\n"
        raise Exception("Grammar Error")
    return tuple(['method_name']+list(args))

def STR():
    return STR
# skipping \c Type= (\c Primitive_type|\c Array|\c Scoped_id)
def Assertion(*args):
    """
    Construct a "assertion" node. Valid arguments are 
    (\c Id(), \c AssertExpr())
    \return (\c "Assertion", \c Id(), \c AssertExpr())
    """
    f = Assertion
    if len(args) <> 2:
        print "**GRAMMAR ERROR: expected 2 arguments for a", f.__name__
        print "Most likely you want to enter \"up<enter>l<enter>\" now to see what happened."
        raise Exception("Grammar Error")
    if isinstance(args[0], PythonTypes.StringType):
        pass
    else:
        print f.__name__+"():\n    \"\"\"%s\"\"\"\n" %f.__doc__.replace("\\n","\n").replace("\return","Returns").replace("\\c ","")
        print "**GRAMMAR ERROR in argument args[0] = %s"%repr(args[0])
        print "  Most likely you now want to enter \"up<enter>l<enter>\"\n into the debugger to see what happened.\n"
        raise Exception("Grammar Error")
    if isinstance(args[1], tuple) and args[1][0] == infix_expr:
        pass
    elif isinstance(args[1], tuple) and args[1][0] == prefix_expr:
        pass
    elif isinstance(args[1], tuple) and args[1][0] == fn_eval:
        pass
    elif isinstance(args[1], tuple) and args[1][0] == var_ref:
        pass
    elif isinstance(args[1], PythonTypes.StringType):
        pass
    elif isinstance(args[1], PythonTypes.IntType):
        pass
    elif isinstance(args[1], PythonTypes.FloatType):
        pass
    elif isinstance(args[1], PythonTypes.StringType):
        pass
    elif args[1] == pure:
        pass
    elif args[1] == result:
        pass
    elif isinstance(args[1], tuple) and args[1][0] == complex:
        pass
    else:
        print f.__name__+"():\n    \"\"\"%s\"\"\"\n" %f.__doc__.replace("\\n","\n").replace("\return","Returns").replace("\\c ","")
        print "**GRAMMAR ERROR in argument args[1] = %s"%repr(args[1])
        print "  Most likely you now want to enter \"up<enter>l<enter>\"\n into the debugger to see what happened.\n"
        raise Exception("Grammar Error")
    return tuple(['assertion']+list(args))

# skipping \c AssertExpr= (\c Infix_expr|\c Prefix_expr|\c Fn_eval|\c Var_ref|\c Id|\c Literal)
# skipping \c Arg_attr= (copy|[STR])
# skipping \c Mode= (in|out|inout)
def Rarray(*args):
    """
    Construct a "rarray" node. Valid arguments are 
    (\c Primitive_type(), \c Dimension(), \c Id(), \c Extents())
    \return (\c "Rarray", \c Primitive_type(), \c Dimension(), \c Id(), \c Extents())
    """
    f = Rarray
    if len(args) <> 4:
        print "**GRAMMAR ERROR: expected 4 arguments for a", f.__name__
        print "Most likely you want to enter \"up<enter>l<enter>\" now to see what happened."
        raise Exception("Grammar Error")
    if isinstance(args[0], tuple) and args[0][0] == primitive_type:
        pass
    else:
        print f.__name__+"():\n    \"\"\"%s\"\"\"\n" %f.__doc__.replace("\\n","\n").replace("\return","Returns").replace("\\c ","")
        print "**GRAMMAR ERROR in argument args[0] = %s"%repr(args[0])
        print "  Most likely you now want to enter \"up<enter>l<enter>\"\n into the debugger to see what happened.\n"
        raise Exception("Grammar Error")
    if isinstance(args[1], PythonTypes.IntType):
        pass
    else:
        print f.__name__+"():\n    \"\"\"%s\"\"\"\n" %f.__doc__.replace("\\n","\n").replace("\return","Returns").replace("\\c ","")
        print "**GRAMMAR ERROR in argument args[1] = %s"%repr(args[1])
        print "  Most likely you now want to enter \"up<enter>l<enter>\"\n into the debugger to see what happened.\n"
        raise Exception("Grammar Error")
    if isinstance(args[2], PythonTypes.StringType):
        pass
    else:
        print f.__name__+"():\n    \"\"\"%s\"\"\"\n" %f.__doc__.replace("\\n","\n").replace("\return","Returns").replace("\\c ","")
        print "**GRAMMAR ERROR in argument args[2] = %s"%repr(args[2])
        print "  Most likely you now want to enter \"up<enter>l<enter>\"\n into the debugger to see what happened.\n"
        raise Exception("Grammar Error")
    if isinstance(args[3], PythonTypes.IntType):
        pass
    else:
        print f.__name__+"():\n    \"\"\"%s\"\"\"\n" %f.__doc__.replace("\\n","\n").replace("\return","Returns").replace("\\c ","")
        print "**GRAMMAR ERROR in argument args[3] = %s"%repr(args[3])
        print "  Most likely you now want to enter \"up<enter>l<enter>\"\n into the debugger to see what happened.\n"
        raise Exception("Grammar Error")
    return tuple(['rarray']+list(args))

def Array(*args):
    """
    Construct a "array" node. Valid arguments are 
    (\c Scalar_type(), \c Dimension(), \c Orientation())
    \return (\c "Array", \c Scalar_type(), \c Dimension(), \c Orientation())
    """
    f = Array
    if len(args) <> 3:
        print "**GRAMMAR ERROR: expected 3 arguments for a", f.__name__
        print "Most likely you want to enter \"up<enter>l<enter>\" now to see what happened."
        raise Exception("Grammar Error")
    if isinstance(args[0], tuple) and args[0][0] == primitive_type:
        pass
    elif isinstance(args[0], tuple) and args[0][0] == scoped_id:
        pass
    else:
        print f.__name__+"():\n    \"\"\"%s\"\"\"\n" %f.__doc__.replace("\\n","\n").replace("\return","Returns").replace("\\c ","")
        print "**GRAMMAR ERROR in argument args[0] = %s"%repr(args[0])
        print "  Most likely you now want to enter \"up<enter>l<enter>\"\n into the debugger to see what happened.\n"
        raise Exception("Grammar Error")
    if isinstance(args[1], PythonTypes.IntType):
        pass
    else:
        print f.__name__+"():\n    \"\"\"%s\"\"\"\n" %f.__doc__.replace("\\n","\n").replace("\return","Returns").replace("\\c ","")
        print "**GRAMMAR ERROR in argument args[1] = %s"%repr(args[1])
        print "  Most likely you now want to enter \"up<enter>l<enter>\"\n into the debugger to see what happened.\n"
        raise Exception("Grammar Error")
    if args[2] == row_major:
        pass
    elif args[2] == column_major:
        pass
    else:
        print f.__name__+"():\n    \"\"\"%s\"\"\"\n" %f.__doc__.replace("\\n","\n").replace("\return","Returns").replace("\\c ","")
        print "**GRAMMAR ERROR in argument args[2] = %s"%repr(args[2])
        print "  Most likely you now want to enter \"up<enter>l<enter>\"\n into the debugger to see what happened.\n"
        raise Exception("Grammar Error")
    return tuple(['array']+list(args))

def Primitive_type(*args):
    """
    Construct a "primitive_type" node. Valid arguments are 
    (Bool()
    |Char()
    |Int()
    |Long()
    |Float()
    |Double()
    |Fcomplex()
    |Dcomplex()
    |String()
    |Opaque())
    \return (\c "Primitive_type", Bool()
    |Char()
    |Int()
    |Long()
    |Float()
    |Double()
    |Fcomplex()
    |Dcomplex()
    |String()
    |Opaque())
    """
    f = Primitive_type
    if len(args) <> 1:
        print "**GRAMMAR ERROR: expected 1 arguments for a", f.__name__
        print "Most likely you want to enter \"up<enter>l<enter>\" now to see what happened."
        raise Exception("Grammar Error")
    if args[0] == bool:
        pass
    elif args[0] == char:
        pass
    elif args[0] == int:
        pass
    elif args[0] == long:
        pass
    elif args[0] == float:
        pass
    elif args[0] == double:
        pass
    elif args[0] == fcomplex:
        pass
    elif args[0] == dcomplex:
        pass
    elif args[0] == string:
        pass
    elif args[0] == opaque:
        pass
    else:
        print f.__name__+"():\n    \"\"\"%s\"\"\"\n" %f.__doc__.replace("\\n","\n").replace("\return","Returns").replace("\\c ","")
        print "**GRAMMAR ERROR in argument args[0] = %s"%repr(args[0])
        print "  Most likely you now want to enter \"up<enter>l<enter>\"\n into the debugger to see what happened.\n"
        raise Exception("Grammar Error")
    return tuple(['primitive_type']+list(args))

# skipping \c Scalar_type= (\c Primitive_type|\c Scoped_id)
def INT():
    return INT
# skipping \c Orientation= (row_major|column_major)
def INT():
    return INT
def INT():
    return INT
# skipping \c Bin_op= (log_or|log_and|eq|ne|bit_or|bit_and|bit_xor|lt|gt|lshift|rshift|plus|minus|times|divide|modulo|rem|pow)
# skipping \c Un_op= (is|log_not|bit_not)
# skipping \c Literal= (INT|FLOAT|STR|pure|result|\c Complex)
def Complex(*args):
    """
    Construct a "complex" node. Valid arguments are 
    (FLOAT(), FLOAT())
    \return (\c "Complex", FLOAT(), FLOAT())
    """
    f = Complex
    if len(args) <> 2:
        print "**GRAMMAR ERROR: expected 2 arguments for a", f.__name__
        print "Most likely you want to enter \"up<enter>l<enter>\" now to see what happened."
        raise Exception("Grammar Error")
    if isinstance(args[0], PythonTypes.FloatType):
        pass
    else:
        print f.__name__+"():\n    \"\"\"%s\"\"\"\n" %f.__doc__.replace("\\n","\n").replace("\return","Returns").replace("\\c ","")
        print "**GRAMMAR ERROR in argument args[0] = %s"%repr(args[0])
        print "  Most likely you now want to enter \"up<enter>l<enter>\"\n into the debugger to see what happened.\n"
        raise Exception("Grammar Error")
    if isinstance(args[1], PythonTypes.FloatType):
        pass
    else:
        print f.__name__+"():\n    \"\"\"%s\"\"\"\n" %f.__doc__.replace("\\n","\n").replace("\return","Returns").replace("\\c ","")
        print "**GRAMMAR ERROR in argument args[1] = %s"%repr(args[1])
        print "  Most likely you now want to enter \"up<enter>l<enter>\"\n into the debugger to see what happened.\n"
        raise Exception("Grammar Error")
    return tuple(['complex']+list(args))

def Enumerator(*args):
    """
    Construct a "enumerator" node. Valid arguments are 
    (\c Id())
    \return (\c "Enumerator", \c Id())
    """
    f = Enumerator
    if len(args) <> 1:
        print "**GRAMMAR ERROR: expected 1 arguments for a", f.__name__
        print "Most likely you want to enter \"up<enter>l<enter>\" now to see what happened."
        raise Exception("Grammar Error")
    if isinstance(args[0], PythonTypes.StringType):
        pass
    else:
        print f.__name__+"():\n    \"\"\"%s\"\"\"\n" %f.__doc__.replace("\\n","\n").replace("\return","Returns").replace("\\c ","")
        print "**GRAMMAR ERROR in argument args[0] = %s"%repr(args[0])
        print "  Most likely you now want to enter \"up<enter>l<enter>\"\n into the debugger to see what happened.\n"
        raise Exception("Grammar Error")
    return tuple(['enumerator']+list(args))

def Enumerator(*args):
    """
    Construct a "enumerator" node. Valid arguments are 
    (\c Id(), INT())
    \return (\c "Enumerator", \c Id(), INT())
    """
    f = Enumerator
    if len(args) <> 2:
        print "**GRAMMAR ERROR: expected 2 arguments for a", f.__name__
        print "Most likely you want to enter \"up<enter>l<enter>\" now to see what happened."
        raise Exception("Grammar Error")
    if isinstance(args[0], PythonTypes.StringType):
        pass
    else:
        print f.__name__+"():\n    \"\"\"%s\"\"\"\n" %f.__doc__.replace("\\n","\n").replace("\return","Returns").replace("\\c ","")
        print "**GRAMMAR ERROR in argument args[0] = %s"%repr(args[0])
        print "  Most likely you now want to enter \"up<enter>l<enter>\"\n into the debugger to see what happened.\n"
        raise Exception("Grammar Error")
    if isinstance(args[1], PythonTypes.IntType):
        pass
    else:
        print f.__name__+"():\n    \"\"\"%s\"\"\"\n" %f.__doc__.replace("\\n","\n").replace("\return","Returns").replace("\\c ","")
        print "**GRAMMAR ERROR in argument args[1] = %s"%repr(args[1])
        print "  Most likely you now want to enter \"up<enter>l<enter>\"\n into the debugger to see what happened.\n"
        raise Exception("Grammar Error")
    return tuple(['enumerator']+list(args))

def Implements(*args):
    """
    Construct a "implements" node. Valid arguments are 
    (\c Scoped_id())
    \return (\c "Implements", \c Scoped_id())
    """
    f = Implements
    if len(args) <> 1:
        print "**GRAMMAR ERROR: expected 1 arguments for a", f.__name__
        print "Most likely you want to enter \"up<enter>l<enter>\" now to see what happened."
        raise Exception("Grammar Error")
    if isinstance(args[0], tuple) and args[0][0] == scoped_id:
        pass
    else:
        print f.__name__+"():\n    \"\"\"%s\"\"\"\n" %f.__doc__.replace("\\n","\n").replace("\return","Returns").replace("\\c ","")
        print "**GRAMMAR ERROR in argument args[0] = %s"%repr(args[0])
        print "  Most likely you now want to enter \"up<enter>l<enter>\"\n into the debugger to see what happened.\n"
        raise Exception("Grammar Error")
    return tuple(['implements']+list(args))

def Implements_all(*args):
    """
    Construct a "implements_all" node. Valid arguments are 
    (\c Scoped_id())
    \return (\c "Implements_all", \c Scoped_id())
    """
    f = Implements_all
    if len(args) <> 1:
        print "**GRAMMAR ERROR: expected 1 arguments for a", f.__name__
        print "Most likely you want to enter \"up<enter>l<enter>\" now to see what happened."
        raise Exception("Grammar Error")
    if isinstance(args[0], tuple) and args[0][0] == scoped_id:
        pass
    else:
        print f.__name__+"():\n    \"\"\"%s\"\"\"\n" %f.__doc__.replace("\\n","\n").replace("\return","Returns").replace("\\c ","")
        print "**GRAMMAR ERROR in argument args[0] = %s"%repr(args[0])
        print "  Most likely you now want to enter \"up<enter>l<enter>\"\n into the debugger to see what happened.\n"
        raise Exception("Grammar Error")
    return tuple(['implements_all']+list(args))

def Arg(*args):
    """
    Construct a "arg" node. Valid arguments are 
    ([\c Arg_attr()], \c Mode(), \c Type_void(), \c Id())
    \return (\c "Arg", [\c Arg_attr()], \c Mode(), \c Type_void(), \c Id())
    """
    f = Arg
    if len(args) <> 4:
        print "**GRAMMAR ERROR: expected 4 arguments for a", f.__name__
        print "Most likely you want to enter \"up<enter>l<enter>\" now to see what happened."
        raise Exception("Grammar Error")
    if isinstance(args[0], list):
        for a in args[0]:
            if a == copy:
                pass
            elif isinstance(a, list):
                for a in a:
                    if isinstance(a, PythonTypes.StringType):
                        pass
                    else:
                        print f.__name__+"():\n    \"\"\"%s\"\"\"\n" %f.__doc__.replace("\\n","\n").replace("\return","Returns").replace("\\c ","")
                        print "**GRAMMAR ERROR in argument a = %s"%repr(a)
                        print "  Most likely you now want to enter \"up<enter>l<enter>\"\n into the debugger to see what happened.\n"
                        raise Exception("Grammar Error")
            else:
                print f.__name__+"():\n    \"\"\"%s\"\"\"\n" %f.__doc__.replace("\\n","\n").replace("\return","Returns").replace("\\c ","")
                print "**GRAMMAR ERROR in argument a = %s"%repr(a)
                print "  Most likely you now want to enter \"up<enter>l<enter>\"\n into the debugger to see what happened.\n"
                raise Exception("Grammar Error")
    else:
        print f.__name__+"():\n    \"\"\"%s\"\"\"\n" %f.__doc__.replace("\\n","\n").replace("\return","Returns").replace("\\c ","")
        print "**GRAMMAR ERROR in argument args[0] = %s"%repr(args[0])
        print "  Most likely you now want to enter \"up<enter>l<enter>\"\n into the debugger to see what happened.\n"
        raise Exception("Grammar Error")
    if args[1] == in_:
        pass
    elif args[1] == out:
        pass
    elif args[1] == inout:
        pass
    else:
        print f.__name__+"():\n    \"\"\"%s\"\"\"\n" %f.__doc__.replace("\\n","\n").replace("\return","Returns").replace("\\c ","")
        print "**GRAMMAR ERROR in argument args[1] = %s"%repr(args[1])
        print "  Most likely you now want to enter \"up<enter>l<enter>\"\n into the debugger to see what happened.\n"
        raise Exception("Grammar Error")
    if args[2] == void:
        pass
    elif isinstance(args[2], tuple) and args[2][0] == primitive_type:
        pass
    elif isinstance(args[2], tuple) and args[2][0] == array:
        pass
    elif isinstance(args[2], tuple) and args[2][0] == scoped_id:
        pass
    else:
        print f.__name__+"():\n    \"\"\"%s\"\"\"\n" %f.__doc__.replace("\\n","\n").replace("\return","Returns").replace("\\c ","")
        print "**GRAMMAR ERROR in argument args[2] = %s"%repr(args[2])
        print "  Most likely you now want to enter \"up<enter>l<enter>\"\n into the debugger to see what happened.\n"
        raise Exception("Grammar Error")
    if isinstance(args[3], PythonTypes.StringType):
        pass
    else:
        print f.__name__+"():\n    \"\"\"%s\"\"\"\n" %f.__doc__.replace("\\n","\n").replace("\return","Returns").replace("\\c ","")
        print "**GRAMMAR ERROR in argument args[3] = %s"%repr(args[3])
        print "  Most likely you now want to enter \"up<enter>l<enter>\"\n into the debugger to see what happened.\n"
        raise Exception("Grammar Error")
    return tuple(['arg']+list(args))

def Rarg(*args):
    """
    Construct a "rarg" node. Valid arguments are 
    ([\c Arg_attr()], \c Mode(), \c Rarray())
    \return (\c "Rarg", [\c Arg_attr()], \c Mode(), \c Rarray())
    """
    f = Rarg
    if len(args) <> 3:
        print "**GRAMMAR ERROR: expected 3 arguments for a", f.__name__
        print "Most likely you want to enter \"up<enter>l<enter>\" now to see what happened."
        raise Exception("Grammar Error")
    if isinstance(args[0], list):
        for a in args[0]:
            if a == copy:
                pass
            elif isinstance(a, list):
                for a in a:
                    if isinstance(a, PythonTypes.StringType):
                        pass
                    else:
                        print f.__name__+"():\n    \"\"\"%s\"\"\"\n" %f.__doc__.replace("\\n","\n").replace("\return","Returns").replace("\\c ","")
                        print "**GRAMMAR ERROR in argument a = %s"%repr(a)
                        print "  Most likely you now want to enter \"up<enter>l<enter>\"\n into the debugger to see what happened.\n"
                        raise Exception("Grammar Error")
            else:
                print f.__name__+"():\n    \"\"\"%s\"\"\"\n" %f.__doc__.replace("\\n","\n").replace("\return","Returns").replace("\\c ","")
                print "**GRAMMAR ERROR in argument a = %s"%repr(a)
                print "  Most likely you now want to enter \"up<enter>l<enter>\"\n into the debugger to see what happened.\n"
                raise Exception("Grammar Error")
    else:
        print f.__name__+"():\n    \"\"\"%s\"\"\"\n" %f.__doc__.replace("\\n","\n").replace("\return","Returns").replace("\\c ","")
        print "**GRAMMAR ERROR in argument args[0] = %s"%repr(args[0])
        print "  Most likely you now want to enter \"up<enter>l<enter>\"\n into the debugger to see what happened.\n"
        raise Exception("Grammar Error")
    if args[1] == in_:
        pass
    elif args[1] == out:
        pass
    elif args[1] == inout:
        pass
    else:
        print f.__name__+"():\n    \"\"\"%s\"\"\"\n" %f.__doc__.replace("\\n","\n").replace("\return","Returns").replace("\\c ","")
        print "**GRAMMAR ERROR in argument args[1] = %s"%repr(args[1])
        print "  Most likely you now want to enter \"up<enter>l<enter>\"\n into the debugger to see what happened.\n"
        raise Exception("Grammar Error")
    if isinstance(args[2], tuple) and args[2][0] == rarray:
        pass
    else:
        print f.__name__+"():\n    \"\"\"%s\"\"\"\n" %f.__doc__.replace("\\n","\n").replace("\return","Returns").replace("\\c ","")
        print "**GRAMMAR ERROR in argument args[2] = %s"%repr(args[2])
        print "  Most likely you now want to enter \"up<enter>l<enter>\"\n into the debugger to see what happened.\n"
        raise Exception("Grammar Error")
    return tuple(['rarg']+list(args))

def Custom_attribute(*args):
    """
    Construct a "custom_attribute" node. Valid arguments are 
    (STR())
    \return (\c "Custom_attribute", STR())
    """
    f = Custom_attribute
    if len(args) <> 1:
        print "**GRAMMAR ERROR: expected 1 arguments for a", f.__name__
        print "Most likely you want to enter \"up<enter>l<enter>\" now to see what happened."
        raise Exception("Grammar Error")
    if isinstance(args[0], PythonTypes.StringType):
        pass
    else:
        print f.__name__+"():\n    \"\"\"%s\"\"\"\n" %f.__doc__.replace("\\n","\n").replace("\return","Returns").replace("\\c ","")
        print "**GRAMMAR ERROR in argument args[0] = %s"%repr(args[0])
        print "  Most likely you now want to enter \"up<enter>l<enter>\"\n into the debugger to see what happened.\n"
        raise Exception("Grammar Error")
    return tuple(['custom_attribute']+list(args))

def Custom_attribute_assoc(*args):
    """
    Construct a "custom_attribute_assoc" node. Valid arguments are 
    (STR(), STR())
    \return (\c "Custom_attribute_assoc", STR(), STR())
    """
    f = Custom_attribute_assoc
    if len(args) <> 2:
        print "**GRAMMAR ERROR: expected 2 arguments for a", f.__name__
        print "Most likely you want to enter \"up<enter>l<enter>\" now to see what happened."
        raise Exception("Grammar Error")
    if isinstance(args[0], PythonTypes.StringType):
        pass
    else:
        print f.__name__+"():\n    \"\"\"%s\"\"\"\n" %f.__doc__.replace("\\n","\n").replace("\return","Returns").replace("\\c ","")
        print "**GRAMMAR ERROR in argument args[0] = %s"%repr(args[0])
        print "  Most likely you now want to enter \"up<enter>l<enter>\"\n into the debugger to see what happened.\n"
        raise Exception("Grammar Error")
    if isinstance(args[1], PythonTypes.StringType):
        pass
    else:
        print f.__name__+"():\n    \"\"\"%s\"\"\"\n" %f.__doc__.replace("\\n","\n").replace("\return","Returns").replace("\\c ","")
        print "**GRAMMAR ERROR in argument args[1] = %s"%repr(args[1])
        print "  Most likely you now want to enter \"up<enter>l<enter>\"\n into the debugger to see what happened.\n"
        raise Exception("Grammar Error")
    return tuple(['custom_attribute_assoc']+list(args))

def Infix_expr(*args):
    """
    Construct a "infix_expr" node. Valid arguments are 
    (\c Bin_op(), \c AssertExpr(), \c AssertExpr())
    \return (\c "Infix_expr", \c Bin_op(), \c AssertExpr(), \c AssertExpr())
    """
    f = Infix_expr
    if len(args) <> 3:
        print "**GRAMMAR ERROR: expected 3 arguments for a", f.__name__
        print "Most likely you want to enter \"up<enter>l<enter>\" now to see what happened."
        raise Exception("Grammar Error")
    if args[0] == log_or:
        pass
    elif args[0] == log_and:
        pass
    elif args[0] == eq:
        pass
    elif args[0] == ne:
        pass
    elif args[0] == bit_or:
        pass
    elif args[0] == bit_and:
        pass
    elif args[0] == bit_xor:
        pass
    elif args[0] == lt:
        pass
    elif args[0] == gt:
        pass
    elif args[0] == lshift:
        pass
    elif args[0] == rshift:
        pass
    elif args[0] == plus:
        pass
    elif args[0] == minus:
        pass
    elif args[0] == times:
        pass
    elif args[0] == divide:
        pass
    elif args[0] == modulo:
        pass
    elif args[0] == rem:
        pass
    elif args[0] == pow:
        pass
    else:
        print f.__name__+"():\n    \"\"\"%s\"\"\"\n" %f.__doc__.replace("\\n","\n").replace("\return","Returns").replace("\\c ","")
        print "**GRAMMAR ERROR in argument args[0] = %s"%repr(args[0])
        print "  Most likely you now want to enter \"up<enter>l<enter>\"\n into the debugger to see what happened.\n"
        raise Exception("Grammar Error")
    if isinstance(args[1], tuple) and args[1][0] == infix_expr:
        pass
    elif isinstance(args[1], tuple) and args[1][0] == prefix_expr:
        pass
    elif isinstance(args[1], tuple) and args[1][0] == fn_eval:
        pass
    elif isinstance(args[1], tuple) and args[1][0] == var_ref:
        pass
    elif isinstance(args[1], PythonTypes.StringType):
        pass
    elif isinstance(args[1], PythonTypes.IntType):
        pass
    elif isinstance(args[1], PythonTypes.FloatType):
        pass
    elif isinstance(args[1], PythonTypes.StringType):
        pass
    elif args[1] == pure:
        pass
    elif args[1] == result:
        pass
    elif isinstance(args[1], tuple) and args[1][0] == complex:
        pass
    else:
        print f.__name__+"():\n    \"\"\"%s\"\"\"\n" %f.__doc__.replace("\\n","\n").replace("\return","Returns").replace("\\c ","")
        print "**GRAMMAR ERROR in argument args[1] = %s"%repr(args[1])
        print "  Most likely you now want to enter \"up<enter>l<enter>\"\n into the debugger to see what happened.\n"
        raise Exception("Grammar Error")
    if isinstance(args[2], tuple) and args[2][0] == infix_expr:
        pass
    elif isinstance(args[2], tuple) and args[2][0] == prefix_expr:
        pass
    elif isinstance(args[2], tuple) and args[2][0] == fn_eval:
        pass
    elif isinstance(args[2], tuple) and args[2][0] == var_ref:
        pass
    elif isinstance(args[2], PythonTypes.StringType):
        pass
    elif isinstance(args[2], PythonTypes.IntType):
        pass
    elif isinstance(args[2], PythonTypes.FloatType):
        pass
    elif isinstance(args[2], PythonTypes.StringType):
        pass
    elif args[2] == pure:
        pass
    elif args[2] == result:
        pass
    elif isinstance(args[2], tuple) and args[2][0] == complex:
        pass
    else:
        print f.__name__+"():\n    \"\"\"%s\"\"\"\n" %f.__doc__.replace("\\n","\n").replace("\return","Returns").replace("\\c ","")
        print "**GRAMMAR ERROR in argument args[2] = %s"%repr(args[2])
        print "  Most likely you now want to enter \"up<enter>l<enter>\"\n into the debugger to see what happened.\n"
        raise Exception("Grammar Error")
    return tuple(['infix_expr']+list(args))

def Prefix_expr(*args):
    """
    Construct a "prefix_expr" node. Valid arguments are 
    (\c Un_op(), \c AssertExpr())
    \return (\c "Prefix_expr", \c Un_op(), \c AssertExpr())
    """
    f = Prefix_expr
    if len(args) <> 2:
        print "**GRAMMAR ERROR: expected 2 arguments for a", f.__name__
        print "Most likely you want to enter \"up<enter>l<enter>\" now to see what happened."
        raise Exception("Grammar Error")
    if args[0] == is_:
        pass
    elif args[0] == log_not:
        pass
    elif args[0] == bit_not:
        pass
    else:
        print f.__name__+"():\n    \"\"\"%s\"\"\"\n" %f.__doc__.replace("\\n","\n").replace("\return","Returns").replace("\\c ","")
        print "**GRAMMAR ERROR in argument args[0] = %s"%repr(args[0])
        print "  Most likely you now want to enter \"up<enter>l<enter>\"\n into the debugger to see what happened.\n"
        raise Exception("Grammar Error")
    if isinstance(args[1], tuple) and args[1][0] == infix_expr:
        pass
    elif isinstance(args[1], tuple) and args[1][0] == prefix_expr:
        pass
    elif isinstance(args[1], tuple) and args[1][0] == fn_eval:
        pass
    elif isinstance(args[1], tuple) and args[1][0] == var_ref:
        pass
    elif isinstance(args[1], PythonTypes.StringType):
        pass
    elif isinstance(args[1], PythonTypes.IntType):
        pass
    elif isinstance(args[1], PythonTypes.FloatType):
        pass
    elif isinstance(args[1], PythonTypes.StringType):
        pass
    elif args[1] == pure:
        pass
    elif args[1] == result:
        pass
    elif isinstance(args[1], tuple) and args[1][0] == complex:
        pass
    else:
        print f.__name__+"():\n    \"\"\"%s\"\"\"\n" %f.__doc__.replace("\\n","\n").replace("\return","Returns").replace("\\c ","")
        print "**GRAMMAR ERROR in argument args[1] = %s"%repr(args[1])
        print "  Most likely you now want to enter \"up<enter>l<enter>\"\n into the debugger to see what happened.\n"
        raise Exception("Grammar Error")
    return tuple(['prefix_expr']+list(args))

def Fn_eval(*args):
    """
    Construct a "fn_eval" node. Valid arguments are 
    (\c Id(), [\c Arg()])
    \return (\c "Fn_eval", \c Id(), [\c Arg()])
    """
    f = Fn_eval
    if len(args) <> 2:
        print "**GRAMMAR ERROR: expected 2 arguments for a", f.__name__
        print "Most likely you want to enter \"up<enter>l<enter>\" now to see what happened."
        raise Exception("Grammar Error")
    if isinstance(args[0], PythonTypes.StringType):
        pass
    else:
        print f.__name__+"():\n    \"\"\"%s\"\"\"\n" %f.__doc__.replace("\\n","\n").replace("\return","Returns").replace("\\c ","")
        print "**GRAMMAR ERROR in argument args[0] = %s"%repr(args[0])
        print "  Most likely you now want to enter \"up<enter>l<enter>\"\n into the debugger to see what happened.\n"
        raise Exception("Grammar Error")
    if isinstance(args[1], list):
        for a in args[1]:
            if isinstance(a, tuple) and a[0] == arg:
                pass
            elif isinstance(a, tuple) and a[0] == rarg:
                pass
            else:
                print f.__name__+"():\n    \"\"\"%s\"\"\"\n" %f.__doc__.replace("\\n","\n").replace("\return","Returns").replace("\\c ","")
                print "**GRAMMAR ERROR in argument a = %s"%repr(a)
                print "  Most likely you now want to enter \"up<enter>l<enter>\"\n into the debugger to see what happened.\n"
                raise Exception("Grammar Error")
    else:
        print f.__name__+"():\n    \"\"\"%s\"\"\"\n" %f.__doc__.replace("\\n","\n").replace("\return","Returns").replace("\\c ","")
        print "**GRAMMAR ERROR in argument args[1] = %s"%repr(args[1])
        print "  Most likely you now want to enter \"up<enter>l<enter>\"\n into the debugger to see what happened.\n"
        raise Exception("Grammar Error")
    return tuple(['fn_eval']+list(args))

def Var_ref(*args):
    """
    Construct a "var_ref" node. Valid arguments are 
    (\c Id())
    \return (\c "Var_ref", \c Id())
    """
    f = Var_ref
    if len(args) <> 1:
        print "**GRAMMAR ERROR: expected 1 arguments for a", f.__name__
        print "Most likely you want to enter \"up<enter>l<enter>\" now to see what happened."
        raise Exception("Grammar Error")
    if isinstance(args[0], PythonTypes.StringType):
        pass
    else:
        print f.__name__+"():\n    \"\"\"%s\"\"\"\n" %f.__doc__.replace("\\n","\n").replace("\return","Returns").replace("\\c ","")
        print "**GRAMMAR ERROR in argument args[0] = %s"%repr(args[0])
        print "  Most likely you now want to enter \"up<enter>l<enter>\"\n into the debugger to see what happened.\n"
        raise Exception("Grammar Error")
    return tuple(['var_ref']+list(args))

def require_scoped_id(arg):
    """
    Accessor function.
    \return the "scoped_id" member of a "require" node.
    """
    if not isinstance(arg, tuple):
        raise Exception("Grammar Error")
    elif arg[0] <> 'require':
        raise Exception("Grammar Error")
    else: return arg[1]


def require_version(arg):
    """
    Accessor function.
    \return the "version" member of a "require" node.
    """
    if not isinstance(arg, tuple):
        raise Exception("Grammar Error")
    elif arg[0] <> 'require':
        raise Exception("Grammar Error")
    else: return arg[2]


def import_scoped_id(arg):
    """
    Accessor function.
    \return the "scoped_id" member of a "import" node.
    """
    if not isinstance(arg, tuple):
        raise Exception("Grammar Error")
    elif arg[0] <> 'import':
        raise Exception("Grammar Error")
    else: return arg[1]


def import_version(arg):
    """
    Accessor function.
    \return the "version" member of a "import" node.
    """
    if not isinstance(arg, tuple):
        raise Exception("Grammar Error")
    elif arg[0] <> 'import':
        raise Exception("Grammar Error")
    else: return arg[2]


def user_type_type_attrs(arg):
    """
    Accessor function.
    \return the "type_attrs" member of a "user_type" node.
    """
    if not isinstance(arg, tuple):
        raise Exception("Grammar Error")
    elif arg[0] <> 'user_type':
        raise Exception("Grammar Error")
    else: return arg[1]


def user_type_custom_attrs(arg):
    """
    Accessor function.
    \return the "custom_attrs" member of a "user_type" node.
    """
    if not isinstance(arg, tuple):
        raise Exception("Grammar Error")
    elif arg[0] <> 'user_type':
        raise Exception("Grammar Error")
    else: return arg[1]


def user_type_cipse(arg):
    """
    Accessor function.
    \return the "cipse" member of a "user_type" node.
    """
    if not isinstance(arg, tuple):
        raise Exception("Grammar Error")
    elif arg[0] <> 'user_type':
        raise Exception("Grammar Error")
    else: return arg[2]


def file_requires(arg):
    """
    Accessor function.
    \return the "requires" member of a "file" node.
    """
    if not isinstance(arg, tuple):
        raise Exception("Grammar Error")
    elif arg[0] <> 'file':
        raise Exception("Grammar Error")
    else: return arg[1]


def file_import_s(arg):
    """
    Accessor function.
    \return the "import_s" member of a "file" node.
    """
    if not isinstance(arg, tuple):
        raise Exception("Grammar Error")
    elif arg[0] <> 'file':
        raise Exception("Grammar Error")
    else: return arg[2]


def file_user_types(arg):
    """
    Accessor function.
    \return the "user_types" member of a "file" node.
    """
    if not isinstance(arg, tuple):
        raise Exception("Grammar Error")
    elif arg[0] <> 'file':
        raise Exception("Grammar Error")
    else: return arg[3]


def version_STR(arg):
    """
    Accessor function.
    \return the "STR" member of a "version" node.
    """
    if not isinstance(arg, tuple):
        raise Exception("Grammar Error")
    elif arg[0] <> 'version':
        raise Exception("Grammar Error")
    else: return arg[1]


def version_FLOAT(arg):
    """
    Accessor function.
    \return the "FLOAT" member of a "version" node.
    """
    if not isinstance(arg, tuple):
        raise Exception("Grammar Error")
    elif arg[0] <> 'version':
        raise Exception("Grammar Error")
    else: return arg[1]


def version_INT(arg):
    """
    Accessor function.
    \return the "INT" member of a "version" node.
    """
    if not isinstance(arg, tuple):
        raise Exception("Grammar Error")
    elif arg[0] <> 'version':
        raise Exception("Grammar Error")
    else: return arg[1]


def scoped_id_ids(arg):
    """
    Accessor function.
    \return the "ids" member of a "scoped_id" node.
    """
    if not isinstance(arg, tuple):
        raise Exception("Grammar Error")
    elif arg[0] <> 'scoped_id':
        raise Exception("Grammar Error")
    else: return arg[1]


def scoped_id_extension(arg):
    """
    Accessor function.
    \return the "extension" member of a "scoped_id" node.
    """
    if not isinstance(arg, tuple):
        raise Exception("Grammar Error")
    elif arg[0] <> 'scoped_id':
        raise Exception("Grammar Error")
    else: return arg[2]


# skipping \c Id=STR
# skipping \c Doc_comment=STR
def package_id(arg):
    """
    Accessor function.
    \return the "id" member of a "package" node.
    """
    if not isinstance(arg, tuple):
        raise Exception("Grammar Error")
    elif arg[0] <> 'package':
        raise Exception("Grammar Error")
    else: return arg[1]


def package_version(arg):
    """
    Accessor function.
    \return the "version" member of a "package" node.
    """
    if not isinstance(arg, tuple):
        raise Exception("Grammar Error")
    elif arg[0] <> 'package':
        raise Exception("Grammar Error")
    else: return arg[2]


def package_user_types(arg):
    """
    Accessor function.
    \return the "user_types" member of a "package" node.
    """
    if not isinstance(arg, tuple):
        raise Exception("Grammar Error")
    elif arg[0] <> 'package':
        raise Exception("Grammar Error")
    else: return arg[3]


def package_doc_comment(arg):
    """
    Accessor function.
    \return the "doc_comment" member of a "package" node.
    """
    if not isinstance(arg, tuple):
        raise Exception("Grammar Error")
    elif arg[0] <> 'package':
        raise Exception("Grammar Error")
    else: return arg[4]


# skipping \c Type_attr= (final|abstract)
# skipping \c Custom_attr= (\c Custom_attribute|\c Custom_attribute_assoc)
# skipping \c Cipse= (\c Class|\c Interface|\c Package|\c Struct|\c Enum)
def struct_scoped_id(arg):
    """
    Accessor function.
    \return the "scoped_id" member of a "struct" node.
    """
    if not isinstance(arg, tuple):
        raise Exception("Grammar Error")
    elif arg[0] <> 'struct':
        raise Exception("Grammar Error")
    else: return arg[1]


def struct_struct_items(arg):
    """
    Accessor function.
    \return the "struct_items" member of a "struct" node.
    """
    if not isinstance(arg, tuple):
        raise Exception("Grammar Error")
    elif arg[0] <> 'struct':
        raise Exception("Grammar Error")
    else: return arg[2]


def enum_id(arg):
    """
    Accessor function.
    \return the "id" member of a "enum" node.
    """
    if not isinstance(arg, tuple):
        raise Exception("Grammar Error")
    elif arg[0] <> 'enum':
        raise Exception("Grammar Error")
    else: return arg[1]


def enum_enumerators(arg):
    """
    Accessor function.
    \return the "enumerators" member of a "enum" node.
    """
    if not isinstance(arg, tuple):
        raise Exception("Grammar Error")
    elif arg[0] <> 'enum':
        raise Exception("Grammar Error")
    else: return arg[2]


def enum_doc_comment(arg):
    """
    Accessor function.
    \return the "doc_comment" member of a "enum" node.
    """
    if not isinstance(arg, tuple):
        raise Exception("Grammar Error")
    elif arg[0] <> 'enum':
        raise Exception("Grammar Error")
    else: return arg[3]


def interface_id(arg):
    """
    Accessor function.
    \return the "id" member of a "interface" node.
    """
    if not isinstance(arg, tuple):
        raise Exception("Grammar Error")
    elif arg[0] <> 'interface':
        raise Exception("Grammar Error")
    else: return arg[1]


def interface_extends(arg):
    """
    Accessor function.
    \return the "extends" member of a "interface" node.
    """
    if not isinstance(arg, tuple):
        raise Exception("Grammar Error")
    elif arg[0] <> 'interface':
        raise Exception("Grammar Error")
    else: return arg[2]


def interface_invariants(arg):
    """
    Accessor function.
    \return the "invariants" member of a "interface" node.
    """
    if not isinstance(arg, tuple):
        raise Exception("Grammar Error")
    elif arg[0] <> 'interface':
        raise Exception("Grammar Error")
    else: return arg[3]


def interface_methods(arg):
    """
    Accessor function.
    \return the "methods" member of a "interface" node.
    """
    if not isinstance(arg, tuple):
        raise Exception("Grammar Error")
    elif arg[0] <> 'interface':
        raise Exception("Grammar Error")
    else: return arg[4]


def interface_doc_comment(arg):
    """
    Accessor function.
    \return the "doc_comment" member of a "interface" node.
    """
    if not isinstance(arg, tuple):
        raise Exception("Grammar Error")
    elif arg[0] <> 'interface':
        raise Exception("Grammar Error")
    else: return arg[5]


def class_id(arg):
    """
    Accessor function.
    \return the "id" member of a "class" node.
    """
    if not isinstance(arg, tuple):
        raise Exception("Grammar Error")
    elif arg[0] <> 'class':
        raise Exception("Grammar Error")
    else: return arg[1]


def class_extends(arg):
    """
    Accessor function.
    \return the "extends" member of a "class" node.
    """
    if not isinstance(arg, tuple):
        raise Exception("Grammar Error")
    elif arg[0] <> 'class':
        raise Exception("Grammar Error")
    else: return arg[2]


def class_implements(arg):
    """
    Accessor function.
    \return the "implements" member of a "class" node.
    """
    if not isinstance(arg, tuple):
        raise Exception("Grammar Error")
    elif arg[0] <> 'class':
        raise Exception("Grammar Error")
    else: return arg[3]


def class_invariants(arg):
    """
    Accessor function.
    \return the "invariants" member of a "class" node.
    """
    if not isinstance(arg, tuple):
        raise Exception("Grammar Error")
    elif arg[0] <> 'class':
        raise Exception("Grammar Error")
    else: return arg[4]


def class_methods(arg):
    """
    Accessor function.
    \return the "methods" member of a "class" node.
    """
    if not isinstance(arg, tuple):
        raise Exception("Grammar Error")
    elif arg[0] <> 'class':
        raise Exception("Grammar Error")
    else: return arg[5]


def class_doc_comment(arg):
    """
    Accessor function.
    \return the "doc_comment" member of a "class" node.
    """
    if not isinstance(arg, tuple):
        raise Exception("Grammar Error")
    elif arg[0] <> 'class':
        raise Exception("Grammar Error")
    else: return arg[6]


# skipping \c Enumerator= (\c Enumerator|\c Enumerator)
def struct_item_type_void(arg):
    """
    Accessor function.
    \return the "type_void" member of a "struct_item" node.
    """
    if not isinstance(arg, tuple):
        raise Exception("Grammar Error")
    elif arg[0] <> 'struct_item':
        raise Exception("Grammar Error")
    else: return arg[1]


def struct_item_id(arg):
    """
    Accessor function.
    \return the "id" member of a "struct_item" node.
    """
    if not isinstance(arg, tuple):
        raise Exception("Grammar Error")
    elif arg[0] <> 'struct_item':
        raise Exception("Grammar Error")
    else: return arg[2]


# skipping \c Type_void= (void|\c Type)
def extends_scoped_ids(arg):
    """
    Accessor function.
    \return the "scoped_ids" member of a "extends" node.
    """
    if not isinstance(arg, tuple):
        raise Exception("Grammar Error")
    elif arg[0] <> 'extends':
        raise Exception("Grammar Error")
    else: return arg[1]


# skipping \c Implements= (\c Implements|\c Implements_all)
def invariant_assertion(arg):
    """
    Accessor function.
    \return the "assertion" member of a "invariant" node.
    """
    if not isinstance(arg, tuple):
        raise Exception("Grammar Error")
    elif arg[0] <> 'invariant':
        raise Exception("Grammar Error")
    else: return arg[1]


def method_type_void(arg):
    """
    Accessor function.
    \return the "type_void" member of a "method" node.
    """
    if not isinstance(arg, tuple):
        raise Exception("Grammar Error")
    elif arg[0] <> 'method':
        raise Exception("Grammar Error")
    else: return arg[1]


def method_method_name(arg):
    """
    Accessor function.
    \return the "method_name" member of a "method" node.
    """
    if not isinstance(arg, tuple):
        raise Exception("Grammar Error")
    elif arg[0] <> 'method':
        raise Exception("Grammar Error")
    else: return arg[2]


def method_method_attrs(arg):
    """
    Accessor function.
    \return the "method_attrs" member of a "method" node.
    """
    if not isinstance(arg, tuple):
        raise Exception("Grammar Error")
    elif arg[0] <> 'method':
        raise Exception("Grammar Error")
    else: return arg[3]


def method_args(arg):
    """
    Accessor function.
    \return the "args" member of a "method" node.
    """
    if not isinstance(arg, tuple):
        raise Exception("Grammar Error")
    elif arg[0] <> 'method':
        raise Exception("Grammar Error")
    else: return arg[4]


def method_except_s(arg):
    """
    Accessor function.
    \return the "except_s" member of a "method" node.
    """
    if not isinstance(arg, tuple):
        raise Exception("Grammar Error")
    elif arg[0] <> 'method':
        raise Exception("Grammar Error")
    else: return arg[5]


def method_from_s(arg):
    """
    Accessor function.
    \return the "from_s" member of a "method" node.
    """
    if not isinstance(arg, tuple):
        raise Exception("Grammar Error")
    elif arg[0] <> 'method':
        raise Exception("Grammar Error")
    else: return arg[6]


def method_requires(arg):
    """
    Accessor function.
    \return the "requires" member of a "method" node.
    """
    if not isinstance(arg, tuple):
        raise Exception("Grammar Error")
    elif arg[0] <> 'method':
        raise Exception("Grammar Error")
    else: return arg[7]


def method_ensures(arg):
    """
    Accessor function.
    \return the "ensures" member of a "method" node.
    """
    if not isinstance(arg, tuple):
        raise Exception("Grammar Error")
    elif arg[0] <> 'method':
        raise Exception("Grammar Error")
    else: return arg[8]


def method_doc_comment(arg):
    """
    Accessor function.
    \return the "doc_comment" member of a "method" node.
    """
    if not isinstance(arg, tuple):
        raise Exception("Grammar Error")
    elif arg[0] <> 'method':
        raise Exception("Grammar Error")
    else: return arg[9]


# skipping \c Method_attr= (oneway|local|static|abstract|final|nonblocking|copy)
# skipping \c Arg= (\c Arg|\c Rarg)
def except_scoped_ids(arg):
    """
    Accessor function.
    \return the "scoped_ids" member of a "except" node.
    """
    if not isinstance(arg, tuple):
        raise Exception("Grammar Error")
    elif arg[0] <> 'except':
        raise Exception("Grammar Error")
    else: return arg[1]


def from_scoped_id(arg):
    """
    Accessor function.
    \return the "scoped_id" member of a "from" node.
    """
    if not isinstance(arg, tuple):
        raise Exception("Grammar Error")
    elif arg[0] <> 'from':
        raise Exception("Grammar Error")
    else: return arg[1]


def ensure_scoped_ids(arg):
    """
    Accessor function.
    \return the "scoped_ids" member of a "ensure" node.
    """
    if not isinstance(arg, tuple):
        raise Exception("Grammar Error")
    elif arg[0] <> 'ensure':
        raise Exception("Grammar Error")
    else: return arg[1]


def method_name_id(arg):
    """
    Accessor function.
    \return the "id" member of a "method_name" node.
    """
    if not isinstance(arg, tuple):
        raise Exception("Grammar Error")
    elif arg[0] <> 'method_name':
        raise Exception("Grammar Error")
    else: return arg[1]


def method_name_extension(arg):
    """
    Accessor function.
    \return the "extension" member of a "method_name" node.
    """
    if not isinstance(arg, tuple):
        raise Exception("Grammar Error")
    elif arg[0] <> 'method_name':
        raise Exception("Grammar Error")
    else: return arg[2]


# skipping \c Extension=STR
# skipping \c Type= (\c Primitive_type|\c Array|\c Scoped_id)
def assertion_id(arg):
    """
    Accessor function.
    \return the "id" member of a "assertion" node.
    """
    if not isinstance(arg, tuple):
        raise Exception("Grammar Error")
    elif arg[0] <> 'assertion':
        raise Exception("Grammar Error")
    else: return arg[1]


def assertion_assertExpr(arg):
    """
    Accessor function.
    \return the "assertExpr" member of a "assertion" node.
    """
    if not isinstance(arg, tuple):
        raise Exception("Grammar Error")
    elif arg[0] <> 'assertion':
        raise Exception("Grammar Error")
    else: return arg[2]


# skipping \c AssertExpr= (\c Infix_expr|\c Prefix_expr|\c Fn_eval|\c Var_ref|\c Id|\c Literal)
# skipping \c Arg_attr= (copy|[STR])
# skipping \c Mode= (in|out|inout)
def rarray_primitive_type(arg):
    """
    Accessor function.
    \return the "primitive_type" member of a "rarray" node.
    """
    if not isinstance(arg, tuple):
        raise Exception("Grammar Error")
    elif arg[0] <> 'rarray':
        raise Exception("Grammar Error")
    else: return arg[1]


def rarray_dimension(arg):
    """
    Accessor function.
    \return the "dimension" member of a "rarray" node.
    """
    if not isinstance(arg, tuple):
        raise Exception("Grammar Error")
    elif arg[0] <> 'rarray':
        raise Exception("Grammar Error")
    else: return arg[2]


def rarray_id(arg):
    """
    Accessor function.
    \return the "id" member of a "rarray" node.
    """
    if not isinstance(arg, tuple):
        raise Exception("Grammar Error")
    elif arg[0] <> 'rarray':
        raise Exception("Grammar Error")
    else: return arg[3]


def rarray_extents(arg):
    """
    Accessor function.
    \return the "extents" member of a "rarray" node.
    """
    if not isinstance(arg, tuple):
        raise Exception("Grammar Error")
    elif arg[0] <> 'rarray':
        raise Exception("Grammar Error")
    else: return arg[4]


def array_scalar_type(arg):
    """
    Accessor function.
    \return the "scalar_type" member of a "array" node.
    """
    if not isinstance(arg, tuple):
        raise Exception("Grammar Error")
    elif arg[0] <> 'array':
        raise Exception("Grammar Error")
    else: return arg[1]


def array_dimension(arg):
    """
    Accessor function.
    \return the "dimension" member of a "array" node.
    """
    if not isinstance(arg, tuple):
        raise Exception("Grammar Error")
    elif arg[0] <> 'array':
        raise Exception("Grammar Error")
    else: return arg[2]


def array_orientation(arg):
    """
    Accessor function.
    \return the "orientation" member of a "array" node.
    """
    if not isinstance(arg, tuple):
        raise Exception("Grammar Error")
    elif arg[0] <> 'array':
        raise Exception("Grammar Error")
    else: return arg[3]


def primitive_type_bool(arg):
    """
    Accessor function.
    \return the "bool" member of a "primitive_type" node.
    """
    if not isinstance(arg, tuple):
        raise Exception("Grammar Error")
    elif arg[0] <> 'primitive_type':
        raise Exception("Grammar Error")
    else: return arg[1]


def primitive_type_char(arg):
    """
    Accessor function.
    \return the "char" member of a "primitive_type" node.
    """
    if not isinstance(arg, tuple):
        raise Exception("Grammar Error")
    elif arg[0] <> 'primitive_type':
        raise Exception("Grammar Error")
    else: return arg[1]


def primitive_type_int(arg):
    """
    Accessor function.
    \return the "int" member of a "primitive_type" node.
    """
    if not isinstance(arg, tuple):
        raise Exception("Grammar Error")
    elif arg[0] <> 'primitive_type':
        raise Exception("Grammar Error")
    else: return arg[1]


def primitive_type_long(arg):
    """
    Accessor function.
    \return the "long" member of a "primitive_type" node.
    """
    if not isinstance(arg, tuple):
        raise Exception("Grammar Error")
    elif arg[0] <> 'primitive_type':
        raise Exception("Grammar Error")
    else: return arg[1]


def primitive_type_float(arg):
    """
    Accessor function.
    \return the "float" member of a "primitive_type" node.
    """
    if not isinstance(arg, tuple):
        raise Exception("Grammar Error")
    elif arg[0] <> 'primitive_type':
        raise Exception("Grammar Error")
    else: return arg[1]


def primitive_type_double(arg):
    """
    Accessor function.
    \return the "double" member of a "primitive_type" node.
    """
    if not isinstance(arg, tuple):
        raise Exception("Grammar Error")
    elif arg[0] <> 'primitive_type':
        raise Exception("Grammar Error")
    else: return arg[1]


def primitive_type_fcomplex(arg):
    """
    Accessor function.
    \return the "fcomplex" member of a "primitive_type" node.
    """
    if not isinstance(arg, tuple):
        raise Exception("Grammar Error")
    elif arg[0] <> 'primitive_type':
        raise Exception("Grammar Error")
    else: return arg[1]


def primitive_type_dcomplex(arg):
    """
    Accessor function.
    \return the "dcomplex" member of a "primitive_type" node.
    """
    if not isinstance(arg, tuple):
        raise Exception("Grammar Error")
    elif arg[0] <> 'primitive_type':
        raise Exception("Grammar Error")
    else: return arg[1]


def primitive_type_string(arg):
    """
    Accessor function.
    \return the "string" member of a "primitive_type" node.
    """
    if not isinstance(arg, tuple):
        raise Exception("Grammar Error")
    elif arg[0] <> 'primitive_type':
        raise Exception("Grammar Error")
    else: return arg[1]


def primitive_type_opaque(arg):
    """
    Accessor function.
    \return the "opaque" member of a "primitive_type" node.
    """
    if not isinstance(arg, tuple):
        raise Exception("Grammar Error")
    elif arg[0] <> 'primitive_type':
        raise Exception("Grammar Error")
    else: return arg[1]


# skipping \c Scalar_type= (\c Primitive_type|\c Scoped_id)
# skipping \c Dimension=INT
# skipping \c Orientation= (row_major|column_major)
# skipping \c Extents= \c SimpleIntExpression
# skipping \c SimpleIntExpression=INT
# skipping \c Bin_op= (log_or|log_and|eq|ne|bit_or|bit_and|bit_xor|lt|gt|lshift|rshift|plus|minus|times|divide|modulo|rem|pow)
# skipping \c Un_op= (is|log_not|bit_not)
# skipping \c Literal= (INT|FLOAT|STR|pure|result|\c Complex)
def complex_FLOAT(arg):
    """
    Accessor function.
    \return the "FLOAT" member of a "complex" node.
    """
    if not isinstance(arg, tuple):
        raise Exception("Grammar Error")
    elif arg[0] <> 'complex':
        raise Exception("Grammar Error")
    else: return arg[1]


def complex_FLOAT(arg):
    """
    Accessor function.
    \return the "FLOAT" member of a "complex" node.
    """
    if not isinstance(arg, tuple):
        raise Exception("Grammar Error")
    elif arg[0] <> 'complex':
        raise Exception("Grammar Error")
    else: return arg[2]


def enumerator_id(arg):
    """
    Accessor function.
    \return the "id" member of a "enumerator" node.
    """
    if not isinstance(arg, tuple):
        raise Exception("Grammar Error")
    elif arg[0] <> 'enumerator':
        raise Exception("Grammar Error")
    else: return arg[1]


def enumerator_id(arg):
    """
    Accessor function.
    \return the "id" member of a "enumerator" node.
    """
    if not isinstance(arg, tuple):
        raise Exception("Grammar Error")
    elif arg[0] <> 'enumerator':
        raise Exception("Grammar Error")
    else: return arg[1]


def enumerator_INT(arg):
    """
    Accessor function.
    \return the "INT" member of a "enumerator" node.
    """
    if not isinstance(arg, tuple):
        raise Exception("Grammar Error")
    elif arg[0] <> 'enumerator':
        raise Exception("Grammar Error")
    else: return arg[2]


def implements_scoped_id(arg):
    """
    Accessor function.
    \return the "scoped_id" member of a "implements" node.
    """
    if not isinstance(arg, tuple):
        raise Exception("Grammar Error")
    elif arg[0] <> 'implements':
        raise Exception("Grammar Error")
    else: return arg[1]


def implements_all_scoped_id(arg):
    """
    Accessor function.
    \return the "scoped_id" member of a "implements_all" node.
    """
    if not isinstance(arg, tuple):
        raise Exception("Grammar Error")
    elif arg[0] <> 'implements_all':
        raise Exception("Grammar Error")
    else: return arg[1]


def arg_arg_attrs(arg):
    """
    Accessor function.
    \return the "arg_attrs" member of a "arg" node.
    """
    if not isinstance(arg, tuple):
        raise Exception("Grammar Error")
    elif arg[0] <> 'arg':
        raise Exception("Grammar Error")
    else: return arg[1]


def arg_mode(arg):
    """
    Accessor function.
    \return the "mode" member of a "arg" node.
    """
    if not isinstance(arg, tuple):
        raise Exception("Grammar Error")
    elif arg[0] <> 'arg':
        raise Exception("Grammar Error")
    else: return arg[2]


def arg_type_void(arg):
    """
    Accessor function.
    \return the "type_void" member of a "arg" node.
    """
    if not isinstance(arg, tuple):
        raise Exception("Grammar Error")
    elif arg[0] <> 'arg':
        raise Exception("Grammar Error")
    else: return arg[3]


def arg_id(arg):
    """
    Accessor function.
    \return the "id" member of a "arg" node.
    """
    if not isinstance(arg, tuple):
        raise Exception("Grammar Error")
    elif arg[0] <> 'arg':
        raise Exception("Grammar Error")
    else: return arg[4]


def rarg_arg_attrs(arg):
    """
    Accessor function.
    \return the "arg_attrs" member of a "rarg" node.
    """
    if not isinstance(arg, tuple):
        raise Exception("Grammar Error")
    elif arg[0] <> 'rarg':
        raise Exception("Grammar Error")
    else: return arg[1]


def rarg_mode(arg):
    """
    Accessor function.
    \return the "mode" member of a "rarg" node.
    """
    if not isinstance(arg, tuple):
        raise Exception("Grammar Error")
    elif arg[0] <> 'rarg':
        raise Exception("Grammar Error")
    else: return arg[2]


def rarg_rarray(arg):
    """
    Accessor function.
    \return the "rarray" member of a "rarg" node.
    """
    if not isinstance(arg, tuple):
        raise Exception("Grammar Error")
    elif arg[0] <> 'rarg':
        raise Exception("Grammar Error")
    else: return arg[3]


def custom_attribute_STR(arg):
    """
    Accessor function.
    \return the "STR" member of a "custom_attribute" node.
    """
    if not isinstance(arg, tuple):
        raise Exception("Grammar Error")
    elif arg[0] <> 'custom_attribute':
        raise Exception("Grammar Error")
    else: return arg[1]


def custom_attribute_assoc_STR(arg):
    """
    Accessor function.
    \return the "STR" member of a "custom_attribute_assoc" node.
    """
    if not isinstance(arg, tuple):
        raise Exception("Grammar Error")
    elif arg[0] <> 'custom_attribute_assoc':
        raise Exception("Grammar Error")
    else: return arg[1]


def custom_attribute_assoc_STR(arg):
    """
    Accessor function.
    \return the "STR" member of a "custom_attribute_assoc" node.
    """
    if not isinstance(arg, tuple):
        raise Exception("Grammar Error")
    elif arg[0] <> 'custom_attribute_assoc':
        raise Exception("Grammar Error")
    else: return arg[2]


def infix_expr_bin_op(arg):
    """
    Accessor function.
    \return the "bin_op" member of a "infix_expr" node.
    """
    if not isinstance(arg, tuple):
        raise Exception("Grammar Error")
    elif arg[0] <> 'infix_expr':
        raise Exception("Grammar Error")
    else: return arg[1]


def infix_expr_assertExpr(arg):
    """
    Accessor function.
    \return the "assertExpr" member of a "infix_expr" node.
    """
    if not isinstance(arg, tuple):
        raise Exception("Grammar Error")
    elif arg[0] <> 'infix_expr':
        raise Exception("Grammar Error")
    else: return arg[2]


def infix_expr_assertExpr(arg):
    """
    Accessor function.
    \return the "assertExpr" member of a "infix_expr" node.
    """
    if not isinstance(arg, tuple):
        raise Exception("Grammar Error")
    elif arg[0] <> 'infix_expr':
        raise Exception("Grammar Error")
    else: return arg[3]


def prefix_expr_un_op(arg):
    """
    Accessor function.
    \return the "un_op" member of a "prefix_expr" node.
    """
    if not isinstance(arg, tuple):
        raise Exception("Grammar Error")
    elif arg[0] <> 'prefix_expr':
        raise Exception("Grammar Error")
    else: return arg[1]


def prefix_expr_assertExpr(arg):
    """
    Accessor function.
    \return the "assertExpr" member of a "prefix_expr" node.
    """
    if not isinstance(arg, tuple):
        raise Exception("Grammar Error")
    elif arg[0] <> 'prefix_expr':
        raise Exception("Grammar Error")
    else: return arg[2]


def fn_eval_id(arg):
    """
    Accessor function.
    \return the "id" member of a "fn_eval" node.
    """
    if not isinstance(arg, tuple):
        raise Exception("Grammar Error")
    elif arg[0] <> 'fn_eval':
        raise Exception("Grammar Error")
    else: return arg[1]


def fn_eval_args(arg):
    """
    Accessor function.
    \return the "args" member of a "fn_eval" node.
    """
    if not isinstance(arg, tuple):
        raise Exception("Grammar Error")
    elif arg[0] <> 'fn_eval':
        raise Exception("Grammar Error")
    else: return arg[2]


def var_ref_id(arg):
    """
    Accessor function.
    \return the "id" member of a "var_ref" node.
    """
    if not isinstance(arg, tuple):
        raise Exception("Grammar Error")
    elif arg[0] <> 'var_ref':
        raise Exception("Grammar Error")
    else: return arg[1]


 ## sidl primitive types
pt_bool = Primitive_type(bool)
pt_bool     = Primitive_type(bool)
pt_char     = Primitive_type(char)
pt_int	     = Primitive_type(int)
pt_long     = Primitive_type(long)
pt_float    = Primitive_type(float)
pt_double   = Primitive_type(double)
pt_fcomplex = Primitive_type(fcomplex)
pt_dcomplex = Primitive_type(dcomplex)
pt_string   = Primitive_type(string)
pt_opaque   = Primitive_type(opaque)
def visit_hierarchy(base_class, visit_func, symbol_table, visited_nodes = []):
    """
    Visit all parent classes and implemented interfaces of
    \c base_class exactly once and invoke visit_func on each
    sidl.class/sidl.interface node.
 
    \arg visited_nodes         An optional list of nodes
                               to exclude from visiting.
 			       Contains the list of visited
 			       nodes after return.
    """
 
    def step(visited_nodes, base):
 
 	visit_func(base)
 	visited_nodes.append(base[1])
 
 	n = symbol_table[base[1]]
 	if n:
 	    if n[0] == class_:
 		extends = n[2]
 		for ext in extends:
                   if ext[1] not in visited_nodes:
 		        step(visited_nodes, ext)
 		for loop_impls in n[3]:
 		    loop_interfaces = loop_impls[1]
 		    for interface_sym in loop_interfaces:
 			if interface_sym and interface_sym[1] not in visited_nodes:
 			    step(visited_nodes, interface_sym)
 	    elif n[0] == interface:
 		for parent_interface in n[2]:
 		    if parent_interface and parent_interface[1] not in visited_nodes:
 			step(visited_nodes, parent_interface)
 			    
    if base_class and base_class[1] not in visited_nodes:
 	step(visited_nodes, base_class)
