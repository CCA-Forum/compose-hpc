#!/usr/bin/env python
# -*- python -*-
## @package sidl
# Grammar for the SIDL intermediate representation (IR).
# This is NOT a grammar for SIDL, the language.
#
# Please report bugs to <adrian@llnl.gov>.
#
# \authors <pre>
#
# Copyright (c) 2011, Lawrence Livermore National Security, LLC.
# Produced at the Lawrence Livermore National Laboratory
# Written by Adrian Prantl <adrian@llnl.gov>.
#
# LLNL-CODE-473891.
# All rights reserved.
#
# This file is part of BRAID. For details, see
# http://compose-hpc.sourceforge.net/.
# Please read the COPYRIGHT file for Our Notice and
# for the BSD License.
#
# </pre>
#
#
# <h2>Grammar definition</h2>
#
#\verbatim
# 
# [
#   _File = file([Requires], [Import], [User_type]),
#   Version = version('STR' | 'FLOAT' | 'INT'),
#   Requires = requires(Scoped_id, Version),
#   Import = import(Scoped_id, Version),
#   Package = package(Id, Version, [User_type], Doc_comment),
#   User_type = user_type([(Type_attr|Custom_attr)], Cipse),
#   Cipse = ( Class
#           | Interface
#           | Package
#           | Struct
#           | Enum ),
#   Type_attr = (final | abstract),
#   Id = 'STR',
#   Doc_comment = 'STR',
#   Enum = enum(Id, [Enumerator], Doc_comment),
#   Enumerator = ( enumerator(Id) | enumerator_value(Id, 'INT')),
#   Struct = struct(Id, [Struct_item], Doc_comment),
#   Struct_item = struct_item( (Type_void | Rarray), Id),
#   Class = class(Id, [Extends], [Implements], [Invariant], [Method], Doc_comment),
#   Interface = interface(Id, [Extends], [Invariant], [Method], Doc_comment),
#   Implements = ( implements(Scoped_id)
#                | implements_all(Scoped_id)),
#   Method = method(Type_void, Method_name, [Method_attr], [Arg],
#                   [Except], [From], [Require], [Ensure], Doc_comment),
#   Method_name = method_name(Id, Extension),
#   Extension = 'STR',
#   Type_void = ( void | Type ),
#   Method_attr = ( oneway
#                 | local
#                 | static
#                 | abstract
#                 | final
#                 | nonblocking
#                 | copy ),
#   From = from(Scoped_id),
#   Invariant = invariant(Assertion),
#   Assertion = assertion(Id, AssertExpr),
#   Except = except(Scoped_id),
#   Extends = extends(Scoped_id),
#   Ensure = ensure(Assertion),
#   Require = require(Assertion),
#   Arg = arg([Arg_attr], Mode, (Type_void | Rarray), Id),
#   Arg_attr = (copy | ['STR']),
#   Custom_attr = ( custom_attribute('STR')
#                 | custom_attribute_assoc('STR', 'STR')
#                 ),
#   Mode = (in | out | inout),
#   Type = (Primitive_type | Array | Scoped_id),
#   Primitive_type = primitive_type(
#       bool|char|int|long|float|double|fcomplex|dcomplex|string|opaque),
#   Array = array(Scalar_type, Dimension, Orientation),
#   Scalar_type = (Primitive_type|Scoped_id),
#   Dimension = 'INT',
#   Orientation = (row_major|column_major),
#   Rarray = rarray(Primitive_type, Dimension, Extents),
#   Extents = SimpleIntExpression,
#   SimpleIntExpression = ('INT' | Id), % FIXME
#   AssertExpr = ( infix_expr(Bin_op, AssertExpr, AssertExpr)
#                | prefix_expr(Un_op, AssertExpr)
#                | fn_eval(Id, [AssertExpr])
#                | var_ref(Id)
#                | Id
#                | Literal
#                ),
#   Bin_op = (log_or|log_and|eq|ne|bit_or|bit_and|bit_xor|lt|gt|le|ge
# 	   |lshift|rshift|plus|minus|times|divide|modulo|rem|pow|implies|iff),
#   Un_op = ( is|log_not|bit_not ),
#   Scoped_id = scoped_id([Module], Id, Extension),
#   Module = 'STR',
#   Literal = ('INT' | 'FLOAT' | 'STR' | pure | result | Complex),
#   Complex = complex('FLOAT', 'FLOAT')
# ].
#   
#\endverbatim


# Automatically generated by GRAMOLA.
#     ### ### #### ### ###
#     ### DO NOT EDIT! ###
#     ### ### #### ### ###
import types as PythonTypes


## Token definitions

abstract = 'abstract'
arg = 'arg'
array = 'array'
assertion = 'assertion'
bit_and = 'bit_and'
bit_not = 'bit_not'
bit_or = 'bit_or'
bit_xor = 'bit_xor'
bool = 'bool'
char = 'char'
class_ = 'class'
column_major = 'column_major'
complex = 'complex'
copy = 'copy'
custom_attribute = 'custom_attribute'
custom_attribute_assoc = 'custom_attribute_assoc'
dcomplex = 'dcomplex'
divide = 'divide'
double = 'double'
ensure = 'ensure'
enum = 'enum'
enumerator = 'enumerator'
enumerator_value = 'enumerator_value'
eq = 'eq'
except_ = 'except'
extends = 'extends'
fcomplex = 'fcomplex'
file = 'file'
final = 'final'
float = 'float'
fn_eval = 'fn_eval'
from_ = 'from'
ge = 'ge'
gt = 'gt'
iff = 'iff'
implements = 'implements'
implements_all = 'implements_all'
implies = 'implies'
import_ = 'import'
in_ = 'in'
infix_expr = 'infix_expr'
inout = 'inout'
int = 'int'
interface = 'interface'
invariant = 'invariant'
is_ = 'is'
le = 'le'
local = 'local'
log_and = 'log_and'
log_not = 'log_not'
log_or = 'log_or'
long = 'long'
lshift = 'lshift'
lt = 'lt'
method = 'method'
method_name = 'method_name'
minus = 'minus'
modulo = 'modulo'
ne = 'ne'
nonblocking = 'nonblocking'
oneway = 'oneway'
opaque = 'opaque'
out = 'out'
package = 'package'
plus = 'plus'
pow = 'pow'
prefix_expr = 'prefix_expr'
primitive_type = 'primitive_type'
pure = 'pure'
rarray = 'rarray'
rem = 'rem'
require = 'require'
requires = 'requires'
result = 'result'
row_major = 'row_major'
rshift = 'rshift'
scoped_id = 'scoped_id'
static = 'static'
string = 'string'
struct = 'struct'
struct_item = 'struct_item'
times = 'times'
user_type = 'user_type'
var_ref = 'var_ref'
version = 'version'
void = 'void'


## Constructor definitions

def Requires(*args):
    """
    Construct a "requires" node. Valid arguments are 
    (\c Scoped_id(), \c Version())
    \return (\c "Requires", \c Scoped_id(), \c Version())
    """
    f = Requires
    if len(args) <> 2:
        print "**GRAMMAR ERROR: expected 2 arguments for a", f.__name__
        print "Most likely you want to enter \"up<enter>l<enter>\" now to see what happened."
        raise Exception("Grammar Error")
    if isinstance(args[0], tuple) and args[0][0] == scoped_id:
        pass
    else:
        print f.__name__+"():\n    \"\"\"%s\"\"\"\n" %f.__doc__.replace("\\n","\n").replace("\return","Returns").replace("\\c ","")
        print "**GRAMMAR ERROR in argument args[0] = %s"%repr(args[0])
        print "  Most likely you now want to enter \"up<enter>l<enter>\"\n into the debugger to see what happened.\n"
        raise Exception("Grammar Error")
    if isinstance(args[1], tuple) and args[1][0] == version:
        pass
    else:
        print f.__name__+"():\n    \"\"\"%s\"\"\"\n" %f.__doc__.replace("\\n","\n").replace("\return","Returns").replace("\\c ","")
        print "**GRAMMAR ERROR in argument args[1] = %s"%repr(args[1])
        print "  Most likely you now want to enter \"up<enter>l<enter>\"\n into the debugger to see what happened.\n"
        raise Exception("Grammar Error")
    return tuple(['requires']+list(args))

def Import(*args):
    """
    Construct a "import" node. Valid arguments are 
    (\c Scoped_id(), \c Version())
    \return (\c "Import", \c Scoped_id(), \c Version())
    """
    f = Import
    if len(args) <> 2:
        print "**GRAMMAR ERROR: expected 2 arguments for a", f.__name__
        print "Most likely you want to enter \"up<enter>l<enter>\" now to see what happened."
        raise Exception("Grammar Error")
    if isinstance(args[0], tuple) and args[0][0] == scoped_id:
        pass
    else:
        print f.__name__+"():\n    \"\"\"%s\"\"\"\n" %f.__doc__.replace("\\n","\n").replace("\return","Returns").replace("\\c ","")
        print "**GRAMMAR ERROR in argument args[0] = %s"%repr(args[0])
        print "  Most likely you now want to enter \"up<enter>l<enter>\"\n into the debugger to see what happened.\n"
        raise Exception("Grammar Error")
    if isinstance(args[1], tuple) and args[1][0] == version:
        pass
    else:
        print f.__name__+"():\n    \"\"\"%s\"\"\"\n" %f.__doc__.replace("\\n","\n").replace("\return","Returns").replace("\\c ","")
        print "**GRAMMAR ERROR in argument args[1] = %s"%repr(args[1])
        print "  Most likely you now want to enter \"up<enter>l<enter>\"\n into the debugger to see what happened.\n"
        raise Exception("Grammar Error")
    return tuple(['import']+list(args))

def User_type(*args):
    """
    Construct a "user_type" node. Valid arguments are 
    ([\c Type_attr()
    |\c Custom_attr()], \c Cipse())
    \return (\c "User_type", [\c Type_attr()
    |\c Custom_attr()], \c Cipse())
    """
    f = User_type
    if len(args) <> 2:
        print "**GRAMMAR ERROR: expected 2 arguments for a", f.__name__
        print "Most likely you want to enter \"up<enter>l<enter>\" now to see what happened."
        raise Exception("Grammar Error")
    if isinstance(args[0], list) or isinstance(args[0], tuple):
        for a in args[0]:
            if a == final:
                pass
            elif a == abstract:
                pass
            elif isinstance(a, tuple) and a[0] == custom_attribute:
                pass
            elif isinstance(a, tuple) and a[0] == custom_attribute_assoc:
                pass
            else:
                print f.__name__+"():\n    \"\"\"%s\"\"\"\n" %f.__doc__.replace("\\n","\n").replace("\return","Returns").replace("\\c ","")
                print "**GRAMMAR ERROR in argument a = %s"%repr(a)
                print "  Most likely you now want to enter \"up<enter>l<enter>\"\n into the debugger to see what happened.\n"
                raise Exception("Grammar Error")
    else:
        print f.__name__+"():\n    \"\"\"%s\"\"\"\n" %f.__doc__.replace("\\n","\n").replace("\return","Returns").replace("\\c ","")
        print "**GRAMMAR ERROR in argument args[0] = %s"%repr(args[0])
        print "  Most likely you now want to enter \"up<enter>l<enter>\"\n into the debugger to see what happened.\n"
        raise Exception("Grammar Error")
    if isinstance(args[1], tuple) and args[1][0] == class_:
        pass
    elif isinstance(args[1], tuple) and args[1][0] == interface:
        pass
    elif isinstance(args[1], tuple) and args[1][0] == package:
        pass
    elif isinstance(args[1], tuple) and args[1][0] == struct:
        pass
    elif isinstance(args[1], tuple) and args[1][0] == enum:
        pass
    else:
        print f.__name__+"():\n    \"\"\"%s\"\"\"\n" %f.__doc__.replace("\\n","\n").replace("\return","Returns").replace("\\c ","")
        print "**GRAMMAR ERROR in argument args[1] = %s"%repr(args[1])
        print "  Most likely you now want to enter \"up<enter>l<enter>\"\n into the debugger to see what happened.\n"
        raise Exception("Grammar Error")
    return tuple(['user_type']+list(args))

def File(*args):
    """
    Construct a "file" node. Valid arguments are 
    ([\c Requires()], [\c Import()], [\c User_type()])
    \return (\c "_File", [\c Requires()], [\c Import()], [\c User_type()])
    """
    f = File
    if len(args) <> 3:
        print "**GRAMMAR ERROR: expected 3 arguments for a", f.__name__
        print "Most likely you want to enter \"up<enter>l<enter>\" now to see what happened."
        raise Exception("Grammar Error")
    if isinstance(args[0], list) or isinstance(args[0], tuple):
        for a in args[0]:
            if isinstance(a, tuple) and a[0] == requires:
                pass
            else:
                print f.__name__+"():\n    \"\"\"%s\"\"\"\n" %f.__doc__.replace("\\n","\n").replace("\return","Returns").replace("\\c ","")
                print "**GRAMMAR ERROR in argument a = %s"%repr(a)
                print "  Most likely you now want to enter \"up<enter>l<enter>\"\n into the debugger to see what happened.\n"
                raise Exception("Grammar Error")
    else:
        print f.__name__+"():\n    \"\"\"%s\"\"\"\n" %f.__doc__.replace("\\n","\n").replace("\return","Returns").replace("\\c ","")
        print "**GRAMMAR ERROR in argument args[0] = %s"%repr(args[0])
        print "  Most likely you now want to enter \"up<enter>l<enter>\"\n into the debugger to see what happened.\n"
        raise Exception("Grammar Error")
    if isinstance(args[1], list) or isinstance(args[1], tuple):
        for a in args[1]:
            if isinstance(a, tuple) and a[0] == import_:
                pass
            else:
                print f.__name__+"():\n    \"\"\"%s\"\"\"\n" %f.__doc__.replace("\\n","\n").replace("\return","Returns").replace("\\c ","")
                print "**GRAMMAR ERROR in argument a = %s"%repr(a)
                print "  Most likely you now want to enter \"up<enter>l<enter>\"\n into the debugger to see what happened.\n"
                raise Exception("Grammar Error")
    else:
        print f.__name__+"():\n    \"\"\"%s\"\"\"\n" %f.__doc__.replace("\\n","\n").replace("\return","Returns").replace("\\c ","")
        print "**GRAMMAR ERROR in argument args[1] = %s"%repr(args[1])
        print "  Most likely you now want to enter \"up<enter>l<enter>\"\n into the debugger to see what happened.\n"
        raise Exception("Grammar Error")
    if isinstance(args[2], list) or isinstance(args[2], tuple):
        for a in args[2]:
            if isinstance(a, tuple) and a[0] == user_type:
                pass
            else:
                print f.__name__+"():\n    \"\"\"%s\"\"\"\n" %f.__doc__.replace("\\n","\n").replace("\return","Returns").replace("\\c ","")
                print "**GRAMMAR ERROR in argument a = %s"%repr(a)
                print "  Most likely you now want to enter \"up<enter>l<enter>\"\n into the debugger to see what happened.\n"
                raise Exception("Grammar Error")
    else:
        print f.__name__+"():\n    \"\"\"%s\"\"\"\n" %f.__doc__.replace("\\n","\n").replace("\return","Returns").replace("\\c ","")
        print "**GRAMMAR ERROR in argument args[2] = %s"%repr(args[2])
        print "  Most likely you now want to enter \"up<enter>l<enter>\"\n into the debugger to see what happened.\n"
        raise Exception("Grammar Error")
    return tuple(['file']+list(args))

def Version(*args):
    """
    Construct a "version" node. Valid arguments are 
    (STR()
    |FLOAT()
    |INT())
    \return (\c "Version", STR()
    |FLOAT()
    |INT())
    """
    f = Version
    if len(args) <> 1:
        print "**GRAMMAR ERROR: expected 1 arguments for a", f.__name__
        print "Most likely you want to enter \"up<enter>l<enter>\" now to see what happened."
        raise Exception("Grammar Error")
    if isinstance(args[0], PythonTypes.StringType):
        pass
    elif isinstance(args[0], PythonTypes.FloatType):
        pass
    elif isinstance(args[0], PythonTypes.IntType):
        pass
    else:
        print f.__name__+"():\n    \"\"\"%s\"\"\"\n" %f.__doc__.replace("\\n","\n").replace("\return","Returns").replace("\\c ","")
        print "**GRAMMAR ERROR in argument args[0] = %s"%repr(args[0])
        print "  Most likely you now want to enter \"up<enter>l<enter>\"\n into the debugger to see what happened.\n"
        raise Exception("Grammar Error")
    return tuple(['version']+list(args))

def Scoped_id(*args):
    """
    Construct a "scoped_id" node. Valid arguments are 
    ([\c Module()], \c Id(), \c Extension())
    \return (\c "Scoped_id", [\c Module()], \c Id(), \c Extension())
    """
    f = Scoped_id
    if len(args) <> 3:
        print "**GRAMMAR ERROR: expected 3 arguments for a", f.__name__
        print "Most likely you want to enter \"up<enter>l<enter>\" now to see what happened."
        raise Exception("Grammar Error")
    if isinstance(args[0], list) or isinstance(args[0], tuple):
        for a in args[0]:
            if isinstance(a, PythonTypes.StringType):
                pass
            else:
                print f.__name__+"():\n    \"\"\"%s\"\"\"\n" %f.__doc__.replace("\\n","\n").replace("\return","Returns").replace("\\c ","")
                print "**GRAMMAR ERROR in argument a = %s"%repr(a)
                print "  Most likely you now want to enter \"up<enter>l<enter>\"\n into the debugger to see what happened.\n"
                raise Exception("Grammar Error")
    else:
        print f.__name__+"():\n    \"\"\"%s\"\"\"\n" %f.__doc__.replace("\\n","\n").replace("\return","Returns").replace("\\c ","")
        print "**GRAMMAR ERROR in argument args[0] = %s"%repr(args[0])
        print "  Most likely you now want to enter \"up<enter>l<enter>\"\n into the debugger to see what happened.\n"
        raise Exception("Grammar Error")
    if isinstance(args[1], PythonTypes.StringType):
        pass
    else:
        print f.__name__+"():\n    \"\"\"%s\"\"\"\n" %f.__doc__.replace("\\n","\n").replace("\return","Returns").replace("\\c ","")
        print "**GRAMMAR ERROR in argument args[1] = %s"%repr(args[1])
        print "  Most likely you now want to enter \"up<enter>l<enter>\"\n into the debugger to see what happened.\n"
        raise Exception("Grammar Error")
    if isinstance(args[2], PythonTypes.StringType):
        pass
    else:
        print f.__name__+"():\n    \"\"\"%s\"\"\"\n" %f.__doc__.replace("\\n","\n").replace("\return","Returns").replace("\\c ","")
        print "**GRAMMAR ERROR in argument args[2] = %s"%repr(args[2])
        print "  Most likely you now want to enter \"up<enter>l<enter>\"\n into the debugger to see what happened.\n"
        raise Exception("Grammar Error")
    return tuple(['scoped_id']+list(args))

def STR():
    return STR
def STR():
    return STR
def Package(*args):
    """
    Construct a "package" node. Valid arguments are 
    (\c Id(), \c Version(), [\c User_type()], \c Doc_comment())
    \return (\c "Package", \c Id(), \c Version(), [\c User_type()], \c Doc_comment())
    """
    f = Package
    if len(args) <> 4:
        print "**GRAMMAR ERROR: expected 4 arguments for a", f.__name__
        print "Most likely you want to enter \"up<enter>l<enter>\" now to see what happened."
        raise Exception("Grammar Error")
    if isinstance(args[0], PythonTypes.StringType):
        pass
    else:
        print f.__name__+"():\n    \"\"\"%s\"\"\"\n" %f.__doc__.replace("\\n","\n").replace("\return","Returns").replace("\\c ","")
        print "**GRAMMAR ERROR in argument args[0] = %s"%repr(args[0])
        print "  Most likely you now want to enter \"up<enter>l<enter>\"\n into the debugger to see what happened.\n"
        raise Exception("Grammar Error")
    if isinstance(args[1], tuple) and args[1][0] == version:
        pass
    else:
        print f.__name__+"():\n    \"\"\"%s\"\"\"\n" %f.__doc__.replace("\\n","\n").replace("\return","Returns").replace("\\c ","")
        print "**GRAMMAR ERROR in argument args[1] = %s"%repr(args[1])
        print "  Most likely you now want to enter \"up<enter>l<enter>\"\n into the debugger to see what happened.\n"
        raise Exception("Grammar Error")
    if isinstance(args[2], list) or isinstance(args[2], tuple):
        for a in args[2]:
            if isinstance(a, tuple) and a[0] == user_type:
                pass
            else:
                print f.__name__+"():\n    \"\"\"%s\"\"\"\n" %f.__doc__.replace("\\n","\n").replace("\return","Returns").replace("\\c ","")
                print "**GRAMMAR ERROR in argument a = %s"%repr(a)
                print "  Most likely you now want to enter \"up<enter>l<enter>\"\n into the debugger to see what happened.\n"
                raise Exception("Grammar Error")
    else:
        print f.__name__+"():\n    \"\"\"%s\"\"\"\n" %f.__doc__.replace("\\n","\n").replace("\return","Returns").replace("\\c ","")
        print "**GRAMMAR ERROR in argument args[2] = %s"%repr(args[2])
        print "  Most likely you now want to enter \"up<enter>l<enter>\"\n into the debugger to see what happened.\n"
        raise Exception("Grammar Error")
    if isinstance(args[3], PythonTypes.StringType):
        pass
    else:
        print f.__name__+"():\n    \"\"\"%s\"\"\"\n" %f.__doc__.replace("\\n","\n").replace("\return","Returns").replace("\\c ","")
        print "**GRAMMAR ERROR in argument args[3] = %s"%repr(args[3])
        print "  Most likely you now want to enter \"up<enter>l<enter>\"\n into the debugger to see what happened.\n"
        raise Exception("Grammar Error")
    return tuple(['package']+list(args))

# skipping \c Type_attr= (final|abstract)
# skipping \c Custom_attr= (\c Custom_attribute|\c Custom_attribute_assoc)
# skipping \c Cipse= (\c Class|\c Interface|\c Package|\c Struct|\c Enum)
def Struct(*args):
    """
    Construct a "struct" node. Valid arguments are 
    (\c Id(), [\c Struct_item()], \c Doc_comment())
    \return (\c "Struct", \c Id(), [\c Struct_item()], \c Doc_comment())
    """
    f = Struct
    if len(args) <> 3:
        print "**GRAMMAR ERROR: expected 3 arguments for a", f.__name__
        print "Most likely you want to enter \"up<enter>l<enter>\" now to see what happened."
        raise Exception("Grammar Error")
    if isinstance(args[0], PythonTypes.StringType):
        pass
    else:
        print f.__name__+"():\n    \"\"\"%s\"\"\"\n" %f.__doc__.replace("\\n","\n").replace("\return","Returns").replace("\\c ","")
        print "**GRAMMAR ERROR in argument args[0] = %s"%repr(args[0])
        print "  Most likely you now want to enter \"up<enter>l<enter>\"\n into the debugger to see what happened.\n"
        raise Exception("Grammar Error")
    if isinstance(args[1], list) or isinstance(args[1], tuple):
        for a in args[1]:
            if isinstance(a, tuple) and a[0] == struct_item:
                pass
            else:
                print f.__name__+"():\n    \"\"\"%s\"\"\"\n" %f.__doc__.replace("\\n","\n").replace("\return","Returns").replace("\\c ","")
                print "**GRAMMAR ERROR in argument a = %s"%repr(a)
                print "  Most likely you now want to enter \"up<enter>l<enter>\"\n into the debugger to see what happened.\n"
                raise Exception("Grammar Error")
    else:
        print f.__name__+"():\n    \"\"\"%s\"\"\"\n" %f.__doc__.replace("\\n","\n").replace("\return","Returns").replace("\\c ","")
        print "**GRAMMAR ERROR in argument args[1] = %s"%repr(args[1])
        print "  Most likely you now want to enter \"up<enter>l<enter>\"\n into the debugger to see what happened.\n"
        raise Exception("Grammar Error")
    if isinstance(args[2], PythonTypes.StringType):
        pass
    else:
        print f.__name__+"():\n    \"\"\"%s\"\"\"\n" %f.__doc__.replace("\\n","\n").replace("\return","Returns").replace("\\c ","")
        print "**GRAMMAR ERROR in argument args[2] = %s"%repr(args[2])
        print "  Most likely you now want to enter \"up<enter>l<enter>\"\n into the debugger to see what happened.\n"
        raise Exception("Grammar Error")
    return tuple(['struct']+list(args))

def Enum(*args):
    """
    Construct a "enum" node. Valid arguments are 
    (\c Id(), [\c Enumerator()], \c Doc_comment())
    \return (\c "Enum", \c Id(), [\c Enumerator()], \c Doc_comment())
    """
    f = Enum
    if len(args) <> 3:
        print "**GRAMMAR ERROR: expected 3 arguments for a", f.__name__
        print "Most likely you want to enter \"up<enter>l<enter>\" now to see what happened."
        raise Exception("Grammar Error")
    if isinstance(args[0], PythonTypes.StringType):
        pass
    else:
        print f.__name__+"():\n    \"\"\"%s\"\"\"\n" %f.__doc__.replace("\\n","\n").replace("\return","Returns").replace("\\c ","")
        print "**GRAMMAR ERROR in argument args[0] = %s"%repr(args[0])
        print "  Most likely you now want to enter \"up<enter>l<enter>\"\n into the debugger to see what happened.\n"
        raise Exception("Grammar Error")
    if isinstance(args[1], list) or isinstance(args[1], tuple):
        for a in args[1]:
            if isinstance(a, tuple) and a[0] == enumerator:
                pass
            elif isinstance(a, tuple) and a[0] == enumerator_value:
                pass
            else:
                print f.__name__+"():\n    \"\"\"%s\"\"\"\n" %f.__doc__.replace("\\n","\n").replace("\return","Returns").replace("\\c ","")
                print "**GRAMMAR ERROR in argument a = %s"%repr(a)
                print "  Most likely you now want to enter \"up<enter>l<enter>\"\n into the debugger to see what happened.\n"
                raise Exception("Grammar Error")
    else:
        print f.__name__+"():\n    \"\"\"%s\"\"\"\n" %f.__doc__.replace("\\n","\n").replace("\return","Returns").replace("\\c ","")
        print "**GRAMMAR ERROR in argument args[1] = %s"%repr(args[1])
        print "  Most likely you now want to enter \"up<enter>l<enter>\"\n into the debugger to see what happened.\n"
        raise Exception("Grammar Error")
    if isinstance(args[2], PythonTypes.StringType):
        pass
    else:
        print f.__name__+"():\n    \"\"\"%s\"\"\"\n" %f.__doc__.replace("\\n","\n").replace("\return","Returns").replace("\\c ","")
        print "**GRAMMAR ERROR in argument args[2] = %s"%repr(args[2])
        print "  Most likely you now want to enter \"up<enter>l<enter>\"\n into the debugger to see what happened.\n"
        raise Exception("Grammar Error")
    return tuple(['enum']+list(args))

def Interface(*args):
    """
    Construct a "interface" node. Valid arguments are 
    (\c Id(), [\c Extends()], [\c Invariant()], [\c Method()], \c Doc_comment())
    \return (\c "Interface", \c Id(), [\c Extends()], [\c Invariant()], [\c Method()], \c Doc_comment())
    """
    f = Interface
    if len(args) <> 5:
        print "**GRAMMAR ERROR: expected 5 arguments for a", f.__name__
        print "Most likely you want to enter \"up<enter>l<enter>\" now to see what happened."
        raise Exception("Grammar Error")
    if isinstance(args[0], PythonTypes.StringType):
        pass
    else:
        print f.__name__+"():\n    \"\"\"%s\"\"\"\n" %f.__doc__.replace("\\n","\n").replace("\return","Returns").replace("\\c ","")
        print "**GRAMMAR ERROR in argument args[0] = %s"%repr(args[0])
        print "  Most likely you now want to enter \"up<enter>l<enter>\"\n into the debugger to see what happened.\n"
        raise Exception("Grammar Error")
    if isinstance(args[1], list) or isinstance(args[1], tuple):
        for a in args[1]:
            if isinstance(a, tuple) and a[0] == extends:
                pass
            else:
                print f.__name__+"():\n    \"\"\"%s\"\"\"\n" %f.__doc__.replace("\\n","\n").replace("\return","Returns").replace("\\c ","")
                print "**GRAMMAR ERROR in argument a = %s"%repr(a)
                print "  Most likely you now want to enter \"up<enter>l<enter>\"\n into the debugger to see what happened.\n"
                raise Exception("Grammar Error")
    else:
        print f.__name__+"():\n    \"\"\"%s\"\"\"\n" %f.__doc__.replace("\\n","\n").replace("\return","Returns").replace("\\c ","")
        print "**GRAMMAR ERROR in argument args[1] = %s"%repr(args[1])
        print "  Most likely you now want to enter \"up<enter>l<enter>\"\n into the debugger to see what happened.\n"
        raise Exception("Grammar Error")
    if isinstance(args[2], list) or isinstance(args[2], tuple):
        for a in args[2]:
            if isinstance(a, tuple) and a[0] == invariant:
                pass
            else:
                print f.__name__+"():\n    \"\"\"%s\"\"\"\n" %f.__doc__.replace("\\n","\n").replace("\return","Returns").replace("\\c ","")
                print "**GRAMMAR ERROR in argument a = %s"%repr(a)
                print "  Most likely you now want to enter \"up<enter>l<enter>\"\n into the debugger to see what happened.\n"
                raise Exception("Grammar Error")
    else:
        print f.__name__+"():\n    \"\"\"%s\"\"\"\n" %f.__doc__.replace("\\n","\n").replace("\return","Returns").replace("\\c ","")
        print "**GRAMMAR ERROR in argument args[2] = %s"%repr(args[2])
        print "  Most likely you now want to enter \"up<enter>l<enter>\"\n into the debugger to see what happened.\n"
        raise Exception("Grammar Error")
    if isinstance(args[3], list) or isinstance(args[3], tuple):
        for a in args[3]:
            if isinstance(a, tuple) and a[0] == method:
                pass
            else:
                print f.__name__+"():\n    \"\"\"%s\"\"\"\n" %f.__doc__.replace("\\n","\n").replace("\return","Returns").replace("\\c ","")
                print "**GRAMMAR ERROR in argument a = %s"%repr(a)
                print "  Most likely you now want to enter \"up<enter>l<enter>\"\n into the debugger to see what happened.\n"
                raise Exception("Grammar Error")
    else:
        print f.__name__+"():\n    \"\"\"%s\"\"\"\n" %f.__doc__.replace("\\n","\n").replace("\return","Returns").replace("\\c ","")
        print "**GRAMMAR ERROR in argument args[3] = %s"%repr(args[3])
        print "  Most likely you now want to enter \"up<enter>l<enter>\"\n into the debugger to see what happened.\n"
        raise Exception("Grammar Error")
    if isinstance(args[4], PythonTypes.StringType):
        pass
    else:
        print f.__name__+"():\n    \"\"\"%s\"\"\"\n" %f.__doc__.replace("\\n","\n").replace("\return","Returns").replace("\\c ","")
        print "**GRAMMAR ERROR in argument args[4] = %s"%repr(args[4])
        print "  Most likely you now want to enter \"up<enter>l<enter>\"\n into the debugger to see what happened.\n"
        raise Exception("Grammar Error")
    return tuple(['interface']+list(args))

def Class(*args):
    """
    Construct a "class" node. Valid arguments are 
    (\c Id(), [\c Extends()], [\c Implements()], [\c Invariant()], [\c Method()], \c Doc_comment())
    \return (\c "Class", \c Id(), [\c Extends()], [\c Implements()], [\c Invariant()], [\c Method()], \c Doc_comment())
    """
    f = Class
    if len(args) <> 6:
        print "**GRAMMAR ERROR: expected 6 arguments for a", f.__name__
        print "Most likely you want to enter \"up<enter>l<enter>\" now to see what happened."
        raise Exception("Grammar Error")
    if isinstance(args[0], PythonTypes.StringType):
        pass
    else:
        print f.__name__+"():\n    \"\"\"%s\"\"\"\n" %f.__doc__.replace("\\n","\n").replace("\return","Returns").replace("\\c ","")
        print "**GRAMMAR ERROR in argument args[0] = %s"%repr(args[0])
        print "  Most likely you now want to enter \"up<enter>l<enter>\"\n into the debugger to see what happened.\n"
        raise Exception("Grammar Error")
    if isinstance(args[1], list) or isinstance(args[1], tuple):
        for a in args[1]:
            if isinstance(a, tuple) and a[0] == extends:
                pass
            else:
                print f.__name__+"():\n    \"\"\"%s\"\"\"\n" %f.__doc__.replace("\\n","\n").replace("\return","Returns").replace("\\c ","")
                print "**GRAMMAR ERROR in argument a = %s"%repr(a)
                print "  Most likely you now want to enter \"up<enter>l<enter>\"\n into the debugger to see what happened.\n"
                raise Exception("Grammar Error")
    else:
        print f.__name__+"():\n    \"\"\"%s\"\"\"\n" %f.__doc__.replace("\\n","\n").replace("\return","Returns").replace("\\c ","")
        print "**GRAMMAR ERROR in argument args[1] = %s"%repr(args[1])
        print "  Most likely you now want to enter \"up<enter>l<enter>\"\n into the debugger to see what happened.\n"
        raise Exception("Grammar Error")
    if isinstance(args[2], list) or isinstance(args[2], tuple):
        for a in args[2]:
            if isinstance(a, tuple) and a[0] == implements:
                pass
            elif isinstance(a, tuple) and a[0] == implements_all:
                pass
            else:
                print f.__name__+"():\n    \"\"\"%s\"\"\"\n" %f.__doc__.replace("\\n","\n").replace("\return","Returns").replace("\\c ","")
                print "**GRAMMAR ERROR in argument a = %s"%repr(a)
                print "  Most likely you now want to enter \"up<enter>l<enter>\"\n into the debugger to see what happened.\n"
                raise Exception("Grammar Error")
    else:
        print f.__name__+"():\n    \"\"\"%s\"\"\"\n" %f.__doc__.replace("\\n","\n").replace("\return","Returns").replace("\\c ","")
        print "**GRAMMAR ERROR in argument args[2] = %s"%repr(args[2])
        print "  Most likely you now want to enter \"up<enter>l<enter>\"\n into the debugger to see what happened.\n"
        raise Exception("Grammar Error")
    if isinstance(args[3], list) or isinstance(args[3], tuple):
        for a in args[3]:
            if isinstance(a, tuple) and a[0] == invariant:
                pass
            else:
                print f.__name__+"():\n    \"\"\"%s\"\"\"\n" %f.__doc__.replace("\\n","\n").replace("\return","Returns").replace("\\c ","")
                print "**GRAMMAR ERROR in argument a = %s"%repr(a)
                print "  Most likely you now want to enter \"up<enter>l<enter>\"\n into the debugger to see what happened.\n"
                raise Exception("Grammar Error")
    else:
        print f.__name__+"():\n    \"\"\"%s\"\"\"\n" %f.__doc__.replace("\\n","\n").replace("\return","Returns").replace("\\c ","")
        print "**GRAMMAR ERROR in argument args[3] = %s"%repr(args[3])
        print "  Most likely you now want to enter \"up<enter>l<enter>\"\n into the debugger to see what happened.\n"
        raise Exception("Grammar Error")
    if isinstance(args[4], list) or isinstance(args[4], tuple):
        for a in args[4]:
            if isinstance(a, tuple) and a[0] == method:
                pass
            else:
                print f.__name__+"():\n    \"\"\"%s\"\"\"\n" %f.__doc__.replace("\\n","\n").replace("\return","Returns").replace("\\c ","")
                print "**GRAMMAR ERROR in argument a = %s"%repr(a)
                print "  Most likely you now want to enter \"up<enter>l<enter>\"\n into the debugger to see what happened.\n"
                raise Exception("Grammar Error")
    else:
        print f.__name__+"():\n    \"\"\"%s\"\"\"\n" %f.__doc__.replace("\\n","\n").replace("\return","Returns").replace("\\c ","")
        print "**GRAMMAR ERROR in argument args[4] = %s"%repr(args[4])
        print "  Most likely you now want to enter \"up<enter>l<enter>\"\n into the debugger to see what happened.\n"
        raise Exception("Grammar Error")
    if isinstance(args[5], PythonTypes.StringType):
        pass
    else:
        print f.__name__+"():\n    \"\"\"%s\"\"\"\n" %f.__doc__.replace("\\n","\n").replace("\return","Returns").replace("\\c ","")
        print "**GRAMMAR ERROR in argument args[5] = %s"%repr(args[5])
        print "  Most likely you now want to enter \"up<enter>l<enter>\"\n into the debugger to see what happened.\n"
        raise Exception("Grammar Error")
    return tuple(['class']+list(args))

# skipping \c Enumerator= (\c Enumerator|\c Enumerator_value)
def Struct_item(*args):
    """
    Construct a "struct_item" node. Valid arguments are 
    (\c Type_void()
    |\c Rarray(), \c Id())
    \return (\c "Struct_item", \c Type_void()
    |\c Rarray(), \c Id())
    """
    f = Struct_item
    if len(args) <> 2:
        print "**GRAMMAR ERROR: expected 2 arguments for a", f.__name__
        print "Most likely you want to enter \"up<enter>l<enter>\" now to see what happened."
        raise Exception("Grammar Error")
    if args[0] == void:
        pass
    elif isinstance(args[0], tuple) and args[0][0] == primitive_type:
        pass
    elif isinstance(args[0], tuple) and args[0][0] == array:
        pass
    elif isinstance(args[0], tuple) and args[0][0] == scoped_id:
        pass
    elif isinstance(args[0], tuple) and args[0][0] == rarray:
        pass
    else:
        print f.__name__+"():\n    \"\"\"%s\"\"\"\n" %f.__doc__.replace("\\n","\n").replace("\return","Returns").replace("\\c ","")
        print "**GRAMMAR ERROR in argument args[0] = %s"%repr(args[0])
        print "  Most likely you now want to enter \"up<enter>l<enter>\"\n into the debugger to see what happened.\n"
        raise Exception("Grammar Error")
    if isinstance(args[1], PythonTypes.StringType):
        pass
    else:
        print f.__name__+"():\n    \"\"\"%s\"\"\"\n" %f.__doc__.replace("\\n","\n").replace("\return","Returns").replace("\\c ","")
        print "**GRAMMAR ERROR in argument args[1] = %s"%repr(args[1])
        print "  Most likely you now want to enter \"up<enter>l<enter>\"\n into the debugger to see what happened.\n"
        raise Exception("Grammar Error")
    return tuple(['struct_item']+list(args))

# skipping \c Type_void= (void|\c Type)
def Rarray(*args):
    """
    Construct a "rarray" node. Valid arguments are 
    (\c Primitive_type(), \c Dimension(), \c Extents())
    \return (\c "Rarray", \c Primitive_type(), \c Dimension(), \c Extents())
    """
    f = Rarray
    if len(args) <> 3:
        print "**GRAMMAR ERROR: expected 3 arguments for a", f.__name__
        print "Most likely you want to enter \"up<enter>l<enter>\" now to see what happened."
        raise Exception("Grammar Error")
    if isinstance(args[0], tuple) and args[0][0] == primitive_type:
        pass
    else:
        print f.__name__+"():\n    \"\"\"%s\"\"\"\n" %f.__doc__.replace("\\n","\n").replace("\return","Returns").replace("\\c ","")
        print "**GRAMMAR ERROR in argument args[0] = %s"%repr(args[0])
        print "  Most likely you now want to enter \"up<enter>l<enter>\"\n into the debugger to see what happened.\n"
        raise Exception("Grammar Error")
    if isinstance(args[1], PythonTypes.IntType):
        pass
    else:
        print f.__name__+"():\n    \"\"\"%s\"\"\"\n" %f.__doc__.replace("\\n","\n").replace("\return","Returns").replace("\\c ","")
        print "**GRAMMAR ERROR in argument args[1] = %s"%repr(args[1])
        print "  Most likely you now want to enter \"up<enter>l<enter>\"\n into the debugger to see what happened.\n"
        raise Exception("Grammar Error")
    if isinstance(args[2], PythonTypes.IntType):
        pass
    elif isinstance(args[2], PythonTypes.StringType):
        pass
    else:
        print f.__name__+"():\n    \"\"\"%s\"\"\"\n" %f.__doc__.replace("\\n","\n").replace("\return","Returns").replace("\\c ","")
        print "**GRAMMAR ERROR in argument args[2] = %s"%repr(args[2])
        print "  Most likely you now want to enter \"up<enter>l<enter>\"\n into the debugger to see what happened.\n"
        raise Exception("Grammar Error")
    return tuple(['rarray']+list(args))

def Extends(*args):
    """
    Construct a "extends" node. Valid arguments are 
    (\c Scoped_id())
    \return (\c "Extends", \c Scoped_id())
    """
    f = Extends
    if len(args) <> 1:
        print "**GRAMMAR ERROR: expected 1 arguments for a", f.__name__
        print "Most likely you want to enter \"up<enter>l<enter>\" now to see what happened."
        raise Exception("Grammar Error")
    if isinstance(args[0], tuple) and args[0][0] == scoped_id:
        pass
    else:
        print f.__name__+"():\n    \"\"\"%s\"\"\"\n" %f.__doc__.replace("\\n","\n").replace("\return","Returns").replace("\\c ","")
        print "**GRAMMAR ERROR in argument args[0] = %s"%repr(args[0])
        print "  Most likely you now want to enter \"up<enter>l<enter>\"\n into the debugger to see what happened.\n"
        raise Exception("Grammar Error")
    return tuple(['extends']+list(args))

# skipping \c Implements= (\c Implements|\c Implements_all)
def Invariant(*args):
    """
    Construct a "invariant" node. Valid arguments are 
    (\c Assertion())
    \return (\c "Invariant", \c Assertion())
    """
    f = Invariant
    if len(args) <> 1:
        print "**GRAMMAR ERROR: expected 1 arguments for a", f.__name__
        print "Most likely you want to enter \"up<enter>l<enter>\" now to see what happened."
        raise Exception("Grammar Error")
    if isinstance(args[0], tuple) and args[0][0] == assertion:
        pass
    else:
        print f.__name__+"():\n    \"\"\"%s\"\"\"\n" %f.__doc__.replace("\\n","\n").replace("\return","Returns").replace("\\c ","")
        print "**GRAMMAR ERROR in argument args[0] = %s"%repr(args[0])
        print "  Most likely you now want to enter \"up<enter>l<enter>\"\n into the debugger to see what happened.\n"
        raise Exception("Grammar Error")
    return tuple(['invariant']+list(args))

def Method(*args):
    """
    Construct a "method" node. Valid arguments are 
    (\c Type_void(), \c Method_name(), [\c Method_attr()], [\c Arg()], [\c Except()], [\c From()], [\c Require()], [\c Ensure()], \c Doc_comment())
    \return (\c "Method", \c Type_void(), \c Method_name(), [\c Method_attr()], [\c Arg()], [\c Except()], [\c From()], [\c Require()], [\c Ensure()], \c Doc_comment())
    """
    f = Method
    if len(args) <> 9:
        print "**GRAMMAR ERROR: expected 9 arguments for a", f.__name__
        print "Most likely you want to enter \"up<enter>l<enter>\" now to see what happened."
        raise Exception("Grammar Error")
    if args[0] == void:
        pass
    elif isinstance(args[0], tuple) and args[0][0] == primitive_type:
        pass
    elif isinstance(args[0], tuple) and args[0][0] == array:
        pass
    elif isinstance(args[0], tuple) and args[0][0] == scoped_id:
        pass
    else:
        print f.__name__+"():\n    \"\"\"%s\"\"\"\n" %f.__doc__.replace("\\n","\n").replace("\return","Returns").replace("\\c ","")
        print "**GRAMMAR ERROR in argument args[0] = %s"%repr(args[0])
        print "  Most likely you now want to enter \"up<enter>l<enter>\"\n into the debugger to see what happened.\n"
        raise Exception("Grammar Error")
    if isinstance(args[1], tuple) and args[1][0] == method_name:
        pass
    else:
        print f.__name__+"():\n    \"\"\"%s\"\"\"\n" %f.__doc__.replace("\\n","\n").replace("\return","Returns").replace("\\c ","")
        print "**GRAMMAR ERROR in argument args[1] = %s"%repr(args[1])
        print "  Most likely you now want to enter \"up<enter>l<enter>\"\n into the debugger to see what happened.\n"
        raise Exception("Grammar Error")
    if isinstance(args[2], list) or isinstance(args[2], tuple):
        for a in args[2]:
            if a == oneway:
                pass
            elif a == local:
                pass
            elif a == static:
                pass
            elif a == abstract:
                pass
            elif a == final:
                pass
            elif a == nonblocking:
                pass
            elif a == copy:
                pass
            else:
                print f.__name__+"():\n    \"\"\"%s\"\"\"\n" %f.__doc__.replace("\\n","\n").replace("\return","Returns").replace("\\c ","")
                print "**GRAMMAR ERROR in argument a = %s"%repr(a)
                print "  Most likely you now want to enter \"up<enter>l<enter>\"\n into the debugger to see what happened.\n"
                raise Exception("Grammar Error")
    else:
        print f.__name__+"():\n    \"\"\"%s\"\"\"\n" %f.__doc__.replace("\\n","\n").replace("\return","Returns").replace("\\c ","")
        print "**GRAMMAR ERROR in argument args[2] = %s"%repr(args[2])
        print "  Most likely you now want to enter \"up<enter>l<enter>\"\n into the debugger to see what happened.\n"
        raise Exception("Grammar Error")
    if isinstance(args[3], list) or isinstance(args[3], tuple):
        for a in args[3]:
            if isinstance(a, tuple) and a[0] == arg:
                pass
            else:
                print f.__name__+"():\n    \"\"\"%s\"\"\"\n" %f.__doc__.replace("\\n","\n").replace("\return","Returns").replace("\\c ","")
                print "**GRAMMAR ERROR in argument a = %s"%repr(a)
                print "  Most likely you now want to enter \"up<enter>l<enter>\"\n into the debugger to see what happened.\n"
                raise Exception("Grammar Error")
    else:
        print f.__name__+"():\n    \"\"\"%s\"\"\"\n" %f.__doc__.replace("\\n","\n").replace("\return","Returns").replace("\\c ","")
        print "**GRAMMAR ERROR in argument args[3] = %s"%repr(args[3])
        print "  Most likely you now want to enter \"up<enter>l<enter>\"\n into the debugger to see what happened.\n"
        raise Exception("Grammar Error")
    if isinstance(args[4], list) or isinstance(args[4], tuple):
        for a in args[4]:
            if isinstance(a, tuple) and a[0] == except_:
                pass
            else:
                print f.__name__+"():\n    \"\"\"%s\"\"\"\n" %f.__doc__.replace("\\n","\n").replace("\return","Returns").replace("\\c ","")
                print "**GRAMMAR ERROR in argument a = %s"%repr(a)
                print "  Most likely you now want to enter \"up<enter>l<enter>\"\n into the debugger to see what happened.\n"
                raise Exception("Grammar Error")
    else:
        print f.__name__+"():\n    \"\"\"%s\"\"\"\n" %f.__doc__.replace("\\n","\n").replace("\return","Returns").replace("\\c ","")
        print "**GRAMMAR ERROR in argument args[4] = %s"%repr(args[4])
        print "  Most likely you now want to enter \"up<enter>l<enter>\"\n into the debugger to see what happened.\n"
        raise Exception("Grammar Error")
    if isinstance(args[5], list) or isinstance(args[5], tuple):
        for a in args[5]:
            if isinstance(a, tuple) and a[0] == from_:
                pass
            else:
                print f.__name__+"():\n    \"\"\"%s\"\"\"\n" %f.__doc__.replace("\\n","\n").replace("\return","Returns").replace("\\c ","")
                print "**GRAMMAR ERROR in argument a = %s"%repr(a)
                print "  Most likely you now want to enter \"up<enter>l<enter>\"\n into the debugger to see what happened.\n"
                raise Exception("Grammar Error")
    else:
        print f.__name__+"():\n    \"\"\"%s\"\"\"\n" %f.__doc__.replace("\\n","\n").replace("\return","Returns").replace("\\c ","")
        print "**GRAMMAR ERROR in argument args[5] = %s"%repr(args[5])
        print "  Most likely you now want to enter \"up<enter>l<enter>\"\n into the debugger to see what happened.\n"
        raise Exception("Grammar Error")
    if isinstance(args[6], list) or isinstance(args[6], tuple):
        for a in args[6]:
            if isinstance(a, tuple) and a[0] == require:
                pass
            else:
                print f.__name__+"():\n    \"\"\"%s\"\"\"\n" %f.__doc__.replace("\\n","\n").replace("\return","Returns").replace("\\c ","")
                print "**GRAMMAR ERROR in argument a = %s"%repr(a)
                print "  Most likely you now want to enter \"up<enter>l<enter>\"\n into the debugger to see what happened.\n"
                raise Exception("Grammar Error")
    else:
        print f.__name__+"():\n    \"\"\"%s\"\"\"\n" %f.__doc__.replace("\\n","\n").replace("\return","Returns").replace("\\c ","")
        print "**GRAMMAR ERROR in argument args[6] = %s"%repr(args[6])
        print "  Most likely you now want to enter \"up<enter>l<enter>\"\n into the debugger to see what happened.\n"
        raise Exception("Grammar Error")
    if isinstance(args[7], list) or isinstance(args[7], tuple):
        for a in args[7]:
            if isinstance(a, tuple) and a[0] == ensure:
                pass
            else:
                print f.__name__+"():\n    \"\"\"%s\"\"\"\n" %f.__doc__.replace("\\n","\n").replace("\return","Returns").replace("\\c ","")
                print "**GRAMMAR ERROR in argument a = %s"%repr(a)
                print "  Most likely you now want to enter \"up<enter>l<enter>\"\n into the debugger to see what happened.\n"
                raise Exception("Grammar Error")
    else:
        print f.__name__+"():\n    \"\"\"%s\"\"\"\n" %f.__doc__.replace("\\n","\n").replace("\return","Returns").replace("\\c ","")
        print "**GRAMMAR ERROR in argument args[7] = %s"%repr(args[7])
        print "  Most likely you now want to enter \"up<enter>l<enter>\"\n into the debugger to see what happened.\n"
        raise Exception("Grammar Error")
    if isinstance(args[8], PythonTypes.StringType):
        pass
    else:
        print f.__name__+"():\n    \"\"\"%s\"\"\"\n" %f.__doc__.replace("\\n","\n").replace("\return","Returns").replace("\\c ","")
        print "**GRAMMAR ERROR in argument args[8] = %s"%repr(args[8])
        print "  Most likely you now want to enter \"up<enter>l<enter>\"\n into the debugger to see what happened.\n"
        raise Exception("Grammar Error")
    return tuple(['method']+list(args))

# skipping \c Method_attr= (oneway|local|static|abstract|final|nonblocking|copy)
def Arg(*args):
    """
    Construct a "arg" node. Valid arguments are 
    ([\c Arg_attr()], \c Mode(), \c Type_void()
    |\c Rarray(), \c Id())
    \return (\c "Arg", [\c Arg_attr()], \c Mode(), \c Type_void()
    |\c Rarray(), \c Id())
    """
    f = Arg
    if len(args) <> 4:
        print "**GRAMMAR ERROR: expected 4 arguments for a", f.__name__
        print "Most likely you want to enter \"up<enter>l<enter>\" now to see what happened."
        raise Exception("Grammar Error")
    if isinstance(args[0], list) or isinstance(args[0], tuple):
        for a in args[0]:
            if a == copy:
                pass
            elif isinstance(a, list) or isinstance(a, tuple):
                for a in a:
                    if isinstance(a, PythonTypes.StringType):
                        pass
                    else:
                        print f.__name__+"():\n    \"\"\"%s\"\"\"\n" %f.__doc__.replace("\\n","\n").replace("\return","Returns").replace("\\c ","")
                        print "**GRAMMAR ERROR in argument a = %s"%repr(a)
                        print "  Most likely you now want to enter \"up<enter>l<enter>\"\n into the debugger to see what happened.\n"
                        raise Exception("Grammar Error")
            else:
                print f.__name__+"():\n    \"\"\"%s\"\"\"\n" %f.__doc__.replace("\\n","\n").replace("\return","Returns").replace("\\c ","")
                print "**GRAMMAR ERROR in argument a = %s"%repr(a)
                print "  Most likely you now want to enter \"up<enter>l<enter>\"\n into the debugger to see what happened.\n"
                raise Exception("Grammar Error")
    else:
        print f.__name__+"():\n    \"\"\"%s\"\"\"\n" %f.__doc__.replace("\\n","\n").replace("\return","Returns").replace("\\c ","")
        print "**GRAMMAR ERROR in argument args[0] = %s"%repr(args[0])
        print "  Most likely you now want to enter \"up<enter>l<enter>\"\n into the debugger to see what happened.\n"
        raise Exception("Grammar Error")
    if args[1] == in_:
        pass
    elif args[1] == out:
        pass
    elif args[1] == inout:
        pass
    else:
        print f.__name__+"():\n    \"\"\"%s\"\"\"\n" %f.__doc__.replace("\\n","\n").replace("\return","Returns").replace("\\c ","")
        print "**GRAMMAR ERROR in argument args[1] = %s"%repr(args[1])
        print "  Most likely you now want to enter \"up<enter>l<enter>\"\n into the debugger to see what happened.\n"
        raise Exception("Grammar Error")
    if args[2] == void:
        pass
    elif isinstance(args[2], tuple) and args[2][0] == primitive_type:
        pass
    elif isinstance(args[2], tuple) and args[2][0] == array:
        pass
    elif isinstance(args[2], tuple) and args[2][0] == scoped_id:
        pass
    elif isinstance(args[2], tuple) and args[2][0] == rarray:
        pass
    else:
        print f.__name__+"():\n    \"\"\"%s\"\"\"\n" %f.__doc__.replace("\\n","\n").replace("\return","Returns").replace("\\c ","")
        print "**GRAMMAR ERROR in argument args[2] = %s"%repr(args[2])
        print "  Most likely you now want to enter \"up<enter>l<enter>\"\n into the debugger to see what happened.\n"
        raise Exception("Grammar Error")
    if isinstance(args[3], PythonTypes.StringType):
        pass
    else:
        print f.__name__+"():\n    \"\"\"%s\"\"\"\n" %f.__doc__.replace("\\n","\n").replace("\return","Returns").replace("\\c ","")
        print "**GRAMMAR ERROR in argument args[3] = %s"%repr(args[3])
        print "  Most likely you now want to enter \"up<enter>l<enter>\"\n into the debugger to see what happened.\n"
        raise Exception("Grammar Error")
    return tuple(['arg']+list(args))

def Except(*args):
    """
    Construct a "except" node. Valid arguments are 
    (\c Scoped_id())
    \return (\c "Except", \c Scoped_id())
    """
    f = Except
    if len(args) <> 1:
        print "**GRAMMAR ERROR: expected 1 arguments for a", f.__name__
        print "Most likely you want to enter \"up<enter>l<enter>\" now to see what happened."
        raise Exception("Grammar Error")
    if isinstance(args[0], tuple) and args[0][0] == scoped_id:
        pass
    else:
        print f.__name__+"():\n    \"\"\"%s\"\"\"\n" %f.__doc__.replace("\\n","\n").replace("\return","Returns").replace("\\c ","")
        print "**GRAMMAR ERROR in argument args[0] = %s"%repr(args[0])
        print "  Most likely you now want to enter \"up<enter>l<enter>\"\n into the debugger to see what happened.\n"
        raise Exception("Grammar Error")
    return tuple(['except']+list(args))

def From(*args):
    """
    Construct a "from" node. Valid arguments are 
    (\c Scoped_id())
    \return (\c "From", \c Scoped_id())
    """
    f = From
    if len(args) <> 1:
        print "**GRAMMAR ERROR: expected 1 arguments for a", f.__name__
        print "Most likely you want to enter \"up<enter>l<enter>\" now to see what happened."
        raise Exception("Grammar Error")
    if isinstance(args[0], tuple) and args[0][0] == scoped_id:
        pass
    else:
        print f.__name__+"():\n    \"\"\"%s\"\"\"\n" %f.__doc__.replace("\\n","\n").replace("\return","Returns").replace("\\c ","")
        print "**GRAMMAR ERROR in argument args[0] = %s"%repr(args[0])
        print "  Most likely you now want to enter \"up<enter>l<enter>\"\n into the debugger to see what happened.\n"
        raise Exception("Grammar Error")
    return tuple(['from']+list(args))

def Require(*args):
    """
    Construct a "require" node. Valid arguments are 
    (\c Assertion())
    \return (\c "Require", \c Assertion())
    """
    f = Require
    if len(args) <> 1:
        print "**GRAMMAR ERROR: expected 1 arguments for a", f.__name__
        print "Most likely you want to enter \"up<enter>l<enter>\" now to see what happened."
        raise Exception("Grammar Error")
    if isinstance(args[0], tuple) and args[0][0] == assertion:
        pass
    else:
        print f.__name__+"():\n    \"\"\"%s\"\"\"\n" %f.__doc__.replace("\\n","\n").replace("\return","Returns").replace("\\c ","")
        print "**GRAMMAR ERROR in argument args[0] = %s"%repr(args[0])
        print "  Most likely you now want to enter \"up<enter>l<enter>\"\n into the debugger to see what happened.\n"
        raise Exception("Grammar Error")
    return tuple(['require']+list(args))

def Ensure(*args):
    """
    Construct a "ensure" node. Valid arguments are 
    (\c Assertion())
    \return (\c "Ensure", \c Assertion())
    """
    f = Ensure
    if len(args) <> 1:
        print "**GRAMMAR ERROR: expected 1 arguments for a", f.__name__
        print "Most likely you want to enter \"up<enter>l<enter>\" now to see what happened."
        raise Exception("Grammar Error")
    if isinstance(args[0], tuple) and args[0][0] == assertion:
        pass
    else:
        print f.__name__+"():\n    \"\"\"%s\"\"\"\n" %f.__doc__.replace("\\n","\n").replace("\return","Returns").replace("\\c ","")
        print "**GRAMMAR ERROR in argument args[0] = %s"%repr(args[0])
        print "  Most likely you now want to enter \"up<enter>l<enter>\"\n into the debugger to see what happened.\n"
        raise Exception("Grammar Error")
    return tuple(['ensure']+list(args))

def Method_name(*args):
    """
    Construct a "method_name" node. Valid arguments are 
    (\c Id(), \c Extension())
    \return (\c "Method_name", \c Id(), \c Extension())
    """
    f = Method_name
    if len(args) <> 2:
        print "**GRAMMAR ERROR: expected 2 arguments for a", f.__name__
        print "Most likely you want to enter \"up<enter>l<enter>\" now to see what happened."
        raise Exception("Grammar Error")
    if isinstance(args[0], PythonTypes.StringType):
        pass
    else:
        print f.__name__+"():\n    \"\"\"%s\"\"\"\n" %f.__doc__.replace("\\n","\n").replace("\return","Returns").replace("\\c ","")
        print "**GRAMMAR ERROR in argument args[0] = %s"%repr(args[0])
        print "  Most likely you now want to enter \"up<enter>l<enter>\"\n into the debugger to see what happened.\n"
        raise Exception("Grammar Error")
    if isinstance(args[1], PythonTypes.StringType):
        pass
    else:
        print f.__name__+"():\n    \"\"\"%s\"\"\"\n" %f.__doc__.replace("\\n","\n").replace("\return","Returns").replace("\\c ","")
        print "**GRAMMAR ERROR in argument args[1] = %s"%repr(args[1])
        print "  Most likely you now want to enter \"up<enter>l<enter>\"\n into the debugger to see what happened.\n"
        raise Exception("Grammar Error")
    return tuple(['method_name']+list(args))

def STR():
    return STR
# skipping \c Type= (\c Primitive_type|\c Array|\c Scoped_id)
def Assertion(*args):
    """
    Construct a "assertion" node. Valid arguments are 
    (\c Id(), \c AssertExpr())
    \return (\c "Assertion", \c Id(), \c AssertExpr())
    """
    f = Assertion
    if len(args) <> 2:
        print "**GRAMMAR ERROR: expected 2 arguments for a", f.__name__
        print "Most likely you want to enter \"up<enter>l<enter>\" now to see what happened."
        raise Exception("Grammar Error")
    if isinstance(args[0], PythonTypes.StringType):
        pass
    else:
        print f.__name__+"():\n    \"\"\"%s\"\"\"\n" %f.__doc__.replace("\\n","\n").replace("\return","Returns").replace("\\c ","")
        print "**GRAMMAR ERROR in argument args[0] = %s"%repr(args[0])
        print "  Most likely you now want to enter \"up<enter>l<enter>\"\n into the debugger to see what happened.\n"
        raise Exception("Grammar Error")
    if isinstance(args[1], tuple) and args[1][0] == infix_expr:
        pass
    elif isinstance(args[1], tuple) and args[1][0] == prefix_expr:
        pass
    elif isinstance(args[1], tuple) and args[1][0] == fn_eval:
        pass
    elif isinstance(args[1], tuple) and args[1][0] == var_ref:
        pass
    elif isinstance(args[1], PythonTypes.StringType):
        pass
    elif isinstance(args[1], PythonTypes.IntType):
        pass
    elif isinstance(args[1], PythonTypes.FloatType):
        pass
    elif isinstance(args[1], PythonTypes.StringType):
        pass
    elif args[1] == pure:
        pass
    elif args[1] == result:
        pass
    elif isinstance(args[1], tuple) and args[1][0] == complex:
        pass
    else:
        print f.__name__+"():\n    \"\"\"%s\"\"\"\n" %f.__doc__.replace("\\n","\n").replace("\return","Returns").replace("\\c ","")
        print "**GRAMMAR ERROR in argument args[1] = %s"%repr(args[1])
        print "  Most likely you now want to enter \"up<enter>l<enter>\"\n into the debugger to see what happened.\n"
        raise Exception("Grammar Error")
    return tuple(['assertion']+list(args))

# skipping \c AssertExpr= (\c Infix_expr|\c Prefix_expr|\c Fn_eval|\c Var_ref|\c Id|\c Literal)
# skipping \c Arg_attr= (copy|[STR])
# skipping \c Mode= (in|out|inout)
def Array(*args):
    """
    Construct a "array" node. Valid arguments are 
    (\c Scalar_type(), \c Dimension(), \c Orientation())
    \return (\c "Array", \c Scalar_type(), \c Dimension(), \c Orientation())
    """
    f = Array
    if len(args) <> 3:
        print "**GRAMMAR ERROR: expected 3 arguments for a", f.__name__
        print "Most likely you want to enter \"up<enter>l<enter>\" now to see what happened."
        raise Exception("Grammar Error")
    if isinstance(args[0], tuple) and args[0][0] == primitive_type:
        pass
    elif isinstance(args[0], tuple) and args[0][0] == scoped_id:
        pass
    else:
        print f.__name__+"():\n    \"\"\"%s\"\"\"\n" %f.__doc__.replace("\\n","\n").replace("\return","Returns").replace("\\c ","")
        print "**GRAMMAR ERROR in argument args[0] = %s"%repr(args[0])
        print "  Most likely you now want to enter \"up<enter>l<enter>\"\n into the debugger to see what happened.\n"
        raise Exception("Grammar Error")
    if isinstance(args[1], PythonTypes.IntType):
        pass
    else:
        print f.__name__+"():\n    \"\"\"%s\"\"\"\n" %f.__doc__.replace("\\n","\n").replace("\return","Returns").replace("\\c ","")
        print "**GRAMMAR ERROR in argument args[1] = %s"%repr(args[1])
        print "  Most likely you now want to enter \"up<enter>l<enter>\"\n into the debugger to see what happened.\n"
        raise Exception("Grammar Error")
    if args[2] == row_major:
        pass
    elif args[2] == column_major:
        pass
    else:
        print f.__name__+"():\n    \"\"\"%s\"\"\"\n" %f.__doc__.replace("\\n","\n").replace("\return","Returns").replace("\\c ","")
        print "**GRAMMAR ERROR in argument args[2] = %s"%repr(args[2])
        print "  Most likely you now want to enter \"up<enter>l<enter>\"\n into the debugger to see what happened.\n"
        raise Exception("Grammar Error")
    return tuple(['array']+list(args))

def Primitive_type(*args):
    """
    Construct a "primitive_type" node. Valid arguments are 
    (Bool()
    |Char()
    |Int()
    |Long()
    |Float()
    |Double()
    |Fcomplex()
    |Dcomplex()
    |String()
    |Opaque())
    \return (\c "Primitive_type", Bool()
    |Char()
    |Int()
    |Long()
    |Float()
    |Double()
    |Fcomplex()
    |Dcomplex()
    |String()
    |Opaque())
    """
    f = Primitive_type
    if len(args) <> 1:
        print "**GRAMMAR ERROR: expected 1 arguments for a", f.__name__
        print "Most likely you want to enter \"up<enter>l<enter>\" now to see what happened."
        raise Exception("Grammar Error")
    if args[0] == bool:
        pass
    elif args[0] == char:
        pass
    elif args[0] == int:
        pass
    elif args[0] == long:
        pass
    elif args[0] == float:
        pass
    elif args[0] == double:
        pass
    elif args[0] == fcomplex:
        pass
    elif args[0] == dcomplex:
        pass
    elif args[0] == string:
        pass
    elif args[0] == opaque:
        pass
    else:
        print f.__name__+"():\n    \"\"\"%s\"\"\"\n" %f.__doc__.replace("\\n","\n").replace("\return","Returns").replace("\\c ","")
        print "**GRAMMAR ERROR in argument args[0] = %s"%repr(args[0])
        print "  Most likely you now want to enter \"up<enter>l<enter>\"\n into the debugger to see what happened.\n"
        raise Exception("Grammar Error")
    return tuple(['primitive_type']+list(args))

# skipping \c Scalar_type= (\c Primitive_type|\c Scoped_id)
def INT():
    return INT
# skipping \c Orientation= (row_major|column_major)
# skipping \c Extents= \c SimpleIntExpression
# skipping \c SimpleIntExpression= (INT|\c Id)
# skipping \c Bin_op= (log_or|log_and|eq|ne|bit_or|bit_and|bit_xor|lt|gt|le|ge|lshift|rshift|plus|minus|times|divide|modulo|rem|pow|implies|iff)
# skipping \c Un_op= (is|log_not|bit_not)
# skipping \c Literal= (INT|FLOAT|STR|pure|result|\c Complex)
def STR():
    return STR
def Complex(*args):
    """
    Construct a "complex" node. Valid arguments are 
    (FLOAT(), FLOAT())
    \return (\c "Complex", FLOAT(), FLOAT())
    """
    f = Complex
    if len(args) <> 2:
        print "**GRAMMAR ERROR: expected 2 arguments for a", f.__name__
        print "Most likely you want to enter \"up<enter>l<enter>\" now to see what happened."
        raise Exception("Grammar Error")
    if isinstance(args[0], PythonTypes.FloatType):
        pass
    else:
        print f.__name__+"():\n    \"\"\"%s\"\"\"\n" %f.__doc__.replace("\\n","\n").replace("\return","Returns").replace("\\c ","")
        print "**GRAMMAR ERROR in argument args[0] = %s"%repr(args[0])
        print "  Most likely you now want to enter \"up<enter>l<enter>\"\n into the debugger to see what happened.\n"
        raise Exception("Grammar Error")
    if isinstance(args[1], PythonTypes.FloatType):
        pass
    else:
        print f.__name__+"():\n    \"\"\"%s\"\"\"\n" %f.__doc__.replace("\\n","\n").replace("\return","Returns").replace("\\c ","")
        print "**GRAMMAR ERROR in argument args[1] = %s"%repr(args[1])
        print "  Most likely you now want to enter \"up<enter>l<enter>\"\n into the debugger to see what happened.\n"
        raise Exception("Grammar Error")
    return tuple(['complex']+list(args))

def Enumerator(*args):
    """
    Construct a "enumerator" node. Valid arguments are 
    (\c Id())
    \return (\c "Enumerator", \c Id())
    """
    f = Enumerator
    if len(args) <> 1:
        print "**GRAMMAR ERROR: expected 1 arguments for a", f.__name__
        print "Most likely you want to enter \"up<enter>l<enter>\" now to see what happened."
        raise Exception("Grammar Error")
    if isinstance(args[0], PythonTypes.StringType):
        pass
    else:
        print f.__name__+"():\n    \"\"\"%s\"\"\"\n" %f.__doc__.replace("\\n","\n").replace("\return","Returns").replace("\\c ","")
        print "**GRAMMAR ERROR in argument args[0] = %s"%repr(args[0])
        print "  Most likely you now want to enter \"up<enter>l<enter>\"\n into the debugger to see what happened.\n"
        raise Exception("Grammar Error")
    return tuple(['enumerator']+list(args))

def Enumerator_value(*args):
    """
    Construct a "enumerator_value" node. Valid arguments are 
    (\c Id(), INT())
    \return (\c "Enumerator_value", \c Id(), INT())
    """
    f = Enumerator_value
    if len(args) <> 2:
        print "**GRAMMAR ERROR: expected 2 arguments for a", f.__name__
        print "Most likely you want to enter \"up<enter>l<enter>\" now to see what happened."
        raise Exception("Grammar Error")
    if isinstance(args[0], PythonTypes.StringType):
        pass
    else:
        print f.__name__+"():\n    \"\"\"%s\"\"\"\n" %f.__doc__.replace("\\n","\n").replace("\return","Returns").replace("\\c ","")
        print "**GRAMMAR ERROR in argument args[0] = %s"%repr(args[0])
        print "  Most likely you now want to enter \"up<enter>l<enter>\"\n into the debugger to see what happened.\n"
        raise Exception("Grammar Error")
    if isinstance(args[1], PythonTypes.IntType):
        pass
    else:
        print f.__name__+"():\n    \"\"\"%s\"\"\"\n" %f.__doc__.replace("\\n","\n").replace("\return","Returns").replace("\\c ","")
        print "**GRAMMAR ERROR in argument args[1] = %s"%repr(args[1])
        print "  Most likely you now want to enter \"up<enter>l<enter>\"\n into the debugger to see what happened.\n"
        raise Exception("Grammar Error")
    return tuple(['enumerator_value']+list(args))

def Implements(*args):
    """
    Construct a "implements" node. Valid arguments are 
    (\c Scoped_id())
    \return (\c "Implements", \c Scoped_id())
    """
    f = Implements
    if len(args) <> 1:
        print "**GRAMMAR ERROR: expected 1 arguments for a", f.__name__
        print "Most likely you want to enter \"up<enter>l<enter>\" now to see what happened."
        raise Exception("Grammar Error")
    if isinstance(args[0], tuple) and args[0][0] == scoped_id:
        pass
    else:
        print f.__name__+"():\n    \"\"\"%s\"\"\"\n" %f.__doc__.replace("\\n","\n").replace("\return","Returns").replace("\\c ","")
        print "**GRAMMAR ERROR in argument args[0] = %s"%repr(args[0])
        print "  Most likely you now want to enter \"up<enter>l<enter>\"\n into the debugger to see what happened.\n"
        raise Exception("Grammar Error")
    return tuple(['implements']+list(args))

def Implements_all(*args):
    """
    Construct a "implements_all" node. Valid arguments are 
    (\c Scoped_id())
    \return (\c "Implements_all", \c Scoped_id())
    """
    f = Implements_all
    if len(args) <> 1:
        print "**GRAMMAR ERROR: expected 1 arguments for a", f.__name__
        print "Most likely you want to enter \"up<enter>l<enter>\" now to see what happened."
        raise Exception("Grammar Error")
    if isinstance(args[0], tuple) and args[0][0] == scoped_id:
        pass
    else:
        print f.__name__+"():\n    \"\"\"%s\"\"\"\n" %f.__doc__.replace("\\n","\n").replace("\return","Returns").replace("\\c ","")
        print "**GRAMMAR ERROR in argument args[0] = %s"%repr(args[0])
        print "  Most likely you now want to enter \"up<enter>l<enter>\"\n into the debugger to see what happened.\n"
        raise Exception("Grammar Error")
    return tuple(['implements_all']+list(args))

def Custom_attribute(*args):
    """
    Construct a "custom_attribute" node. Valid arguments are 
    (STR())
    \return (\c "Custom_attribute", STR())
    """
    f = Custom_attribute
    if len(args) <> 1:
        print "**GRAMMAR ERROR: expected 1 arguments for a", f.__name__
        print "Most likely you want to enter \"up<enter>l<enter>\" now to see what happened."
        raise Exception("Grammar Error")
    if isinstance(args[0], PythonTypes.StringType):
        pass
    else:
        print f.__name__+"():\n    \"\"\"%s\"\"\"\n" %f.__doc__.replace("\\n","\n").replace("\return","Returns").replace("\\c ","")
        print "**GRAMMAR ERROR in argument args[0] = %s"%repr(args[0])
        print "  Most likely you now want to enter \"up<enter>l<enter>\"\n into the debugger to see what happened.\n"
        raise Exception("Grammar Error")
    return tuple(['custom_attribute']+list(args))

def Custom_attribute_assoc(*args):
    """
    Construct a "custom_attribute_assoc" node. Valid arguments are 
    (STR(), STR())
    \return (\c "Custom_attribute_assoc", STR(), STR())
    """
    f = Custom_attribute_assoc
    if len(args) <> 2:
        print "**GRAMMAR ERROR: expected 2 arguments for a", f.__name__
        print "Most likely you want to enter \"up<enter>l<enter>\" now to see what happened."
        raise Exception("Grammar Error")
    if isinstance(args[0], PythonTypes.StringType):
        pass
    else:
        print f.__name__+"():\n    \"\"\"%s\"\"\"\n" %f.__doc__.replace("\\n","\n").replace("\return","Returns").replace("\\c ","")
        print "**GRAMMAR ERROR in argument args[0] = %s"%repr(args[0])
        print "  Most likely you now want to enter \"up<enter>l<enter>\"\n into the debugger to see what happened.\n"
        raise Exception("Grammar Error")
    if isinstance(args[1], PythonTypes.StringType):
        pass
    else:
        print f.__name__+"():\n    \"\"\"%s\"\"\"\n" %f.__doc__.replace("\\n","\n").replace("\return","Returns").replace("\\c ","")
        print "**GRAMMAR ERROR in argument args[1] = %s"%repr(args[1])
        print "  Most likely you now want to enter \"up<enter>l<enter>\"\n into the debugger to see what happened.\n"
        raise Exception("Grammar Error")
    return tuple(['custom_attribute_assoc']+list(args))

def Infix_expr(*args):
    """
    Construct a "infix_expr" node. Valid arguments are 
    (\c Bin_op(), \c AssertExpr(), \c AssertExpr())
    \return (\c "Infix_expr", \c Bin_op(), \c AssertExpr(), \c AssertExpr())
    """
    f = Infix_expr
    if len(args) <> 3:
        print "**GRAMMAR ERROR: expected 3 arguments for a", f.__name__
        print "Most likely you want to enter \"up<enter>l<enter>\" now to see what happened."
        raise Exception("Grammar Error")
    if args[0] == log_or:
        pass
    elif args[0] == log_and:
        pass
    elif args[0] == eq:
        pass
    elif args[0] == ne:
        pass
    elif args[0] == bit_or:
        pass
    elif args[0] == bit_and:
        pass
    elif args[0] == bit_xor:
        pass
    elif args[0] == lt:
        pass
    elif args[0] == gt:
        pass
    elif args[0] == le:
        pass
    elif args[0] == ge:
        pass
    elif args[0] == lshift:
        pass
    elif args[0] == rshift:
        pass
    elif args[0] == plus:
        pass
    elif args[0] == minus:
        pass
    elif args[0] == times:
        pass
    elif args[0] == divide:
        pass
    elif args[0] == modulo:
        pass
    elif args[0] == rem:
        pass
    elif args[0] == pow:
        pass
    elif args[0] == implies:
        pass
    elif args[0] == iff:
        pass
    else:
        print f.__name__+"():\n    \"\"\"%s\"\"\"\n" %f.__doc__.replace("\\n","\n").replace("\return","Returns").replace("\\c ","")
        print "**GRAMMAR ERROR in argument args[0] = %s"%repr(args[0])
        print "  Most likely you now want to enter \"up<enter>l<enter>\"\n into the debugger to see what happened.\n"
        raise Exception("Grammar Error")
    if isinstance(args[1], tuple) and args[1][0] == infix_expr:
        pass
    elif isinstance(args[1], tuple) and args[1][0] == prefix_expr:
        pass
    elif isinstance(args[1], tuple) and args[1][0] == fn_eval:
        pass
    elif isinstance(args[1], tuple) and args[1][0] == var_ref:
        pass
    elif isinstance(args[1], PythonTypes.StringType):
        pass
    elif isinstance(args[1], PythonTypes.IntType):
        pass
    elif isinstance(args[1], PythonTypes.FloatType):
        pass
    elif isinstance(args[1], PythonTypes.StringType):
        pass
    elif args[1] == pure:
        pass
    elif args[1] == result:
        pass
    elif isinstance(args[1], tuple) and args[1][0] == complex:
        pass
    else:
        print f.__name__+"():\n    \"\"\"%s\"\"\"\n" %f.__doc__.replace("\\n","\n").replace("\return","Returns").replace("\\c ","")
        print "**GRAMMAR ERROR in argument args[1] = %s"%repr(args[1])
        print "  Most likely you now want to enter \"up<enter>l<enter>\"\n into the debugger to see what happened.\n"
        raise Exception("Grammar Error")
    if isinstance(args[2], tuple) and args[2][0] == infix_expr:
        pass
    elif isinstance(args[2], tuple) and args[2][0] == prefix_expr:
        pass
    elif isinstance(args[2], tuple) and args[2][0] == fn_eval:
        pass
    elif isinstance(args[2], tuple) and args[2][0] == var_ref:
        pass
    elif isinstance(args[2], PythonTypes.StringType):
        pass
    elif isinstance(args[2], PythonTypes.IntType):
        pass
    elif isinstance(args[2], PythonTypes.FloatType):
        pass
    elif isinstance(args[2], PythonTypes.StringType):
        pass
    elif args[2] == pure:
        pass
    elif args[2] == result:
        pass
    elif isinstance(args[2], tuple) and args[2][0] == complex:
        pass
    else:
        print f.__name__+"():\n    \"\"\"%s\"\"\"\n" %f.__doc__.replace("\\n","\n").replace("\return","Returns").replace("\\c ","")
        print "**GRAMMAR ERROR in argument args[2] = %s"%repr(args[2])
        print "  Most likely you now want to enter \"up<enter>l<enter>\"\n into the debugger to see what happened.\n"
        raise Exception("Grammar Error")
    return tuple(['infix_expr']+list(args))

def Prefix_expr(*args):
    """
    Construct a "prefix_expr" node. Valid arguments are 
    (\c Un_op(), \c AssertExpr())
    \return (\c "Prefix_expr", \c Un_op(), \c AssertExpr())
    """
    f = Prefix_expr
    if len(args) <> 2:
        print "**GRAMMAR ERROR: expected 2 arguments for a", f.__name__
        print "Most likely you want to enter \"up<enter>l<enter>\" now to see what happened."
        raise Exception("Grammar Error")
    if args[0] == is_:
        pass
    elif args[0] == log_not:
        pass
    elif args[0] == bit_not:
        pass
    else:
        print f.__name__+"():\n    \"\"\"%s\"\"\"\n" %f.__doc__.replace("\\n","\n").replace("\return","Returns").replace("\\c ","")
        print "**GRAMMAR ERROR in argument args[0] = %s"%repr(args[0])
        print "  Most likely you now want to enter \"up<enter>l<enter>\"\n into the debugger to see what happened.\n"
        raise Exception("Grammar Error")
    if isinstance(args[1], tuple) and args[1][0] == infix_expr:
        pass
    elif isinstance(args[1], tuple) and args[1][0] == prefix_expr:
        pass
    elif isinstance(args[1], tuple) and args[1][0] == fn_eval:
        pass
    elif isinstance(args[1], tuple) and args[1][0] == var_ref:
        pass
    elif isinstance(args[1], PythonTypes.StringType):
        pass
    elif isinstance(args[1], PythonTypes.IntType):
        pass
    elif isinstance(args[1], PythonTypes.FloatType):
        pass
    elif isinstance(args[1], PythonTypes.StringType):
        pass
    elif args[1] == pure:
        pass
    elif args[1] == result:
        pass
    elif isinstance(args[1], tuple) and args[1][0] == complex:
        pass
    else:
        print f.__name__+"():\n    \"\"\"%s\"\"\"\n" %f.__doc__.replace("\\n","\n").replace("\return","Returns").replace("\\c ","")
        print "**GRAMMAR ERROR in argument args[1] = %s"%repr(args[1])
        print "  Most likely you now want to enter \"up<enter>l<enter>\"\n into the debugger to see what happened.\n"
        raise Exception("Grammar Error")
    return tuple(['prefix_expr']+list(args))

def Fn_eval(*args):
    """
    Construct a "fn_eval" node. Valid arguments are 
    (\c Id(), [\c AssertExpr()])
    \return (\c "Fn_eval", \c Id(), [\c AssertExpr()])
    """
    f = Fn_eval
    if len(args) <> 2:
        print "**GRAMMAR ERROR: expected 2 arguments for a", f.__name__
        print "Most likely you want to enter \"up<enter>l<enter>\" now to see what happened."
        raise Exception("Grammar Error")
    if isinstance(args[0], PythonTypes.StringType):
        pass
    else:
        print f.__name__+"():\n    \"\"\"%s\"\"\"\n" %f.__doc__.replace("\\n","\n").replace("\return","Returns").replace("\\c ","")
        print "**GRAMMAR ERROR in argument args[0] = %s"%repr(args[0])
        print "  Most likely you now want to enter \"up<enter>l<enter>\"\n into the debugger to see what happened.\n"
        raise Exception("Grammar Error")
    if isinstance(args[1], list) or isinstance(args[1], tuple):
        for a in args[1]:
            if isinstance(a, tuple) and a[0] == infix_expr:
                pass
            elif isinstance(a, tuple) and a[0] == prefix_expr:
                pass
            elif isinstance(a, tuple) and a[0] == fn_eval:
                pass
            elif isinstance(a, tuple) and a[0] == var_ref:
                pass
            elif isinstance(a, PythonTypes.StringType):
                pass
            elif isinstance(a, PythonTypes.IntType):
                pass
            elif isinstance(a, PythonTypes.FloatType):
                pass
            elif isinstance(a, PythonTypes.StringType):
                pass
            elif a == pure:
                pass
            elif a == result:
                pass
            elif isinstance(a, tuple) and a[0] == complex:
                pass
            else:
                print f.__name__+"():\n    \"\"\"%s\"\"\"\n" %f.__doc__.replace("\\n","\n").replace("\return","Returns").replace("\\c ","")
                print "**GRAMMAR ERROR in argument a = %s"%repr(a)
                print "  Most likely you now want to enter \"up<enter>l<enter>\"\n into the debugger to see what happened.\n"
                raise Exception("Grammar Error")
    else:
        print f.__name__+"():\n    \"\"\"%s\"\"\"\n" %f.__doc__.replace("\\n","\n").replace("\return","Returns").replace("\\c ","")
        print "**GRAMMAR ERROR in argument args[1] = %s"%repr(args[1])
        print "  Most likely you now want to enter \"up<enter>l<enter>\"\n into the debugger to see what happened.\n"
        raise Exception("Grammar Error")
    return tuple(['fn_eval']+list(args))

def Var_ref(*args):
    """
    Construct a "var_ref" node. Valid arguments are 
    (\c Id())
    \return (\c "Var_ref", \c Id())
    """
    f = Var_ref
    if len(args) <> 1:
        print "**GRAMMAR ERROR: expected 1 arguments for a", f.__name__
        print "Most likely you want to enter \"up<enter>l<enter>\" now to see what happened."
        raise Exception("Grammar Error")
    if isinstance(args[0], PythonTypes.StringType):
        pass
    else:
        print f.__name__+"():\n    \"\"\"%s\"\"\"\n" %f.__doc__.replace("\\n","\n").replace("\return","Returns").replace("\\c ","")
        print "**GRAMMAR ERROR in argument args[0] = %s"%repr(args[0])
        print "  Most likely you now want to enter \"up<enter>l<enter>\"\n into the debugger to see what happened.\n"
        raise Exception("Grammar Error")
    return tuple(['var_ref']+list(args))



## Accessor functions

def requires_scoped_id(arg):
    """
    Accessor function.
    \return the "scoped_id" member of a "requires" node.
    """
    if not isinstance(arg, tuple):
        raise Exception("Grammar Error")
    elif arg[0] <> 'requires':
        raise Exception("Grammar Error")
    else: return arg[1]


def requires_version(arg):
    """
    Accessor function.
    \return the "version" member of a "requires" node.
    """
    if not isinstance(arg, tuple):
        raise Exception("Grammar Error")
    elif arg[0] <> 'requires':
        raise Exception("Grammar Error")
    else: return arg[2]


def import_scoped_id(arg):
    """
    Accessor function.
    \return the "scoped_id" member of a "import" node.
    """
    if not isinstance(arg, tuple):
        raise Exception("Grammar Error")
    elif arg[0] <> 'import':
        raise Exception("Grammar Error")
    else: return arg[1]


def import_version(arg):
    """
    Accessor function.
    \return the "version" member of a "import" node.
    """
    if not isinstance(arg, tuple):
        raise Exception("Grammar Error")
    elif arg[0] <> 'import':
        raise Exception("Grammar Error")
    else: return arg[2]


def user_type_type_attrs(arg):
    """
    Accessor function.
    \return the "type_attrs" member of a "user_type" node.
    """
    if not isinstance(arg, tuple):
        raise Exception("Grammar Error")
    elif arg[0] <> 'user_type':
        raise Exception("Grammar Error")
    else: return arg[1]


def user_type_custom_attrs(arg):
    """
    Accessor function.
    \return the "custom_attrs" member of a "user_type" node.
    """
    if not isinstance(arg, tuple):
        raise Exception("Grammar Error")
    elif arg[0] <> 'user_type':
        raise Exception("Grammar Error")
    else: return arg[1]


def user_type_cipse(arg):
    """
    Accessor function.
    \return the "cipse" member of a "user_type" node.
    """
    if not isinstance(arg, tuple):
        raise Exception("Grammar Error")
    elif arg[0] <> 'user_type':
        raise Exception("Grammar Error")
    else: return arg[2]


def file_requires(arg):
    """
    Accessor function.
    \return the "requires" member of a "file" node.
    """
    if not isinstance(arg, tuple):
        raise Exception("Grammar Error")
    elif arg[0] <> 'file':
        raise Exception("Grammar Error")
    else: return arg[1]


def file_import_s(arg):
    """
    Accessor function.
    \return the "import_s" member of a "file" node.
    """
    if not isinstance(arg, tuple):
        raise Exception("Grammar Error")
    elif arg[0] <> 'file':
        raise Exception("Grammar Error")
    else: return arg[2]


def file_user_types(arg):
    """
    Accessor function.
    \return the "user_types" member of a "file" node.
    """
    if not isinstance(arg, tuple):
        raise Exception("Grammar Error")
    elif arg[0] <> 'file':
        raise Exception("Grammar Error")
    else: return arg[3]


def version_STR(arg):
    """
    Accessor function.
    \return the "STR" member of a "version" node.
    """
    if not isinstance(arg, tuple):
        raise Exception("Grammar Error")
    elif arg[0] <> 'version':
        raise Exception("Grammar Error")
    else: return arg[1]


def version_FLOAT(arg):
    """
    Accessor function.
    \return the "FLOAT" member of a "version" node.
    """
    if not isinstance(arg, tuple):
        raise Exception("Grammar Error")
    elif arg[0] <> 'version':
        raise Exception("Grammar Error")
    else: return arg[1]


def version_INT(arg):
    """
    Accessor function.
    \return the "INT" member of a "version" node.
    """
    if not isinstance(arg, tuple):
        raise Exception("Grammar Error")
    elif arg[0] <> 'version':
        raise Exception("Grammar Error")
    else: return arg[1]


def scoped_id_modules(arg):
    """
    Accessor function.
    \return the "modules" member of a "scoped_id" node.
    """
    if not isinstance(arg, tuple):
        raise Exception("Grammar Error")
    elif arg[0] <> 'scoped_id':
        raise Exception("Grammar Error")
    else: return arg[1]


def scoped_id_id(arg):
    """
    Accessor function.
    \return the "id" member of a "scoped_id" node.
    """
    if not isinstance(arg, tuple):
        raise Exception("Grammar Error")
    elif arg[0] <> 'scoped_id':
        raise Exception("Grammar Error")
    else: return arg[2]


def scoped_id_extension(arg):
    """
    Accessor function.
    \return the "extension" member of a "scoped_id" node.
    """
    if not isinstance(arg, tuple):
        raise Exception("Grammar Error")
    elif arg[0] <> 'scoped_id':
        raise Exception("Grammar Error")
    else: return arg[3]


# skipping \c Id=STR
# skipping \c Doc_comment=STR
def package_id(arg):
    """
    Accessor function.
    \return the "id" member of a "package" node.
    """
    if not isinstance(arg, tuple):
        raise Exception("Grammar Error")
    elif arg[0] <> 'package':
        raise Exception("Grammar Error")
    else: return arg[1]


def package_version(arg):
    """
    Accessor function.
    \return the "version" member of a "package" node.
    """
    if not isinstance(arg, tuple):
        raise Exception("Grammar Error")
    elif arg[0] <> 'package':
        raise Exception("Grammar Error")
    else: return arg[2]


def package_user_types(arg):
    """
    Accessor function.
    \return the "user_types" member of a "package" node.
    """
    if not isinstance(arg, tuple):
        raise Exception("Grammar Error")
    elif arg[0] <> 'package':
        raise Exception("Grammar Error")
    else: return arg[3]


def package_doc_comment(arg):
    """
    Accessor function.
    \return the "doc_comment" member of a "package" node.
    """
    if not isinstance(arg, tuple):
        raise Exception("Grammar Error")
    elif arg[0] <> 'package':
        raise Exception("Grammar Error")
    else: return arg[4]


# skipping \c Type_attr= (final|abstract)
# skipping \c Custom_attr= (\c Custom_attribute|\c Custom_attribute_assoc)
# skipping \c Cipse= (\c Class|\c Interface|\c Package|\c Struct|\c Enum)
def struct_id(arg):
    """
    Accessor function.
    \return the "id" member of a "struct" node.
    """
    if not isinstance(arg, tuple):
        raise Exception("Grammar Error")
    elif arg[0] <> 'struct':
        raise Exception("Grammar Error")
    else: return arg[1]


def struct_struct_items(arg):
    """
    Accessor function.
    \return the "struct_items" member of a "struct" node.
    """
    if not isinstance(arg, tuple):
        raise Exception("Grammar Error")
    elif arg[0] <> 'struct':
        raise Exception("Grammar Error")
    else: return arg[2]


def struct_doc_comment(arg):
    """
    Accessor function.
    \return the "doc_comment" member of a "struct" node.
    """
    if not isinstance(arg, tuple):
        raise Exception("Grammar Error")
    elif arg[0] <> 'struct':
        raise Exception("Grammar Error")
    else: return arg[3]


def enum_id(arg):
    """
    Accessor function.
    \return the "id" member of a "enum" node.
    """
    if not isinstance(arg, tuple):
        raise Exception("Grammar Error")
    elif arg[0] <> 'enum':
        raise Exception("Grammar Error")
    else: return arg[1]


def enum_enumerators(arg):
    """
    Accessor function.
    \return the "enumerators" member of a "enum" node.
    """
    if not isinstance(arg, tuple):
        raise Exception("Grammar Error")
    elif arg[0] <> 'enum':
        raise Exception("Grammar Error")
    else: return arg[2]


def enum_doc_comment(arg):
    """
    Accessor function.
    \return the "doc_comment" member of a "enum" node.
    """
    if not isinstance(arg, tuple):
        raise Exception("Grammar Error")
    elif arg[0] <> 'enum':
        raise Exception("Grammar Error")
    else: return arg[3]


def interface_id(arg):
    """
    Accessor function.
    \return the "id" member of a "interface" node.
    """
    if not isinstance(arg, tuple):
        raise Exception("Grammar Error")
    elif arg[0] <> 'interface':
        raise Exception("Grammar Error")
    else: return arg[1]


def interface_extends(arg):
    """
    Accessor function.
    \return the "extends" member of a "interface" node.
    """
    if not isinstance(arg, tuple):
        raise Exception("Grammar Error")
    elif arg[0] <> 'interface':
        raise Exception("Grammar Error")
    else: return arg[2]


def interface_invariants(arg):
    """
    Accessor function.
    \return the "invariants" member of a "interface" node.
    """
    if not isinstance(arg, tuple):
        raise Exception("Grammar Error")
    elif arg[0] <> 'interface':
        raise Exception("Grammar Error")
    else: return arg[3]


def interface_methods(arg):
    """
    Accessor function.
    \return the "methods" member of a "interface" node.
    """
    if not isinstance(arg, tuple):
        raise Exception("Grammar Error")
    elif arg[0] <> 'interface':
        raise Exception("Grammar Error")
    else: return arg[4]


def interface_doc_comment(arg):
    """
    Accessor function.
    \return the "doc_comment" member of a "interface" node.
    """
    if not isinstance(arg, tuple):
        raise Exception("Grammar Error")
    elif arg[0] <> 'interface':
        raise Exception("Grammar Error")
    else: return arg[5]


def class_id(arg):
    """
    Accessor function.
    \return the "id" member of a "class" node.
    """
    if not isinstance(arg, tuple):
        raise Exception("Grammar Error")
    elif arg[0] <> 'class':
        raise Exception("Grammar Error")
    else: return arg[1]


def class_extends(arg):
    """
    Accessor function.
    \return the "extends" member of a "class" node.
    """
    if not isinstance(arg, tuple):
        raise Exception("Grammar Error")
    elif arg[0] <> 'class':
        raise Exception("Grammar Error")
    else: return arg[2]


def class_implements(arg):
    """
    Accessor function.
    \return the "implements" member of a "class" node.
    """
    if not isinstance(arg, tuple):
        raise Exception("Grammar Error")
    elif arg[0] <> 'class':
        raise Exception("Grammar Error")
    else: return arg[3]


def class_invariants(arg):
    """
    Accessor function.
    \return the "invariants" member of a "class" node.
    """
    if not isinstance(arg, tuple):
        raise Exception("Grammar Error")
    elif arg[0] <> 'class':
        raise Exception("Grammar Error")
    else: return arg[4]


def class_methods(arg):
    """
    Accessor function.
    \return the "methods" member of a "class" node.
    """
    if not isinstance(arg, tuple):
        raise Exception("Grammar Error")
    elif arg[0] <> 'class':
        raise Exception("Grammar Error")
    else: return arg[5]


def class_doc_comment(arg):
    """
    Accessor function.
    \return the "doc_comment" member of a "class" node.
    """
    if not isinstance(arg, tuple):
        raise Exception("Grammar Error")
    elif arg[0] <> 'class':
        raise Exception("Grammar Error")
    else: return arg[6]


# skipping \c Enumerator= (\c Enumerator|\c Enumerator_value)
def struct_item_type_void(arg):
    """
    Accessor function.
    \return the "type_void" member of a "struct_item" node.
    """
    if not isinstance(arg, tuple):
        raise Exception("Grammar Error")
    elif arg[0] <> 'struct_item':
        raise Exception("Grammar Error")
    else: return arg[1]


def struct_item_rarray(arg):
    """
    Accessor function.
    \return the "rarray" member of a "struct_item" node.
    """
    if not isinstance(arg, tuple):
        raise Exception("Grammar Error")
    elif arg[0] <> 'struct_item':
        raise Exception("Grammar Error")
    else: return arg[1]


def struct_item_id(arg):
    """
    Accessor function.
    \return the "id" member of a "struct_item" node.
    """
    if not isinstance(arg, tuple):
        raise Exception("Grammar Error")
    elif arg[0] <> 'struct_item':
        raise Exception("Grammar Error")
    else: return arg[2]


# skipping \c Type_void= (void|\c Type)
def rarray_primitive_type(arg):
    """
    Accessor function.
    \return the "primitive_type" member of a "rarray" node.
    """
    if not isinstance(arg, tuple):
        raise Exception("Grammar Error")
    elif arg[0] <> 'rarray':
        raise Exception("Grammar Error")
    else: return arg[1]


def rarray_dimension(arg):
    """
    Accessor function.
    \return the "dimension" member of a "rarray" node.
    """
    if not isinstance(arg, tuple):
        raise Exception("Grammar Error")
    elif arg[0] <> 'rarray':
        raise Exception("Grammar Error")
    else: return arg[2]


def rarray_extents(arg):
    """
    Accessor function.
    \return the "extents" member of a "rarray" node.
    """
    if not isinstance(arg, tuple):
        raise Exception("Grammar Error")
    elif arg[0] <> 'rarray':
        raise Exception("Grammar Error")
    else: return arg[3]


def extends_scoped_id(arg):
    """
    Accessor function.
    \return the "scoped_id" member of a "extends" node.
    """
    if not isinstance(arg, tuple):
        raise Exception("Grammar Error")
    elif arg[0] <> 'extends':
        raise Exception("Grammar Error")
    else: return arg[1]


# skipping \c Implements= (\c Implements|\c Implements_all)
def invariant_assertion(arg):
    """
    Accessor function.
    \return the "assertion" member of a "invariant" node.
    """
    if not isinstance(arg, tuple):
        raise Exception("Grammar Error")
    elif arg[0] <> 'invariant':
        raise Exception("Grammar Error")
    else: return arg[1]


def method_type_void(arg):
    """
    Accessor function.
    \return the "type_void" member of a "method" node.
    """
    if not isinstance(arg, tuple):
        raise Exception("Grammar Error")
    elif arg[0] <> 'method':
        raise Exception("Grammar Error")
    else: return arg[1]


def method_method_name(arg):
    """
    Accessor function.
    \return the "method_name" member of a "method" node.
    """
    if not isinstance(arg, tuple):
        raise Exception("Grammar Error")
    elif arg[0] <> 'method':
        raise Exception("Grammar Error")
    else: return arg[2]


def method_method_attrs(arg):
    """
    Accessor function.
    \return the "method_attrs" member of a "method" node.
    """
    if not isinstance(arg, tuple):
        raise Exception("Grammar Error")
    elif arg[0] <> 'method':
        raise Exception("Grammar Error")
    else: return arg[3]


def method_args(arg):
    """
    Accessor function.
    \return the "args" member of a "method" node.
    """
    if not isinstance(arg, tuple):
        raise Exception("Grammar Error")
    elif arg[0] <> 'method':
        raise Exception("Grammar Error")
    else: return arg[4]


def method_except_s(arg):
    """
    Accessor function.
    \return the "except_s" member of a "method" node.
    """
    if not isinstance(arg, tuple):
        raise Exception("Grammar Error")
    elif arg[0] <> 'method':
        raise Exception("Grammar Error")
    else: return arg[5]


def method_from_s(arg):
    """
    Accessor function.
    \return the "from_s" member of a "method" node.
    """
    if not isinstance(arg, tuple):
        raise Exception("Grammar Error")
    elif arg[0] <> 'method':
        raise Exception("Grammar Error")
    else: return arg[6]


def method_requires(arg):
    """
    Accessor function.
    \return the "requires" member of a "method" node.
    """
    if not isinstance(arg, tuple):
        raise Exception("Grammar Error")
    elif arg[0] <> 'method':
        raise Exception("Grammar Error")
    else: return arg[7]


def method_ensures(arg):
    """
    Accessor function.
    \return the "ensures" member of a "method" node.
    """
    if not isinstance(arg, tuple):
        raise Exception("Grammar Error")
    elif arg[0] <> 'method':
        raise Exception("Grammar Error")
    else: return arg[8]


def method_doc_comment(arg):
    """
    Accessor function.
    \return the "doc_comment" member of a "method" node.
    """
    if not isinstance(arg, tuple):
        raise Exception("Grammar Error")
    elif arg[0] <> 'method':
        raise Exception("Grammar Error")
    else: return arg[9]


# skipping \c Method_attr= (oneway|local|static|abstract|final|nonblocking|copy)
def arg_arg_attrs(arg):
    """
    Accessor function.
    \return the "arg_attrs" member of a "arg" node.
    """
    if not isinstance(arg, tuple):
        raise Exception("Grammar Error")
    elif arg[0] <> 'arg':
        raise Exception("Grammar Error")
    else: return arg[1]


def arg_mode(arg):
    """
    Accessor function.
    \return the "mode" member of a "arg" node.
    """
    if not isinstance(arg, tuple):
        raise Exception("Grammar Error")
    elif arg[0] <> 'arg':
        raise Exception("Grammar Error")
    else: return arg[2]


def arg_type_void(arg):
    """
    Accessor function.
    \return the "type_void" member of a "arg" node.
    """
    if not isinstance(arg, tuple):
        raise Exception("Grammar Error")
    elif arg[0] <> 'arg':
        raise Exception("Grammar Error")
    else: return arg[3]


def arg_rarray(arg):
    """
    Accessor function.
    \return the "rarray" member of a "arg" node.
    """
    if not isinstance(arg, tuple):
        raise Exception("Grammar Error")
    elif arg[0] <> 'arg':
        raise Exception("Grammar Error")
    else: return arg[3]


def arg_id(arg):
    """
    Accessor function.
    \return the "id" member of a "arg" node.
    """
    if not isinstance(arg, tuple):
        raise Exception("Grammar Error")
    elif arg[0] <> 'arg':
        raise Exception("Grammar Error")
    else: return arg[4]


def except_scoped_id(arg):
    """
    Accessor function.
    \return the "scoped_id" member of a "except" node.
    """
    if not isinstance(arg, tuple):
        raise Exception("Grammar Error")
    elif arg[0] <> 'except':
        raise Exception("Grammar Error")
    else: return arg[1]


def from_scoped_id(arg):
    """
    Accessor function.
    \return the "scoped_id" member of a "from" node.
    """
    if not isinstance(arg, tuple):
        raise Exception("Grammar Error")
    elif arg[0] <> 'from':
        raise Exception("Grammar Error")
    else: return arg[1]


def require_assertion(arg):
    """
    Accessor function.
    \return the "assertion" member of a "require" node.
    """
    if not isinstance(arg, tuple):
        raise Exception("Grammar Error")
    elif arg[0] <> 'require':
        raise Exception("Grammar Error")
    else: return arg[1]


def ensure_assertion(arg):
    """
    Accessor function.
    \return the "assertion" member of a "ensure" node.
    """
    if not isinstance(arg, tuple):
        raise Exception("Grammar Error")
    elif arg[0] <> 'ensure':
        raise Exception("Grammar Error")
    else: return arg[1]


def method_name_id(arg):
    """
    Accessor function.
    \return the "id" member of a "method_name" node.
    """
    if not isinstance(arg, tuple):
        raise Exception("Grammar Error")
    elif arg[0] <> 'method_name':
        raise Exception("Grammar Error")
    else: return arg[1]


def method_name_extension(arg):
    """
    Accessor function.
    \return the "extension" member of a "method_name" node.
    """
    if not isinstance(arg, tuple):
        raise Exception("Grammar Error")
    elif arg[0] <> 'method_name':
        raise Exception("Grammar Error")
    else: return arg[2]


# skipping \c Extension=STR
# skipping \c Type= (\c Primitive_type|\c Array|\c Scoped_id)
def assertion_id(arg):
    """
    Accessor function.
    \return the "id" member of a "assertion" node.
    """
    if not isinstance(arg, tuple):
        raise Exception("Grammar Error")
    elif arg[0] <> 'assertion':
        raise Exception("Grammar Error")
    else: return arg[1]


def assertion_assertExpr(arg):
    """
    Accessor function.
    \return the "assertExpr" member of a "assertion" node.
    """
    if not isinstance(arg, tuple):
        raise Exception("Grammar Error")
    elif arg[0] <> 'assertion':
        raise Exception("Grammar Error")
    else: return arg[2]


# skipping \c AssertExpr= (\c Infix_expr|\c Prefix_expr|\c Fn_eval|\c Var_ref|\c Id|\c Literal)
# skipping \c Arg_attr= (copy|[STR])
# skipping \c Mode= (in|out|inout)
def array_scalar_type(arg):
    """
    Accessor function.
    \return the "scalar_type" member of a "array" node.
    """
    if not isinstance(arg, tuple):
        raise Exception("Grammar Error")
    elif arg[0] <> 'array':
        raise Exception("Grammar Error")
    else: return arg[1]


def array_dimension(arg):
    """
    Accessor function.
    \return the "dimension" member of a "array" node.
    """
    if not isinstance(arg, tuple):
        raise Exception("Grammar Error")
    elif arg[0] <> 'array':
        raise Exception("Grammar Error")
    else: return arg[2]


def array_orientation(arg):
    """
    Accessor function.
    \return the "orientation" member of a "array" node.
    """
    if not isinstance(arg, tuple):
        raise Exception("Grammar Error")
    elif arg[0] <> 'array':
        raise Exception("Grammar Error")
    else: return arg[3]


def primitive_type_bool(arg):
    """
    Accessor function.
    \return the "bool" member of a "primitive_type" node.
    """
    if not isinstance(arg, tuple):
        raise Exception("Grammar Error")
    elif arg[0] <> 'primitive_type':
        raise Exception("Grammar Error")
    else: return arg[1]


def primitive_type_char(arg):
    """
    Accessor function.
    \return the "char" member of a "primitive_type" node.
    """
    if not isinstance(arg, tuple):
        raise Exception("Grammar Error")
    elif arg[0] <> 'primitive_type':
        raise Exception("Grammar Error")
    else: return arg[1]


def primitive_type_int(arg):
    """
    Accessor function.
    \return the "int" member of a "primitive_type" node.
    """
    if not isinstance(arg, tuple):
        raise Exception("Grammar Error")
    elif arg[0] <> 'primitive_type':
        raise Exception("Grammar Error")
    else: return arg[1]


def primitive_type_long(arg):
    """
    Accessor function.
    \return the "long" member of a "primitive_type" node.
    """
    if not isinstance(arg, tuple):
        raise Exception("Grammar Error")
    elif arg[0] <> 'primitive_type':
        raise Exception("Grammar Error")
    else: return arg[1]


def primitive_type_float(arg):
    """
    Accessor function.
    \return the "float" member of a "primitive_type" node.
    """
    if not isinstance(arg, tuple):
        raise Exception("Grammar Error")
    elif arg[0] <> 'primitive_type':
        raise Exception("Grammar Error")
    else: return arg[1]


def primitive_type_double(arg):
    """
    Accessor function.
    \return the "double" member of a "primitive_type" node.
    """
    if not isinstance(arg, tuple):
        raise Exception("Grammar Error")
    elif arg[0] <> 'primitive_type':
        raise Exception("Grammar Error")
    else: return arg[1]


def primitive_type_fcomplex(arg):
    """
    Accessor function.
    \return the "fcomplex" member of a "primitive_type" node.
    """
    if not isinstance(arg, tuple):
        raise Exception("Grammar Error")
    elif arg[0] <> 'primitive_type':
        raise Exception("Grammar Error")
    else: return arg[1]


def primitive_type_dcomplex(arg):
    """
    Accessor function.
    \return the "dcomplex" member of a "primitive_type" node.
    """
    if not isinstance(arg, tuple):
        raise Exception("Grammar Error")
    elif arg[0] <> 'primitive_type':
        raise Exception("Grammar Error")
    else: return arg[1]


def primitive_type_string(arg):
    """
    Accessor function.
    \return the "string" member of a "primitive_type" node.
    """
    if not isinstance(arg, tuple):
        raise Exception("Grammar Error")
    elif arg[0] <> 'primitive_type':
        raise Exception("Grammar Error")
    else: return arg[1]


def primitive_type_opaque(arg):
    """
    Accessor function.
    \return the "opaque" member of a "primitive_type" node.
    """
    if not isinstance(arg, tuple):
        raise Exception("Grammar Error")
    elif arg[0] <> 'primitive_type':
        raise Exception("Grammar Error")
    else: return arg[1]


# skipping \c Scalar_type= (\c Primitive_type|\c Scoped_id)
# skipping \c Dimension=INT
# skipping \c Orientation= (row_major|column_major)
# skipping \c Extents= \c SimpleIntExpression
# skipping \c SimpleIntExpression= (INT|\c Id)
# skipping \c Bin_op= (log_or|log_and|eq|ne|bit_or|bit_and|bit_xor|lt|gt|le|ge|lshift|rshift|plus|minus|times|divide|modulo|rem|pow|implies|iff)
# skipping \c Un_op= (is|log_not|bit_not)
# skipping \c Literal= (INT|FLOAT|STR|pure|result|\c Complex)
# skipping \c Module=STR
def complex_FLOAT(arg):
    """
    Accessor function.
    \return the "FLOAT" member of a "complex" node.
    """
    if not isinstance(arg, tuple):
        raise Exception("Grammar Error")
    elif arg[0] <> 'complex':
        raise Exception("Grammar Error")
    else: return arg[1]


def complex_FLOAT(arg):
    """
    Accessor function.
    \return the "FLOAT" member of a "complex" node.
    """
    if not isinstance(arg, tuple):
        raise Exception("Grammar Error")
    elif arg[0] <> 'complex':
        raise Exception("Grammar Error")
    else: return arg[2]


def enumerator_id(arg):
    """
    Accessor function.
    \return the "id" member of a "enumerator" node.
    """
    if not isinstance(arg, tuple):
        raise Exception("Grammar Error")
    elif arg[0] <> 'enumerator':
        raise Exception("Grammar Error")
    else: return arg[1]


def enumerator_value_id(arg):
    """
    Accessor function.
    \return the "id" member of a "enumerator_value" node.
    """
    if not isinstance(arg, tuple):
        raise Exception("Grammar Error")
    elif arg[0] <> 'enumerator_value':
        raise Exception("Grammar Error")
    else: return arg[1]


def enumerator_value_INT(arg):
    """
    Accessor function.
    \return the "INT" member of a "enumerator_value" node.
    """
    if not isinstance(arg, tuple):
        raise Exception("Grammar Error")
    elif arg[0] <> 'enumerator_value':
        raise Exception("Grammar Error")
    else: return arg[2]


def implements_scoped_id(arg):
    """
    Accessor function.
    \return the "scoped_id" member of a "implements" node.
    """
    if not isinstance(arg, tuple):
        raise Exception("Grammar Error")
    elif arg[0] <> 'implements':
        raise Exception("Grammar Error")
    else: return arg[1]


def implements_all_scoped_id(arg):
    """
    Accessor function.
    \return the "scoped_id" member of a "implements_all" node.
    """
    if not isinstance(arg, tuple):
        raise Exception("Grammar Error")
    elif arg[0] <> 'implements_all':
        raise Exception("Grammar Error")
    else: return arg[1]


def custom_attribute_STR(arg):
    """
    Accessor function.
    \return the "STR" member of a "custom_attribute" node.
    """
    if not isinstance(arg, tuple):
        raise Exception("Grammar Error")
    elif arg[0] <> 'custom_attribute':
        raise Exception("Grammar Error")
    else: return arg[1]


def custom_attribute_assoc_STR(arg):
    """
    Accessor function.
    \return the "STR" member of a "custom_attribute_assoc" node.
    """
    if not isinstance(arg, tuple):
        raise Exception("Grammar Error")
    elif arg[0] <> 'custom_attribute_assoc':
        raise Exception("Grammar Error")
    else: return arg[1]


def custom_attribute_assoc_STR(arg):
    """
    Accessor function.
    \return the "STR" member of a "custom_attribute_assoc" node.
    """
    if not isinstance(arg, tuple):
        raise Exception("Grammar Error")
    elif arg[0] <> 'custom_attribute_assoc':
        raise Exception("Grammar Error")
    else: return arg[2]


def infix_expr_bin_op(arg):
    """
    Accessor function.
    \return the "bin_op" member of a "infix_expr" node.
    """
    if not isinstance(arg, tuple):
        raise Exception("Grammar Error")
    elif arg[0] <> 'infix_expr':
        raise Exception("Grammar Error")
    else: return arg[1]


def infix_expr_assertExpr(arg):
    """
    Accessor function.
    \return the "assertExpr" member of a "infix_expr" node.
    """
    if not isinstance(arg, tuple):
        raise Exception("Grammar Error")
    elif arg[0] <> 'infix_expr':
        raise Exception("Grammar Error")
    else: return arg[2]


def infix_expr_assertExpr(arg):
    """
    Accessor function.
    \return the "assertExpr" member of a "infix_expr" node.
    """
    if not isinstance(arg, tuple):
        raise Exception("Grammar Error")
    elif arg[0] <> 'infix_expr':
        raise Exception("Grammar Error")
    else: return arg[3]


def prefix_expr_un_op(arg):
    """
    Accessor function.
    \return the "un_op" member of a "prefix_expr" node.
    """
    if not isinstance(arg, tuple):
        raise Exception("Grammar Error")
    elif arg[0] <> 'prefix_expr':
        raise Exception("Grammar Error")
    else: return arg[1]


def prefix_expr_assertExpr(arg):
    """
    Accessor function.
    \return the "assertExpr" member of a "prefix_expr" node.
    """
    if not isinstance(arg, tuple):
        raise Exception("Grammar Error")
    elif arg[0] <> 'prefix_expr':
        raise Exception("Grammar Error")
    else: return arg[2]


def fn_eval_id(arg):
    """
    Accessor function.
    \return the "id" member of a "fn_eval" node.
    """
    if not isinstance(arg, tuple):
        raise Exception("Grammar Error")
    elif arg[0] <> 'fn_eval':
        raise Exception("Grammar Error")
    else: return arg[1]


def fn_eval_assertExprs(arg):
    """
    Accessor function.
    \return the "assertExprs" member of a "fn_eval" node.
    """
    if not isinstance(arg, tuple):
        raise Exception("Grammar Error")
    elif arg[0] <> 'fn_eval':
        raise Exception("Grammar Error")
    else: return arg[2]


def var_ref_id(arg):
    """
    Accessor function.
    \return the "id" member of a "var_ref" node.
    """
    if not isinstance(arg, tuple):
        raise Exception("Grammar Error")
    elif arg[0] <> 'var_ref':
        raise Exception("Grammar Error")
    else: return arg[1]




## instance checks

def is_requires(arg):
    """
    instanceof-like function.
    \return \c True if the argument is a "requires" node.
    """
    if not isinstance(arg, tuple):
        return False
    return arg[0] == 'requires'

def is_import(arg):
    """
    instanceof-like function.
    \return \c True if the argument is a "import" node.
    """
    if not isinstance(arg, tuple):
        return False
    return arg[0] == 'import'

def is_user_type(arg):
    """
    instanceof-like function.
    \return \c True if the argument is a "user_type" node.
    """
    if not isinstance(arg, tuple):
        return False
    return arg[0] == 'user_type'

def is_file(arg):
    """
    instanceof-like function.
    \return \c True if the argument is a "file" node.
    """
    if not isinstance(arg, tuple):
        return False
    return arg[0] == 'file'

def is_version(arg):
    """
    instanceof-like function.
    \return \c True if the argument is a "version" node.
    """
    if not isinstance(arg, tuple):
        return False
    return arg[0] == 'version'

def is_scoped_id(arg):
    """
    instanceof-like function.
    \return \c True if the argument is a "scoped_id" node.
    """
    if not isinstance(arg, tuple):
        return False
    return arg[0] == 'scoped_id'

# skipping \c Id=STR
# skipping \c Doc_comment=STR
def is_package(arg):
    """
    instanceof-like function.
    \return \c True if the argument is a "package" node.
    """
    if not isinstance(arg, tuple):
        return False
    return arg[0] == 'package'

# skipping \c Type_attr= (final|abstract)
# skipping \c Custom_attr= (\c Custom_attribute|\c Custom_attribute_assoc)
# skipping \c Cipse= (\c Class|\c Interface|\c Package|\c Struct|\c Enum)
def is_struct(arg):
    """
    instanceof-like function.
    \return \c True if the argument is a "struct" node.
    """
    if not isinstance(arg, tuple):
        return False
    return arg[0] == 'struct'

def is_enum(arg):
    """
    instanceof-like function.
    \return \c True if the argument is a "enum" node.
    """
    if not isinstance(arg, tuple):
        return False
    return arg[0] == 'enum'

def is_interface(arg):
    """
    instanceof-like function.
    \return \c True if the argument is a "interface" node.
    """
    if not isinstance(arg, tuple):
        return False
    return arg[0] == 'interface'

def is_class(arg):
    """
    instanceof-like function.
    \return \c True if the argument is a "class" node.
    """
    if not isinstance(arg, tuple):
        return False
    return arg[0] == 'class'

# skipping \c Enumerator= (\c Enumerator|\c Enumerator_value)
def is_struct_item(arg):
    """
    instanceof-like function.
    \return \c True if the argument is a "struct_item" node.
    """
    if not isinstance(arg, tuple):
        return False
    return arg[0] == 'struct_item'

# skipping \c Type_void= (void|\c Type)
def is_rarray(arg):
    """
    instanceof-like function.
    \return \c True if the argument is a "rarray" node.
    """
    if not isinstance(arg, tuple):
        return False
    return arg[0] == 'rarray'

def is_extends(arg):
    """
    instanceof-like function.
    \return \c True if the argument is a "extends" node.
    """
    if not isinstance(arg, tuple):
        return False
    return arg[0] == 'extends'

# skipping \c Implements= (\c Implements|\c Implements_all)
def is_invariant(arg):
    """
    instanceof-like function.
    \return \c True if the argument is a "invariant" node.
    """
    if not isinstance(arg, tuple):
        return False
    return arg[0] == 'invariant'

def is_method(arg):
    """
    instanceof-like function.
    \return \c True if the argument is a "method" node.
    """
    if not isinstance(arg, tuple):
        return False
    return arg[0] == 'method'

# skipping \c Method_attr= (oneway|local|static|abstract|final|nonblocking|copy)
def is_arg(arg):
    """
    instanceof-like function.
    \return \c True if the argument is a "arg" node.
    """
    if not isinstance(arg, tuple):
        return False
    return arg[0] == 'arg'

def is_except(arg):
    """
    instanceof-like function.
    \return \c True if the argument is a "except" node.
    """
    if not isinstance(arg, tuple):
        return False
    return arg[0] == 'except'

def is_from(arg):
    """
    instanceof-like function.
    \return \c True if the argument is a "from" node.
    """
    if not isinstance(arg, tuple):
        return False
    return arg[0] == 'from'

def is_require(arg):
    """
    instanceof-like function.
    \return \c True if the argument is a "require" node.
    """
    if not isinstance(arg, tuple):
        return False
    return arg[0] == 'require'

def is_ensure(arg):
    """
    instanceof-like function.
    \return \c True if the argument is a "ensure" node.
    """
    if not isinstance(arg, tuple):
        return False
    return arg[0] == 'ensure'

def is_method_name(arg):
    """
    instanceof-like function.
    \return \c True if the argument is a "method_name" node.
    """
    if not isinstance(arg, tuple):
        return False
    return arg[0] == 'method_name'

# skipping \c Extension=STR
# skipping \c Type= (\c Primitive_type|\c Array|\c Scoped_id)
def is_assertion(arg):
    """
    instanceof-like function.
    \return \c True if the argument is a "assertion" node.
    """
    if not isinstance(arg, tuple):
        return False
    return arg[0] == 'assertion'

# skipping \c AssertExpr= (\c Infix_expr|\c Prefix_expr|\c Fn_eval|\c Var_ref|\c Id|\c Literal)
# skipping \c Arg_attr= (copy|[STR])
# skipping \c Mode= (in|out|inout)
def is_array(arg):
    """
    instanceof-like function.
    \return \c True if the argument is a "array" node.
    """
    if not isinstance(arg, tuple):
        return False
    return arg[0] == 'array'

def is_primitive_type(arg):
    """
    instanceof-like function.
    \return \c True if the argument is a "primitive_type" node.
    """
    if not isinstance(arg, tuple):
        return False
    return arg[0] == 'primitive_type'

# skipping \c Scalar_type= (\c Primitive_type|\c Scoped_id)
# skipping \c Dimension=INT
# skipping \c Orientation= (row_major|column_major)
# skipping \c Extents= \c SimpleIntExpression
# skipping \c SimpleIntExpression= (INT|\c Id)
# skipping \c Bin_op= (log_or|log_and|eq|ne|bit_or|bit_and|bit_xor|lt|gt|le|ge|lshift|rshift|plus|minus|times|divide|modulo|rem|pow|implies|iff)
# skipping \c Un_op= (is|log_not|bit_not)
# skipping \c Literal= (INT|FLOAT|STR|pure|result|\c Complex)
# skipping \c Module=STR
def is_complex(arg):
    """
    instanceof-like function.
    \return \c True if the argument is a "complex" node.
    """
    if not isinstance(arg, tuple):
        return False
    return arg[0] == 'complex'

def is_enumerator(arg):
    """
    instanceof-like function.
    \return \c True if the argument is a "enumerator" node.
    """
    if not isinstance(arg, tuple):
        return False
    return arg[0] == 'enumerator'

def is_enumerator_value(arg):
    """
    instanceof-like function.
    \return \c True if the argument is a "enumerator_value" node.
    """
    if not isinstance(arg, tuple):
        return False
    return arg[0] == 'enumerator_value'

def is_implements(arg):
    """
    instanceof-like function.
    \return \c True if the argument is a "implements" node.
    """
    if not isinstance(arg, tuple):
        return False
    return arg[0] == 'implements'

def is_implements_all(arg):
    """
    instanceof-like function.
    \return \c True if the argument is a "implements_all" node.
    """
    if not isinstance(arg, tuple):
        return False
    return arg[0] == 'implements_all'

def is_custom_attribute(arg):
    """
    instanceof-like function.
    \return \c True if the argument is a "custom_attribute" node.
    """
    if not isinstance(arg, tuple):
        return False
    return arg[0] == 'custom_attribute'

def is_custom_attribute_assoc(arg):
    """
    instanceof-like function.
    \return \c True if the argument is a "custom_attribute_assoc" node.
    """
    if not isinstance(arg, tuple):
        return False
    return arg[0] == 'custom_attribute_assoc'

def is_infix_expr(arg):
    """
    instanceof-like function.
    \return \c True if the argument is a "infix_expr" node.
    """
    if not isinstance(arg, tuple):
        return False
    return arg[0] == 'infix_expr'

def is_prefix_expr(arg):
    """
    instanceof-like function.
    \return \c True if the argument is a "prefix_expr" node.
    """
    if not isinstance(arg, tuple):
        return False
    return arg[0] == 'prefix_expr'

def is_fn_eval(arg):
    """
    instanceof-like function.
    \return \c True if the argument is a "fn_eval" node.
    """
    if not isinstance(arg, tuple):
        return False
    return arg[0] == 'fn_eval'

def is_var_ref(arg):
    """
    instanceof-like function.
    \return \c True if the argument is a "var_ref" node.
    """
    if not isinstance(arg, tuple):
        return False
    return arg[0] == 'var_ref'

 ## token overrides to simplify the parser
bit_not = '~'
eq = '=='
ne = '!='
bit_or = '|'
bit_and = '&'
bit_xor = '^'
lt = '<'
gt = '>'
le = '<='
ge = '>='
lshift = '<<'
rshift = '>>'
plus = '+'
minus = '_'
times = '*'
divide = '/'
modulo = '%'
rem = 'rem'
pow = '**'
 ## sidl primitive types
pt_bool = Primitive_type(bool)
pt_bool     = Primitive_type(bool)
pt_char     = Primitive_type(char)
pt_int      = Primitive_type(int)
pt_long     = Primitive_type(long)
pt_float    = Primitive_type(float)
pt_double   = Primitive_type(double)
pt_fcomplex = Primitive_type(fcomplex)
pt_dcomplex = Primitive_type(dcomplex)
pt_string   = Primitive_type(string)
pt_opaque   = Primitive_type(opaque)
def type_id(t):
    """
    \return the Id of a class, interface, package, etc.
    """
    return t[1]
def method_id(t):
    """
    \return full name of a method
    """
    return t[2][1]+t[2][2]
def ext_invariants(ext):
    """
    \return the invariants specified by a class or interface
    """
    if ext[0] == class_:
        return class_invariants(ext)
    elif ext[0] == interface:
        return interface_invariants(ext)
    return []
def ext_methods(ext):
    """
    \return the methods specified by a class or interface
    """
    if ext[0] == class_:
        return class_methods(ext)
    elif ext[0] == interface:
        return interface_methods(ext)
    return []
def hashable((scoped_id, modules, name, ext)):
    """
    Make a hashable copy of a scoped_id by turning the list of modules into a tuple.
    """
    return scoped_id, tuple(modules), name, ext
def hashable_type_id(t):
    """
    \return the (hashable) scoped Id of a class, interface, package, etc.
    """
    tid = t[1]
    if isinstance(tid, tuple) and tid[0] == scoped_id:
        return hashable(t[1])
    return tid
def get_scoped_id(symbol_table, ext):
    """
    return the scoped_id of an extendible
    This wouldn't need to be so complicated if symbol_table[]
    would return a class with an id instead of a scoped_id.
    """
    if is_scoped_id(ext):
        return ext
    tid = type_id(ext)
    if is_scoped_id(tid):
        return tid
    return Scoped_id(symbol_table.prefix, tid, '')
def is_static(method):
    """
    \return \c true iff the sidl.method \c method has the \c static
    attribute.
    """
    from patmat import member_chk
    return member_chk(static, method_method_attrs(method))
 
def is_nonblocking(method):
    """
    \return \c true iff the sidl.method \c method has the \c nonblocking
    attribute.
    """
    from patmat import member_chk
    return member_chk(nonblocking, method_method_attrs(method))
 
def is_not_static(method):
    """
    \return \c false iff the sidl.method \c method has the \c static
    attribute.
    """
    return not is_static(method)
def long_method_name(m):
    """
    \return \the long name of the sidl.method \c method
    """
    n = method_method_name(m)
    return n[1]+n[2]
