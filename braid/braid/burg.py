#!/usr/bin/env python
# -*- python -*-
## @package burg
#
# A very simple Bottom-Up Rewriting code Generator. It was inspired by
# the descriptions in
#
# - Engineering a Simple, Efficient Code Generator Generator
#   C. FRASER, D. HANSON and T. PROEBSTING
#   ACM Letters on Programming Languages and Systems
#
# - Optimal Code Selection in DAGs
#   A. ERTL, POPL'99
#
# but is at this point not nearly as sophisticated.
#
# Please report bugs to <adrian@llnl.gov>.
#
# \authors <pre>
#
# Copyright (c) 2011, 2012 Lawrence Livermore National Security, LLC.
# Produced at the Lawrence Livermore National Laboratory
# Written by Adrian Prantl <adrian@llnl.gov>.
# 
# LLNL-CODE-473891.
# All rights reserved.
#
# This file is part of BRAID. For details, see
# http://compose-hpc.sourceforge.net/.
# Please read the COPYRIGHT file for Our Notice and
# for the BSD License.
#
# </pre>
#
import argparse, re
from parse_tree import parse_tree

def error(msg):
    global filename
    print '%s:%d error: %s'%(filename, line_number, msg)
    exit(1)

if __name__ == '__main__':
    # Command line argument handling
    cmdline = argparse.ArgumentParser(
        description='A code generator generator',
        epilog='Please report bugs to <adrian@llnl.gov>.')

    cmdline.add_argument('spec', metavar='<spec.burg>', nargs='?', type=file,
                         help='generator spec file to use as input')

    cmdline.add_argument('-o', '--output', metavar='<output.py>', default='_cg.py',
                         help='file name for the output code generator')

    cmdline.add_argument('--version', action='store_true', 
                         help='print version and exit')

    args = cmdline.parse_args()
    if args.version:  print '2.0';                 exit(0)
    if not args.spec: print 'no input specified!'; exit(1)

    filename = args.spec.name

    # Initialization
    signature = None
    rules = []
    nonterminals = set()
    possible_terminals = []
    arities = dict()
    line_number = 0
    state = 'in_verbatim'
    f = open(args.output, 'w')
    f.write('''\
# THIS FILE WAS AUTOMATICALLY GENERATED BY burg.py
# Specification: %s
# DO NOT EDIT!

debug = False

'''%args.output)


    # Fire up the state machine!
    for line in args.spec.readlines():
        line_number += 1
        if re.match(r'^\s*?(#.*)?$', line): # Comment
            continue

        sig = re.match(r'^%action arguments: \((.*)\)$', line)
        if sig: # Comment
            signature = sig.group(1)
            action_arity = signature.count(',')+1
            continue

        if state == 'in_verbatim':
            if re.match('^%rules:.*$', line): # Rules
                state = 'base'
                continue
            else:
                f.write(line)

        if state == 'in_rule':
            if re.match(r'^\s.*$', line):
                f.write(line)
                have_rule_body = True
            else:
                if not have_rule_body:
                    f.write('    return a0')
                f.write('\n')

                state = 'base'

        if state == 'base':
            if not re.match(r'\s', line[0]):
                # new rule

                # we are using the following grammar:
                # target @lang <-- src @lang? : cost(c)
                #      code
                m = re.match('(.*)<--(.*?):cost\((\d+)\)', re.sub('\s','', line))
                if not m: error('Bad rule syntax\n'+line)

                def chk(match, n, errmsg):
                    return match.group(n) if match.group(n) \
                        else error('Syntax error in '+errmsg)

                # parse the components of the rule declaration
                target      = chk(m, 1, 'target')
                src         = parse_tree(chk(m, 2, 'src'))
                cost        = int(chk(m, 3, 'cost'))

                # add the rule to our internal bookkeeping
                action = 'action_%s_to_%s'%(str(src), target)
                action = re.sub(r'[,.]', '_', re.sub(r"[ '\(\)]",'', action))
                nonterminals.add(target)
                rules.append((target, src, cost, action))

                # store the arity of src
                if isinstance(src, tuple):
                    src_arity = len(src)-1
                    src_functor = src[0]
                    possible_terminals.extend(src)
                else:
                    src_arity = 0
                    src_functor = src
                    possible_terminals.append(src_functor)
                    
                if src_functor in arities and arities[src_functor] <> src_arity:
                    error('inconsistent arity for "%s" (%d versus %d)'
                          %(src, arities[src_functor],src_arity))
                else:
                    arities[src_functor] = src_arity

                # print the rule action
                f.write('# '+line)
                if isinstance(src, tuple): # add an extra argument for each children
                    args = ', '+', '.join(['a%d'%i for i in range(0, src_arity)])
                else: args = ', a0'
                if not signature: 
                    error('no action signature specified so far')
                f.write('def %s(%s%s):\n'%(action, signature, args))
                state = 'in_rule'
                have_rule_body = False

            else: f.write('##ERR?\n')

    f.write('\n')
    f.write('# Terminals and Functors\n')
    for t in set(possible_terminals):
        if t not in nonterminals:
            if t not in arities.keys(): arities[t] = 0
            f.write('%s = %r\n'%(t, t))
    f.write('\n')
    f.write('# Nonterminals\n')
    for nt in nonterminals:
        f.write('%s = %r\n'%(nt, nt))
    f.write('\n')
    f.write('rules = [\n')
    for target, src, cost, action in rules:
        f.write('    (%s, %s, %r, %s),\n' % (target, src, cost, action))
    f.write('  ]\n')
    f.write('nonterminals = %r\n'%nonterminals)
    f.write('\n')
    f.write('# number of children for each node type\n')
    f.write('arities = %r\n'%arities)    
    f.write('\n')
    f.write('# number of additional user-defined  arguments for every action\n')
    f.write('action_arity = %s\n'%action_arity)
    f.write('\n')
    f.write('def no_action(*args): return args[-1]\n')

    # Write the library code
    f.write('''

# Right now the library is hard-coded and always the same. But in the
# future we could customize it by using tailored fixed-size arrays
# instead of sets to speed up the labelling process.


#print 'rules = ', repr(rules)
from parse_tree import *
from utils import *

def is_terminal(symbol):
    # FIXME (performance) replace this hashtable lookup with a flag or a lookup-table
    return symbol not in nonterminals

def labelx(tree):
    return label1(parse_tree(tree.replace('.','_')))

def untup(tup):
    if len(tup) == 1: return tup[0]
    return tup

@accepts(tuple)
def label(node):
    """
    Find a cost-minimal cover of the tree \c tree using the the rules
    defined in the global variable \c rules.

    We assume that \c args is a tuple containing of 
    \c (node, child_name1, child_name2, other_data, ....)
    where node is a tuple containting of 
    (functor, child1, child2, ...)
    """

    arity = arities[node[0]]
    if arity > len(node): raise Exception('node <%r> has not enough children'%node)
    if arity < 0:         raise Exception()
    elif arity == 0:
        child_labels = []
        # FIXME (performance) replace this with a hardcoded array
        my_labels = { node[0]: ((untup(node[1:]), '<terminal>', 0, no_action), 0) }
        # print 'terminal', node
    else: # arity > 0
        if isinstance(node, str): import pdb; pdb.set_trace()
        functor = node[0]
        # print 'FN', functor
        child_labels = map(label, list(node[1:]))
        # FIXME (performance) replace this with a hardcoded array
        my_labels = dict()

    def current_cost(target):
        for (t, src, _, action), cost in my_labels.values():
            if target == t:
                #print "current_cost(%s) = %s"%(target,cost);
                return cost
        return 2**16

    #if node in nonterminals:
    #   print '**WARNING: node %r is a non-terminal symbol'%node
    #   # exit(1)

    if debug:
        print 'label(%s):'%str(node)
        print "my_labels: ", my_labels

    visited = set()
    fixpoint = False
    while not fixpoint:
        fixpoint = True
        for r in rules:
            # find all rules that take a src that this node can offer,
            # either through its parameters or via the target of
            # another rule already selected for this node

            target, src, cost, action = r

            #print 'src =', src, '?'
     
            # is the arity compatible?
            if arity and not (isinstance(src, tuple)
                              and len(src)-1 == arity # have the same arity
                              and (src[0] == node[0]  # compound
                                or src == node)):     # aggregate
                # sadly there's an ambiguity between compound types
                # and n-ary nonterminals
                continue # not compatible

            #if node[0] == cons: import pdb; pdb.set_trace()


            #if len(node[1])>1 and node[1][0] == 'enum': import pdb; pdb.set_trace()

            if arity == 0:
                # can we reach the rule's src sink from our node?
                try:    _, basecost = my_labels[src]
                except KeyError: continue # rule does not match

            else:
                # can we reach the rule's argument src sinks from our node?
                fail = False
                for i in range(arity):
                    #print 'childlables[%d]='%i,child_labels[i]
                    #print src[i+1]
                    try:    _, basecost = child_labels[i][0][src[i+1]]
                    except KeyError: fail = True; break # rule does not match
                #if fail: print 'FAIL', node[0], target, src
                if fail: continue

            # decide whether it pays off to add this rule
            if cost < current_cost(target) and target not in visited:
            #if src not in visited:
                visited.add(src)
                my_labels[target] = (r, cost)
                #print '    my_labels[',target,'] = ',(r, cost)
                fixpoint = False

    if debug:
        for r, cost in my_labels.values():
            print '   ', r, ':', cost
    if len(my_labels) == 0:
        print '**ERROR: no labeling found for <%s>'%repr(node)
        if debug: raise Exception() 
        else:     exit(1)

    return [my_labels]+child_labels

def reducetree(labels, target, debug_src, *user_args):
    """
    Reduce a tree of labels (as generated by \c label() ) to \c target
    and execute all the code generation action associated with the
    labels as side effects.
    """

    def error():
        print "**ERROR: no cover found for:"
        print "  %s --> %s"%(debug_src,target)
        if my_labels.keys():
            print "**Hint: If the tree above is well-formed, "+ \
                  "try adding a rule for <<%s <-- %s>> !"% \
                  (target, my_labels.keys()[0])
        print
        if debug: raise Exception() 
        else:     exit(1)

    arity = len(labels)
    my_labels = labels[0]

    #print "#%d  %s --> %s"%(arity,debug_src,target)

    if not target in my_labels.keys(): 
        error()

    r, cost = my_labels[target]
    # del my_labels[target]

    user_data, target1, _, action = r

    #print '>>',my_labels[target]

    if arity > 1:
      # for each children
      args = map(lambda (l,tgt): reducetree(l, tgt, user_data, *user_args), 
                 zip(labels[1:], target1[1:]))

    else:
      # for this node (chain rules)
      if target1 == '<terminal>':
          args = [user_data]
      else:
          args = [reducetree(my_labels if isinstance(my_labels, list) else [my_labels], 
                            target1, debug_src, *user_args)]

    #print '!', action.__name__, args
    if debug:
        print r, cost
        try:
            return action(*tuple(list(user_args)+args))
        except:
            import pdb, sys
            print "Exception caught in action:", sys.exc_info()[0]
            print sys.exc_info()
            pdb.post_mortem()
    else:
        return action(*tuple(list(user_args)+args))


def codegen(src, target, *user_args):
    if len(user_args) <> action_arity:
        raise Exception()
    labels = label(src)
    if debug:
        import pprint
        print 'labels = '
        pprint.pprint(labels)
        print 'cost-optimal cover:'
    return reducetree(labels, target, src, *user_args)


if __name__ == '__main__':
    try:
        # the user can define this function for debugging purposes
        test_harness()
    except:
        # Invoke the post-mortem debugger
        import pdb, sys
        print sys.exc_info()
        pdb.post_mortem()

''')

    print 'burg: processed %d rules, %d nonterminals'%(len(rules), len(nonterminals))
