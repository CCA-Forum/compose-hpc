#!/usr/bin/env python
# -*- python -*-
## @package burg
#
# A very simple Bottom-Up Rewriting code Generator. It was inspired by
# the descriptions in
#
# - Engineering a Simple, Efficient Code Generator Generator
#   C. FRASER, D. HANSON and T. PROEBSTING
#   ACM Letters on Programming Languages and Systems
#
# - Optimal Code Selection in DAGs
#   A. ERTL, POPL'99
#
# but is at this point not nearly as sophisticated.
#
# Please report bugs to <components@llnl.gov>.
#
# \authors <pre>
#
# Copyright (c) 2011, 2012 Lawrence Livermore National Security, LLC.
# Produced at the Lawrence Livermore National Laboratory
# Written by Adrian Prantl <adrian@llnl.gov>.
# 
# LLNL-CODE-473891.
# All rights reserved.
#
# This file is part of BRAID. For details, see
# http://compose-hpc.sourceforge.net/.
# Please read the COPYRIGHT file for Our Notice and
# for the BSD License.
#
# </pre>
#
import argparse, re
from parse_tree import parse_tree

def error(msg):
    global filename
    print '%s:%d: error: %s'%(filename, line_number, msg)
    exit(1)

if __name__ == '__main__':
    # Command line argument handling
    cmdline = argparse.ArgumentParser(
        description='A code generator generator',
        epilog='Please report bugs to <components@llnl.gov>.')

    cmdline.add_argument('spec', metavar='<spec.burg>', nargs='?', type=file,
                         help='generator spec file to use as input')

    cmdline.add_argument('-o', '--output', metavar='<output.py>', default='_cg.py',
                         help='file name for the output code generator')

    cmdline.add_argument('--dot', metavar='<graph.dot>',
                         help='output a GraphViz dot graph of the grammar')

    cmdline.add_argument('--version', action='store_true', 
                         help='print version and exit')

    cmdline_args = cmdline.parse_args()
    if cmdline_args.version:  print '2.0';                 exit(0)
    if not cmdline_args.spec: print 'no input specified!'; exit(1)

    filename = cmdline_args.spec.name

    # Initialization
    signature = None
    rules = []
    nonterminals = set()
    possible_terminals = []
    arities = dict()
    unique_actions = set()
    line_number = 0
    state = 'in_verbatim'
    f = open(cmdline_args.output, 'w')
    f.write('''\
# THIS FILE WAS AUTOMATICALLY GENERATED BY burg.py
# Specification: %s
# DO NOT EDIT!

debug = False
dot_debug = False
dotf = None

'''%cmdline_args.output)


    # Fire up the state machine!
    for line in cmdline_args.spec.readlines():
        line_number += 1
        if re.match(r'^\s*?(#.*)?$', line): # Comment
            continue

        sig = re.match(r'^%action arguments: \((.*)\)$', line)
        if sig: # Comment
            signature = sig.group(1)
            action_arity = signature.count(',')+1
            continue

        if state == 'in_verbatim':
            if re.match('^%rules:.*$', line): # Rules
                state = 'base'
                continue
            else:
                f.write(line)

        if state == 'in_rule':
            if re.match(r'^\s.*$', line):
                f.write(line)
                have_rule_body = True
            else:
                if not have_rule_body:
                    f.write('    return a0')
                f.write('\n')

                state = 'base'

        if state == 'base':
            if not re.match(r'\s', line[0]):
                # new rule

                # we are using the following grammar:
                # target @lang <-- src @lang? : cost(c)
                #      code
                m = re.match('(.*)<--(.*?):cost\((\d+)\)', re.sub('\s','', line))
                if not m: error('Bad rule syntax\n'+line)

                def chk(match, n, errmsg):
                    return match.group(n) if match.group(n) \
                        else error('Syntax error in '+errmsg)

                # parse the components of the rule declaration
                target      = chk(m, 1, 'target')
                src         = parse_tree(chk(m, 2, 'src'))
                cost        = int(chk(m, 3, 'cost'))

                # add the rule to our internal bookkeeping
                action = 'action_%s_to_%s'%(str(src), target)
                action = re.sub(r'[,.]', '_', re.sub(r"[ '\(\)]",'', action))
                if action in unique_actions: error('rule %s defined twice'%line)
                else: unique_actions.add(action)
                nonterminals.add(target)
                rules.append((target, src, cost, action))

                # store the arity of src
                if isinstance(src, tuple):
                    src_arity = len(src)-1
                    src_functor = src[0]
                    possible_terminals.extend(src)
                else:
                    src_arity = 0
                    src_functor = src
                    possible_terminals.append(src_functor)
                    
                if src_functor in arities and arities[src_functor] <> src_arity:
                    error('inconsistent arity for "%s" (%d versus %d)'
                          %(src, arities[src_functor],src_arity))
                else:
                    arities[src_functor] = src_arity

                # print the rule action
                f.write('# '+line)
                if isinstance(src, tuple): # add an extra argument for each children
                    args = ', '+', '.join(['a%d'%i for i in range(0, src_arity)])
                else: args = ', a0'
                if not signature: 
                    error('no action signature specified so far')
                f.write('def %s(%s%s):\n'%(action, signature, args))
                state = 'in_rule'
                have_rule_body = False

            else: f.write('##ERR?\n')

    f.write('\n')
    f.write('# Terminals and Functors\n')
    for t in set(possible_terminals):
        if t not in nonterminals:
            if t not in arities.keys(): arities[t] = 0
            f.write('%s = %r\n'%(t, t))
    f.write('\n')
    f.write('# Nonterminals\n')
    for nt in nonterminals:
        f.write('%s = %r\n'%(nt, nt))
    f.write('\n')
    f.write('rules = [\n')
    for target, src, cost, action in rules:
        f.write('    (%s, %s, %r, %s),\n' % (target, src, cost, action))
    f.write('  ]\n')
    f.write('nonterminals = %r\n'%nonterminals)
    f.write('\n')
    f.write('# number of children for each node type\n')
    f.write('arities = %r\n'%arities)    
    f.write('\n')
    f.write('# number of additional user-defined  arguments for every action\n')
    f.write('action_arity = %s\n'%action_arity)
    f.write('\n')
    f.write('def no_action(*args): return args[-1]\n')

    # Write the library code
    f.write(r'''

# Right now the library is hard-coded and always the same. But in the
# future we could customize it by using tailored fixed-size arrays
# instead of sets to speed up the labeling process.

#print 'rules = ', repr(rules)
from parse_tree import *
from utils import *

def prettyprint(indent, a):
    if isinstance(a, tuple):
        r = ' '*indent+'%s('%str(a[0])
        for a1 in a[1:]:
            s = prettyprint(indent+4, a1)
            if len(s) > 32: r += '\n'+' '*indent+s
            else: r+=s
            r += ', '
        r += ')'
        return r
    else: return str(a)

def is_terminal(symbol):
    # FIXME (performance) replace this hashtable lookup with a flag or a lookup-table
    return symbol not in nonterminals

def labelx(tree):
    return label1(parse_tree(tree.replace('.','_')))

def untup(tup):
    if len(tup) == 1: return tup[0]
    return tup

@accepts(tuple)
def label(node):
    """
    Find a cost-minimal cover of the tree \c tree using the the rules
    defined in the global variable \c rules.

    We assume that \c args is a tuple containing of 
    \c (node, child_name1, child_name2, other_data, ....)
    where node is a tuple containting of 
    (functor, child1, child2, ...)
    """

    arity = arities[node[0]]
    if arity > len(node): raise Exception('node <%r> has not enough children'%node)
    if arity < 0:         raise Exception()
    elif arity == 0:
        child_labels = []
        # FIXME (performance) replace this with a hardcoded array
        my_labels = { node[0]: ((untup(node[1:]), '<terminal>', 0, no_action), 0) }
        #print 'terminal', node
    else: # arity > 0
        if isinstance(node, str): import pdb; pdb.set_trace()
        functor = node[0]
        # print 'FN', functor
        child_labels = map(label, list(node[1:]))
        # FIXME (performance) replace this with a hardcoded array
        my_labels = dict()

    def current_cost(target):
        try:
            r, cost = my_labels[target]
            #print "current_cost(%s) = %d"%(target,cost);
            return cost

        except KeyError:
            return 2**16
        #for (t, src, _, action), cost in my_labels.values():
        #    if target == t:
        #        #print "current_cost(%s) = %s"%(target,cost);
        #        return cost
        #return 2**16

    #if node in nonterminals:
    #   print '**WARNING: node %r is a non-terminal symbol'%node
    #   # exit(1)

    if debug:
        print 'label(%s):'%str(node)
        print "my_labels: ", my_labels

    fixpoint = False
    while not fixpoint:
        fixpoint = True
        for r in rules:
            # find all rules that take a src that this node can offer,
            # either through its parameters or via the target of
            # another rule already selected for this node

            target, src, cost, action = r

            #print 'src =', src, '?'
     
            # is the rule n-ary and is the arity compatible?
            if isinstance(src, tuple):
                if src == node: import pdb; pdb.set_trace()

                if not (len(src)-1 == arity       # have the same arity
                        and (src[0] == node[0])): # and functor
                    continue # not compatible

                if not child_labels: import pdb; pdb.set_trace()

                # can we reach the rule's argument src sinks from our node?
                basecost = 0
                fail = False
                for i in range(arity):
                    #print 'child_labels[%d]='%i,child_labels[i]
                    #print src[i+1]
                    try:    _, basecost_i = child_labels[i][0][src[i+1]]
                    except KeyError: fail = True; continue # rule does not match
                    basecost = basecost+basecost_i
                if fail: continue

            else:
                # can we reach the rule's src sink from our node?
                try:    _, basecost = my_labels[src]
                except KeyError: continue # rule does not match

            cost = cost + basecost
            # decide whether it pays off to add this rule
            #print cost, '<', current_cost(target), '?'
            if cost < current_cost(target):
                assert(isinstance(src, str) or len(src) == 1+len(child_labels))
                #print '    my_labels[',target,'] = ', r[1]
                my_labels[target] = (r, cost)
                fixpoint = False

                if dot_debug:
                    if isinstance(src, tuple):
                         for s in src[1:]:
                             print >>dotf, s, ' -> ', '_'.join(src), '[style=dashed];'
                         print >>dotf, '_'.join(src), ' -> ', target, '[label="%d"];'%(cost)
                    else: 
                         print >>dotf, src, ' -> ', target, '[label="%d"];'%(cost)

    if debug:
        for r, cost in my_labels.values():
            print '   ', r, ':', cost

    if len(my_labels) == 0:
        print '**ERROR: no labeling found for %d-ary node'%arity
        print prettyprint(10, node)
        if child_labels:
            print '         Hint: this node would expect'
            for target, src, _, _ in rules:
               if node[0] == src[0]:
                  print '          ', repr(src)

            print '         but only the following labelings were found'

            for i in range(arity):
               for src in child_labels[i][0]:
                   print '           arg %d:'%i, src
        exit(1)

    return [my_labels]+child_labels

def reducetree(labels, target, debug_src, *user_args):
    """
    Reduce a tree of labels (as generated by \c label() ) to \c target
    and execute all the code generation action associated with the
    labels as side effects.
    """

    def error():
        print "**ERROR: no cover found for:"
        print "  %s --> %s"%(debug_src,target)
        if my_labels.keys():
            print "**Hint: If the tree above is well-formed, "+ \
                  "try adding a rule for <<%s <-- %s>> !"% \
                  (target, my_labels.keys()[0])
        print
        if debug: raise Exception() 
        else:     exit(1)

    my_labels = labels[0]

    #print "%s(%d) --> %s"%(debug_src,arity,target)

    if not target in my_labels: 
        import pdb; pdb.set_trace()
        error()

    r, cost = my_labels[target]
    # del my_labels[target]

    user_data, target1, _, action = r
    arity = len(target1) if isinstance(target1, tuple) else 1
    #print "%s(%d) --> %s"%(target,arity,target1)
    #print '>>',my_labels[target]
    assert(arity == 1 or arity == len(labels))

    if arity > 1:
      # for each children
      args = map(lambda (l,tgt): reducetree(l, tgt, user_data, *user_args), 
                 zip(labels[1:], target1[1:]))

    else:
      # for this node (chain rules)
      if target1 == '<terminal>':
          args = [user_data]
      else:
          args = [reducetree(my_labels if isinstance(my_labels, list) else [my_labels]+labels[1:], 
                             target1, debug_src, *user_args)]

    #print '!', action.__name__, args
    if debug:
        print r, cost
        try:
            return action(*tuple(list(user_args)+args))
        except:
            import pdb, sys
            print "Exception caught in action:", sys.exc_info()[0]
            print sys.exc_info()
            pdb.post_mortem()
    else:
        return action(*tuple(list(user_args)+args))

def debug_viz(dotf, labels, p=0, c=[0]):
    arity = len(labels)
    n = c[0]+1
    print >>dotf, "%d -> %d;" %(p, n)
    c[0] = n
    if arity > 1:
        map(lambda l: debug_viz(dotf, l, n, c), labels[1:])
    else:
        if isinstance(labels[0], list):
            debug_viz(dotf, labels[0], n, c)
        else:
            print >>dotf, 'node %d [label="%s"];' %(n,','.join(labels[0].iterkeys()))

def codegen(src, target, *user_args):
    if len(user_args) <> action_arity:
        raise Exception()

    if dot_debug:
        dotf = open('/tmp/burg_tmp.dot', 'w')
        print >>dotf, 'digraph "G" {\n'

    labels = label(src)

    #debug_viz(dotf, labels)
    if dot_debug:
        print >>dotf, '}\n'
        dotf.close()
    if debug:
        import pprint
        print 'labels = '
        pprint.pprint(labels)
        print 'cost-optimal cover:'
    return reducetree(labels, target, src, *user_args)


if __name__ == '__main__':
    try:
        # the user can define this function for debugging purposes
        test_harness()
    except:
        # Invoke the post-mortem debugger
        import pdb, sys
        print sys.exc_info()
        pdb.post_mortem()

''')
    f.close()
    
    #
    # dot debug output
    #
    if cmdline_args.dot:
        f = open(cmdline_args.dot, 'w')
        f.write('digraph "%s" {\n'%cmdline_args.spec)
        n = 0
        for r in rules:
            def sanitize(s): return re.sub(r'[,.]', '_', re.sub(r"[ '\(\)]", '', s))
            target, src, cost, action = map(lambda s: sanitize(str(s)), r)

            source = r[1]
            if isinstance(source, tuple):
                n0 = n
                for child in source[1:]:
                    f.write('"%s[%d]" -> "%s[%d]" [weight=3,style=dashed];\n'%(
                            source[0], n0, child, n))
                    n = n+1
                src = "%s[%d]"%(source[0], n)
                f.write('"%s" -> "%s" [style=dashed];\n'%(src,source[0]))

                
            f.write('"%s" -> "%s" [label="%s"];\n'%(src, target, cost))
            f.write('"%s" [shape=box];\n'%src)
            f.write('"%s" [shape=box];\n'%target)

        f.write('}\n')
        f.close()


    print 'burg: processed %d rules, %d nonterminals'%(len(rules), len(nonterminals))
