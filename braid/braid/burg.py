#!/usr/bin/env python
# -*- python -*-
## @package burg
#
# A very simple Bottom-Up Rewriting code Generator. It was inspired by
# the descriptions in
#
# - Engineering a Simple, Efficient Code Generator Generator
#   C. FRASER, D. HANSON and T. PROEBSTING
#   ACM Letters on Programming Languages and Systems
#
# - Optimal Code Selection in DAGs
#   A. ERTL, POPL'99
#
# but is at this point not nearly as sophisticated.
#
# Please report bugs to <adrian@llnl.gov>.
#
# \authors <pre>
#
# Copyright (c) 2011, Lawrence Livermore National Security, LLC.
# Produced at the Lawrence Livermore National Laboratory
# Written by Adrian Prantl <adrian@llnl.gov>.
# 
# LLNL-CODE-473891.
# All rights reserved.
#
# This file is part of BRAID. For details, see
# http://compose-hpc.sourceforge.net/.
# Please read the COPYRIGHT file for Our Notice and
# for the BSD License.
#
# </pre>
#
import argparse, re
from parse_tree import *

def error(msg):
    print '**ERROR', msg
    print 'in line', line_number
    exit(1)

if __name__ == '__main__':
    # Command line argument handling
    cmdline = argparse.ArgumentParser(
        description='A code generator generator',
        epilog='Please report bugs to <adrian@llnl.gov>.')

    cmdline.add_argument('spec', metavar='<spec.burg>', nargs='?', type=file,
                         help='generator spec file to use as input')

    cmdline.add_argument('-o', '--output', metavar='<output.py>', default='_cg.py',
                         help='file name for the output code generator')

    cmdline.add_argument('--version', action='store_true', 
                         help='print version and exit')

    args = cmdline.parse_args()
    if args.version:  print '1.0';                 exit(0)
    if not args.spec: print 'no input specified!'; exit(1)


    # Initialization
    signature = None
    rules = []
    nonterminals = set()
    line_number = 0
    state = 'in_verbatim'
    f = open(args.output, 'w')
    f.write('''\
# THIS FILE WAS AUTOMATICALLY GENERATED BY burg.py
# Specification: %s
# DO NOT EDIT!

debug = False

'''%args.output)


    # Fire up the state machine!
    for line in args.spec.readlines():
        line_number += 1
        if re.match(r'^\s*?(#.*)?$', line): # Comment
            continue

        sig = re.match(r'^%action arguments: \((.*)\)$', line)
        if sig: # Comment
            signature = sig.group(1)
            action_arity = signature.count(',')+1
            continue

        if state == 'in_verbatim':
            if re.match('^%rules:.*$', line): # Rules
                state = 'base'
                continue
            else:
                f.write(line)

        if state == 'in_rule':
            if re.match(r'^\s.*$', line):
                f.write(line)
                have_rule_body = True
            else:
                if not have_rule_body:
                    f.write('    pass')
                f.write('\n')

                state = 'base'

        if state == 'base':
            if not re.match(r'\s', line[0]):
                # new rule

                # we are using the following grammar:
                # target @lang <-- src @lang? : cost(c)
                #      code
                m = re.match('(.*)@(.+)<--(.*?)(@(.+))?:cost\((\d+)\)',
                             re.sub('\s','', line))
                if not m: error('Bad rule syntax\n'+line)

                def chk(match, n, errmsg):
                    return match.group(n) if match.group(n) \
                        else error('Syntax Error in '+errmsg)

                # parse the components of the rule declaration
                target      = chk(m, 1, 'target')
                target_lang = chk(m, 2, 'target lang')
                src         = parse_tree(chk(m, 3, 'src'))
                src_lang    = m.group(5) if m.group(5) else target_lang
                cost        = int(chk(m, 6, 'cost'))

                # add the rule to our internal bookkeeping
                action = 'action_%s_to_%s'%(str(src), target)
                action = re.sub(r'[,.]', '_', re.sub(r"[ '\(\)]",'', action))
                nonterminals.add(target)
                rules.append((target, src, cost, action))

                # print the rule action
                f.write('# '+line)
                if isinstance(src, tuple): # add an extra argument for each children
                    args = ', '+', '.join(['a%d'%i for i in range(0, len(src))])
                else: args = ', a0'
                if not signature: 
                    error('no action signature specified so far')
                f.write('def %s(%s%s):\n'%(action, signature, args))
                state = 'in_rule'
                have_rule_body = False

            else: f.write('##ERR?\n')

    f.write('\n')
    f.write('rules = [\n')
    for target, src, cost, action in rules:
        f.write('    (%s, %s, %r, %s),\n' % (target, src, cost, action))
    f.write('  ]\n')
    f.write('nonterminals = %r\n'%nonterminals)
    f.write('\n')
    f.write('action_arity = %s\n'%action_arity)
    f.write('def no_action(*args): pass\n')

    # Write the library code
    f.write('''

# Right now the library is hard-coded and always the same. But in the
# future we could customize it by using tailored fixed-size arrays
# instead os sets to speed up the labelling process.


#print 'rules = ', repr(rules)
from parse_tree import *
from utils import *

def labelx(tree):
    return label1(parse_tree(tree.replace('.','_')))

@accepts(tuple)
def label(args):
    """
    Find a cost-minimal cover of the tree \c tree using the the rules
    defined in the global variable \c rules.

    We assume that \c args is a tuple containing of 
    \c (node, child_name1, child_name2, other_data, ....)
    where node is a tuple containting of 
    (functor, child1, child2, ...)

    The purpose of data is to pass extra arguments to the actions,
    e.g., the file to print to.
    """

    data = list(args[1:])
    if isinstance(args, str): import pdb; pdb.set_trace()
    node = args[0]
    functor = node[0]
    arity = len(node) if isinstance(node, tuple) else 0
    if arity < 0: import pdb; pdb.set_trace()
    if arity > 0:
        if isinstance(node, str): import pdb; pdb.set_trace()
        child_labels = map(label, zip(node[1:], data))
        # FIXME (performance) replace this with a hardcoded array
        my_labels = dict()
    else: # arity == 0
        child_labels = []
        my_labels = { args[0]: ((args, '<terminal>', 0, no_action), 0) }

    def current_cost(target):
        for (t, src, _, action), cost in my_labels.values():
            if target == t:
                #print "current_cost(%s) = %s"%(target,cost);
                return cost
        return 2**16

    #if node in nonterminals:
    #   print '**WARNING: node %r is a non-terminal symbol'%node
    #   # exit(1)

    if debug:
        print 'label(%s):'%str(node)
        print "my_labels: ", my_labels

    visited = set()
    fixpoint = False
    while not fixpoint:
        fixpoint = True
        for r in rules:
            # find all rules that take a src that this node can offer,
            # either through its parameters or via the target of
            # another rule already selected for this node

            target, src, cost, action = r

            #print 'src =', src

            # is the arity compatible?
            if arity and not (isinstance(src, tuple)
                              and len(src) == arity  # have the same arity
                              and (src[0] == node    # compound
                                or src == node)):    # aggregate
                # sadly there's an ambiguity between compound types
                # and n-ary nonterminals
                continue # not compatible

            if len(node[1])>1 and node[1][0] == 'enum': import pdb; pdb.set_trace()

            # can we reach the rule's src sink from our node?
            if arity == 0:
                try:    _, basecost = my_labels[src]
                except: continue # rule does not match

            # can we reach the rule's argument src sinks from our node?
            for i in range(1, arity):
                try:    _, basecost = child_labels[src[i][0]]
                except: continue # rule does not match

            # decide whether it pays off to add this rule
            if cost < current_cost(target) and target not in visited:
            #if src not in visited:
                visited.add(src)
                my_labels[target] = (r, cost)
                #print '    my_labels[',target,'] = ',(r, cost)
                fixpoint = False

    if debug:
        for r, cost in my_labels.values():
            print '   ', r, ':', cost
    #if len(my_labels) == 0:
    #     print '**ERROR: no labelling found for <%s>'%repr(args)

    return tuple([my_labels]+data)

def reducetree(label, target, *args):
    """
    Reduce a tree of labels (as generated by \c label() ) to \c target
    and execute all the code generation action associated with the
    labels as side effects.
    """
    my_labels = label[0]

    try:
        success = False
        while target in my_labels:
            r, cost = my_labels[target]
            del my_labels[target]
     
            _, target, _, action = r
            if debug:
                print r, cost
            try:
                action(*tuple(list(args)+[label[-1]]))
            except:
                import pdb, sys
                print "Exception caught in action:", sys.exc_info()[0]
                print sys.exc_info()
                pdb.post_mortem()
            success = True

        if not success:
            print "**ERROR: no cover found! <%r>"%target
            #import pdb; pdb.set_trace()

    except TypeError:
        pass # non-hashable

    for i in range(1, len(label)-1): # for each children
        reducetree(label[i], target, *args)

def codegen(src, target, *args):
    if len(args) <> action_arity:
        import pdb; pdb.set_trace()
    labels = label(src)
    if debug:
        print 'labels = ', labels
        print 'cost-optimal cover:'
    return reducetree(labels, target, *args)

if __name__ == '__main__':
    try:
        codegen((chpl.char, 'test'), ior.char, [], set(), '*')
        #reducetree(label(('chpl.Char')), 'ior.str', [], set())
        #print
        #reducetree(label('upcast(ior.object)'), 'ior.baseobject', [], set())
    except:
        # Invoke the post-mortem debugger
        import pdb, sys
        print sys.exc_info()
        pdb.post_mortem()

''')

    print 'burg: processed %d rules, %d nonterminals'%(len(rules), len(nonterminals))
