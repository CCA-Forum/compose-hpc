%% -*- prolog -*-
%%# Pipe this into GRAMOLA
%%# Lines starting with a single '%' will be presereved.
%%# To avoid duplicate doxygen comments, '% %%' will be replaced by '##'
%% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%#!/usr/bin/env python
%# -*- python -*-
%#% @package sidl
%# Grammar for the SIDL intermediate representation (IR).
%# This is NOT a grammar for SIDL, the language.
%#
%# Please report bugs to <adrian@llnl.gov>.
%#
%# \authors <pre>
%#
%# Copyright (c) 2011, Lawrence Livermore National Security, LLC.
%# Produced at the Lawrence Livermore National Laboratory
%# Written by Adrian Prantl <adrian@llnl.gov>.
%#  
%# LLNL-CODE-473891.
%# All rights reserved.
%#  
%# This file is part of BRAID. For details, see 
%# http://compose-hpc.sourceforge.net/. 
%# Please read the COPYRIGHT file for Our Notice and
%# for the BSD License.
%#
%# </pre>
%#
%#
%# <h2>Grammar definition</h2>
%#
%%# Built-in types are ['STR' | 'FLOAT' | 'INT']
%%# Do not forget to add parentheses around ( A|B )!
%%# In alternatives, atoms must come first: atom|complex(something).
%%# Prefix an underscore to suppress singleton warnings.
[  
  _File = file([Require], [Import], [User_type]),
  Version = version('STR' | 'FLOAT' | 'INT'),
  Require = require(Scoped_id, Version),
  Import = import(Scoped_id, Version),
  Package = package(Id, Version, [User_type], Doc_comment),
  User_type = user_type([(Type_attr|Custom_attr)], Cipse),
  Cipse = ( Class
          | Interface
          | Package
          | Struct
          | Enum ),
  Type_attr = type_attribute(final | abstract),
  Id = 'STR',
  Doc_comment = 'STR',
  Enum = enum(Id, [Enumerator], Doc_comment),
  Enumerator = enumerator(Id, int),
  Struct = struct(Scoped_id, [Struct_item]),
  Struct_item = struct_item(Type_void, Id),
  Class = class(Id, [Extends], [Implements], [Invariant], [Method], Doc_comment),
  Interface = interface(Id, [Extends], [Invariant], [Method], Doc_comment),
  Implements = ( implements(Scoped_id)
               | implements_all(Scoped_id)),
  Method = method(Type_void, Method_name, [Method_attr], [Arg],
		  [Except], [From], [Require], [Ensure], Doc_comment),
  Method_name = method_name(Id, Extension),
  Extension = 'STR',
  Type_void = ( void | Type ),
  Method_attr = ( oneway
                | local
                | static
                | abstract
                | final
                | nonblocking
                | copy ),
  From = from(Scoped_id),
  Invariant = invariant(Assertion),
  Assertion = assertion(Id, AssertExpr),
  Except = except([Scoped_id]),
  Ensure = ensure([Scoped_id]),
  Extends = extends([Scoped_id]),
  Arg = ( arg([Arg_attr], Mode, Type_void, Id)
        | rarg([Arg_attr], Mode, Rarray) ),
  Arg_attr = (copy | ['STR']),
  Custom_attr = ( custom_attribute('STR')
                | custom_attribute_assoc('STR', 'STR')
                ),
  Mode = (in | out | inout),
  Type = (Primitive_type | Array | Scoped_id),
  Primitive_type = primitive_type(
      bool|char|int|long|float|double|fcomplex|dcomplex|string|opaque),      
  Array = array(Scalar_type, Dimension, Orientation),
  Scalar_type = (Primitive_type|Scoped_id),
  Dimension = int,
  Orientation = (row_major|column_major),
  Rarray = rarray(Primitive_type, Dimension, Id, Extents),
  Extents = SimpleIntExpression,
  SimpleIntExpression = int, % resolved by the parser?
  AssertExpr = ( infix_expr(Bin_op, AssertExpr, AssertExpr)
               | prefix_expr(Un_op, AssertExpr)
               | fn_eval(Id, [Arg])
               | var_ref(Id)
               | Id
               | Literal
               ),
  Bin_op = (log_or|log_and|eq|ne|bit_or|bit_and|bit_xor|lt|gt|lshift|rshift
          |plus|minus|times|divide|modulo|rem|pow),
  Un_op = ( is|log_not|bit_not ),
  Scoped_id = scoped_id([Id], Extension),
  Literal = ('INT' | 'FLOAT' | 'STR' | pure | result | Complex),
  Complex = complex('FLOAT', 'FLOAT')
].