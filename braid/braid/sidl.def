%% -*- prolog -*-
%%# Pipe this into GRAMOLA
%%# Lines starting with a single '%' will be presereved.
%%# To avoid duplicate doxygen comments, '% %%' will be replaced by '##'
%% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%#!/usr/bin/env python
%# -*- python -*-
%#% @package sidl
%# Grammar for the SIDL intermediate representation (IR).
%# This is NOT a grammar for SIDL, the language.
%#
%# Please report bugs to <adrian@llnl.gov>.
%#
%# \authors <pre>
%#
%# Copyright (c) 2011, Lawrence Livermore National Security, LLC.
%# Produced at the Lawrence Livermore National Laboratory
%# Written by Adrian Prantl <adrian@llnl.gov>.
%#
%# LLNL-CODE-473891.
%# All rights reserved.
%#
%# This file is part of BRAID. For details, see
%# http://compose-hpc.sourceforge.net/.
%# Please read the COPYRIGHT file for Our Notice and
%# for the BSD License.
%#
%# </pre>
%#
%#
%# <h2>Grammar definition</h2>
%#
%%# Built-in types are ['STR' | 'FLOAT' | 'INT']
%%# Do not forget to add parentheses around ( A|B )!
%%# In alternatives, atoms must come first: atom|complex(something).
%%# Prefix an underscore to suppress singleton warnings.
[
  _File = file([Requires], [Import], [User_type]),
  Version = version('STR' | 'FLOAT' | 'INT'),
  Requires = requires(Scoped_id, Version),
  Import = import(Scoped_id, Version),
  Package = package(Id, Version, [User_type], Doc_comment),
  User_type = user_type([(Type_attr|Custom_attr)], Cipse),
  Cipse = ( Class
          | Interface
          | Package
          | Struct
          | Enum ),
  Type_attr = (final | abstract),
  Id = 'STR',
  Doc_comment = 'STR',
  Enum = enum(Id, [Enumerator], Doc_comment),
  Enumerator = ( enumerator(Id) | enumerator_value(Id, 'INT')),
  Struct = struct(Id, [Struct_item], Doc_comment),
  Struct_item = struct_item( (Type_void | Rarray), Id),
  Class = class(Id, [Extends], [Implements], [Invariant], [Method], Doc_comment),
  Interface = interface(Id, [Extends], [Invariant], [Method], Doc_comment),
  Implements = ( implements(Scoped_id)
               | implements_all(Scoped_id)),
  Method = method(Type_void, Method_name, [Method_attr], [Arg],
                  [Except], [From], [Require], [Ensure], Doc_comment),
  Method_name = method_name(Id, Extension),
  Extension = 'STR',
  Type_void = ( void | Type ),
  Method_attr = ( oneway
                | local
                | static
                | abstract
                | final
                | nonblocking
                | copy ),
  From = from(Scoped_id),
  Invariant = invariant(Assertion),
  Assertion = assertion(Id, AssertExpr),
  Except = except(Scoped_id),
  Extends = extends(Scoped_id),
  Ensure = ensure(Assertion),
  Require = require(Assertion),
  Arg = arg([Arg_attr], Mode, (Type_void | Rarray), Id),
  Arg_attr = (copy | ['STR']),
  Custom_attr = ( custom_attribute('STR')
                | custom_attribute_assoc('STR', 'STR')
                ),
  Mode = (in | out | inout),
  Type = (Primitive_type | Array | Scoped_id),
  Primitive_type = primitive_type(
      bool|char|int|long|float|double|fcomplex|dcomplex|string|opaque),
  Array = array(Scalar_type, Dimension, Orientation),
  Scalar_type = (Primitive_type|Scoped_id),
  Dimension = 'INT',
  Orientation = (row_major|column_major),
  Rarray = rarray(Primitive_type, Dimension, Extents),
  Extents = SimpleIntExpression,
  SimpleIntExpression = ('INT' | Id), % FIXME
  AssertExpr = ( infix_expr(Bin_op, AssertExpr, AssertExpr)
               | prefix_expr(Un_op, AssertExpr)
               | fn_eval(Id, [AssertExpr])
               | var_ref(Id)
               | Id
               | Literal
               ),
  Bin_op = (log_or|log_and|eq|ne|bit_or|bit_and|bit_xor|lt|gt|le|ge
	   |lshift|rshift|plus|minus|times|divide|modulo|rem|pow|implies|iff),
  Un_op = ( is|log_not|bit_not ),
  Scoped_id = scoped_id([Module], Id, Extension),
  Module = 'STR',
  Literal = ('INT' | 'FLOAT' | 'STR' | pure | result | Complex),
  Complex = complex('FLOAT', 'FLOAT')
].
% ## token overrides to simplify the parser
%bit_not = '~'
%eq = '=='
%ne = '!='
%bit_or = '|'
%bit_and = '&'
%bit_xor = '^'
%lt = '<'
%gt = '>'
%le = '<='
%ge = '>='
%lshift = '<<'
%rshift = '>>'
%plus = '+'
%minus = '_'
%times = '*'
%divide = '/'
%modulo = '%'
%rem = 'rem'
%pow = '**'
% ## sidl primitive types
%pt_bool = Primitive_type(bool)
%pt_bool     = Primitive_type(bool)
%pt_char     = Primitive_type(char)
%pt_int      = Primitive_type(int)
%pt_long     = Primitive_type(long)
%pt_float    = Primitive_type(float)
%pt_double   = Primitive_type(double)
%pt_fcomplex = Primitive_type(fcomplex)
%pt_dcomplex = Primitive_type(dcomplex)
%pt_string   = Primitive_type(string)
%pt_opaque   = Primitive_type(opaque)
%def visit_hierarchy(base_class, visit_func, symbol_table, visited_nodes):
%    """
%    Visit all parent classes and implemented interfaces of
%    \c base_class exactly once and invoke visit_func on each
%    sidl.class/sidl.interface node.
% 
%    \arg visited_nodes         An optional list of nodes
%                               to exclude from visiting.
%                              Contains the list of visited
%                              nodes after return.
%    """
% 
%    def step(visited_nodes, base):
% 
%       visit_func(base)
%       visited_nodes.append(base)
% 
%       n = symbol_table[base]
%       if n:
%           if n[0] == class_:
%               extends = n[2]
%               for ext in extends:
%                   if ext[1] not in visited_nodes:
%                       step(visited_nodes, ext[1])
%               for _, impl in n[3]:
%                   if impl and impl not in visited_nodes:
%                       step(visited_nodes, impl)
%
%           elif n[0] == interface:
%               for parent_interface in n[2]:
%                   if parent_interface[1] and parent_interface[1] not in visited_nodes:
%                       step(visited_nodes, parent_interface[1])
%                           
%    if base_class and base_class[1] not in visited_nodes:
%       step(visited_nodes, base_class)
%
%def get_parent(symbol_table, class_or_interface):
%    """
%    return the base class/interface of \c class_or_interface
%    """
%    extends = class_or_interface[2]
%    if extends == []:
%        return extends
%    return symbol_table[extends[0][1]]
%
%from sidl_symbols import get_parent_interfaces
%def get_unique_interfaces(symbol_table, cls):
%    """
%    Extract the unique interfaces from this class.  The unique interfaces
%    are those that belong to this class but do not belong to one of its
%    parents (if they exit).  The returned set consists of objects of the
%    type <code>Interface</code>.
%    """
%    unique = set(get_parent_interfaces(symbol_table, cls))
%    parent = get_parent(symbol_table, cls);
%    if parent:
%        unique -= set(get_parent_interfaces(symbol_table, parent))
%    return unique
%
%def type_id(t):
%    """
%    \return the Id of a class, interface, package, etc.
%    """
%    return t[1]
%
%def hashable((scoped_id, modules, name, ext)):
%    """
%    Make a hashable copy of a scoped_id by turning the list of modules into a tuple.
%    """
%    return scoped_id, tuple(modules), name, ext
%
%
%def hashable_type_id(t):
%    """
%    \return the (hashable) scoped Id of a class, interface, package, etc.
%    """
%    tid = t[1]
%    if isinstance(tid, tuple) and tid[0] == scoped_id:
%        return hashable(t[1])
%    return tid
%
%def get_scoped_id(symbol_table, ext):
%    """
%    return the scoped_id of an extendible
%    This wouldn't need to be so complicated if symbol_table[]
%    would return a class with an id instead of a scoped_id.
%    """
%    tid = type_id(ext)
%    if is_class(ext):
%        if is_scoped_id(tid):
%            return tid
%        return Scoped_id(symbol_table.prefix, tid, '')
%    elif is_interface(ext):
%        return tid
%    return ext
%

