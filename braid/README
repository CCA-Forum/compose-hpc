BRAID 0.2.2 README                             <!-- -*- markdown -*- -->
==================

*** Released 26 AUGUST 2011 ***

About
-----

BRAID, the Braid system for Rewriting Abstract Descriptions, is a
compiler-like tool to generate the glue code necessary for language
interoperability. Developed by the
[Components project](https://computation.llnl.gov/casc/components/) at
Lawrence Livermore National Laboratory, BRAID supports the Scientific
Interface Definition Language (SIDL) for the language-independent
declaration of interfaces associated with scientific software
packages.

### Relation to Babel ###

The language bindings generated by BRAID are binary-compatible to
those generated by the related
[Babel](https://computation.llnl.gov/casc/components/) tool. While
Babel handles traditional programming languages (such as C, C++,
Fortran (77-2008), Python, and Java), BRAID adds support for modern
[PGAS](http://en.wikipedia.org/wiki/Partitioned_global_address_space)
languages.

In practice, this means that if you want to, for example, let a Chapel
program use a component implemented in Fortran 95, you would invoke
Babel for the Fortran code and Braid for Chapel code:

    braid --makefile --client=Chapel interface.sidl
    babel --makefile --server=F95    interface.sidl


Supported Languages
-------------------

    Language | Client   Server
    ---------+----------------------
    Chapel   | stable*  experimental
    UPC      | planned  planned
    X10      | planned  planned

*) The following features are not yet implemented: 

Generic arrays, arrays of objects, structs, contracts, hooks and RMI.

Installation
------------

BRAID uses autotools, so the regular 

    ./configure && make install
	
will work just fine. Below is the step-by-step hand-holding version of
the installation process:
	

	tar xjvf braid-0.2.2.tar.bz2 && cd braid-0.2.2
    mkdir build && cd build
    ../configure --prefix=<INSTALL_PATH>
    make [-j<N>] && make install
     
    # other useful commands
    ../configure --help
    make check

### User-visible dependencies
If you just want to compile and install BRAID, you will need:
- Python:		 Version 2.6 or higher
- GNU flex, gcc, ld, Perl, AWK, sed

If you want to run the regression tests, you will also need:
- Babel:		 Version 2.0 or higher
- Chapel:		 Version 1.3.0
- Java:			 JVM 1.6 or higher
- NumPy:		 Version 1.0.4 or higher

### Developer-only dependencies
- Make:			 GNU make version 3.74 or higher
- Autotools:	 Version 2.65 or later
- SWI-Prolog:	 Version 5.10.4 or higher 
				 (only needed if you intend to modify [ir,sidl].def)
- Doxygen:		 Version 1.6 or higher 
				 (disable with ./configure --disable-documentation)



Development status                                
------------------

BRAID is written in 98% Python; the SIDL scanner is implemented in
flex (C). Some of the Python sources are automatically generated from
a high-level specification (sidl.def, ir.def) by a Prolog script. The
implementation language choice is motivated by Python being the
highest-level language that we can assume to be pre-installed on all
our target systems. So far we have three components:

- A complete parser for SIDL which generates an object-oriented
  intermediate representation (IR)

- A converter to an extensible s-expression-based language
  independent IR

- Code generators that convert this IR into Chapel and C code. 
  Other languages supported by Babel will follow.

  To facilitate the writing of these code generators we put some
  effort into extending Python with a pattern-matching mechanism
  for arbitrarily complex tuples. (And the s-expressions from the
  IR are internally represented as Python tuples.)


This diagram shows the work-flow implemented in BRAID:

                 Parser               Conversion
    +-------------+  +------------------+  +---------------------+
    | SIDL        |--| SIDL-based       |--| Language indep. IR  |
    |             |  | declarative IR   |  | (s-expressions)     |
    +-------------+  +------------------+  +---------------------+
                                             |       |
                                             |       | Code
                                             |       | Generators
                                             |       |
                                           +-----------+ +----------+
                                           | Chapel    | | C, ...   |
                                           |           | |          |
                                           +-----------+ +----------+

The idea to use the s-expression-based IR to interface with ROTE
at some later point. Other components (e.g. PAUL) can also
generate this IR to get access to the code generators.
