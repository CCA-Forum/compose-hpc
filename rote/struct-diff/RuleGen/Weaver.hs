{-|
  Code to take two edit trees as generated by the code in the Yang.hs module, 
  and produce a unified tree with them woven together.  Each weave point where 
  the trees are attached either represents a match, mismatch, or a hole (gap) 
  on either side.
-}

--
-- Author: matt@galois.com
--
module RuleGen.Weaver (
	WeaveTree(..),
	WeavePoint(..),
	weave,
	nonMatchForest,
  replaceWeaveTreeNode,
  replaceWeavePoint,
	toRule
) where

import Data.List (intercalate)
import RuleGen.Yang
-- import Debug.Trace
import RuleGen.Data.Trees

-- pass-through to turn off tracing
trace :: String -> a -> a
trace _ x = x

data WeaveTree a = WNode Label a [WeavePoint a]
                 | WLeaf LabeledTree
  deriving Eq

instance (Show (WeaveTree a)) where
  show (WNode lbl _ ps) = "WNode "++(show lbl)++"["++(intercalate "," $ map show ps)++"]"
  show (WLeaf t)        = "WLeaf "++(show t)

-- | A weave point represents a relationship between two subtrees of a larger tree.
--   there are four cases:
--
--     (1) match: the roots of the subtrees match
--
--     2. mismatch: the roots of the subtrees do not match
--
--     3. righthole: the best matching by the Yang algorithm determined that the subtree
--        at the given root exists in the start tree and not in the target tree.
--
--     4. lefthole: similar to righthole, except the root exists in the target tree and
--        not the source.
--  
--   [lefthole ==> insertion of new code; righthole ==> deletion of existing code]
data WeavePoint a = Match (WeaveTree a)
                  | Mismatch (WeaveTree a) (WeaveTree a)
                  | LeftHole (WeaveTree a)
                  | RightHole (WeaveTree a)
  deriving Eq

instance (Show (WeavePoint a)) where
	show (Match m)      = "MATCH: "++(show m)++"\n\n"
	show (Mismatch a b) = "MISMATCH: \n   LEFT="++(pp a)++
	                      "\n\n  RIGHT="++(pp b)++"\n\n"
	show (LeftHole m)   = "LH: "++(show m)++"\n\n"
	show (RightHole m)  = "RH: "++(show m)++"\n\n"

-- given a label, we seek any subtree rooted with that label and replace it with
-- the provided edit or weave tree node (depending on where in the weave tree)
-- the match occurs.  We need to provide an additional argument used to control
-- how mismatch nodes are traversed.  In some cases, we want to perform replacement
-- only on the left-hand children of a mismatch, so we would call this with (True,False).
-- replacement on both sides would require (True,True).  The final parameter is
-- the weavetree being traversed.
replaceWeaveTreeNode :: Label -> WeaveTree a -> LabeledTree -> (Bool, Bool) -> WeaveTree a -> WeaveTree a
replaceWeaveTreeNode lbl replWT replLT flags t =
  case t of
    WLeaf e                  -> WLeaf (replaceSubtrees lbl replLT e)
    WNode s a kids | s == lbl  -> replWT
                   | otherwise -> WNode s a (map (\k -> replaceWeavePoint lbl 
                                                                          replWT 
                                                                          replLT 
                                                                          flags 
                                                                          k) 
                                               kids)

-- same purpose as replaceWeaveTree, but operates on WeavePoints.  The two functions are mutually
-- recursive since WeaveTree Nodes have WeavePoints as children, which in turn have WeaveTree node
-- children.
replaceWeavePoint :: Label -> WeaveTree a -> LabeledTree -> (Bool, Bool) -> WeavePoint a -> WeavePoint a
replaceWeavePoint lbl replWT replLT flags@(lflag,rflag) p =
  let replacer = replaceWeaveTreeNode lbl replWT replLT flags
  in
    case p of
      Match m      -> Match (replacer m)
      Mismatch a b -> 
          let ra = if lflag then replacer a else a
              rb = if rflag then replacer b else b
          in Mismatch ra rb
      LeftHole m   -> LeftHole (replacer m)
      RightHole m  -> RightHole (replacer m)

--
-- pretty printer for weave trees that only works for leaves to turn them into
-- rules.  TODO: make this go away.
pp :: WeaveTree a -> String
pp (WLeaf t) = treeToRule t
pp t         = error $ "Unexpected pp call for WeaveTree :: "++(show t)

{-|
  Given a weave point, produce a pair of strings representing the LHS and RHS of
  the corresponding rewrite rule.
-}
toRule :: WeavePoint a -> Maybe (String,String)
toRule (Mismatch a b) = Just (pp a, pp b)
toRule _              = Nothing

{-|
  Given a weave tree, split it into a forest of subtrees where each
  subtree is rooted at a non-Match node.
-}
nonMatchForest :: WeaveTree a     -- ^ Weave tree to filter into subtrees.
               -> [WeavePoint a]  -- ^ Set of subtrees rooted at non-matching nodes.
nonMatchForest (WLeaf _)        = error "nonMatchForest encountered WLeaf"
nonMatchForest (WNode _ _ kids) = concat $ map handle kids
  where handle (Match t) = nonMatchForest t
        handle x = [x]
	
--	      	
-- given an edit tree, convert ELeaf nodes to WLeaf nodes.  These
-- are used to hang labeled trees off of the tree nodes that represent
-- tree edit operations.  this call makes no sense to make with non-leaf
-- nodes, so it is an error to call them.
--
leafify :: EditTree -> WeaveTree a
leafify (ELeaf t)     = WLeaf t
leafify e@(ENode _ _) = WLeaf $ etreeToLTree e
leafify ENil          = error $ "Erroneous leafify call :: ENil"

{-|
  Given two edit trees as produced by Yang's diff algorithm, try to weave them
  together into a weave tree containing matches, mismatches, and left/right holes.
-}
weave :: EditTree    -- ^ Left edit tree (Input code)
      -> EditTree    -- ^ Right edit tree (Output code)
      -> a           -- ^ Default annotation
      -> WeaveTree a -- ^ The weave tree
weave (ENode albl akids) (ENode _ bkids) def = WNode albl def (zippy akids bkids def)
weave a b                                _   = error $ "Bad weave :: "++(show a)++
                                                   " // "++(show b)

--
-- this function zips together two lists of editop/edittree pairs.
-- the goal is to yield a single list of "weavepoints", which
-- represent ways that the two trees either match or mismatch.  each
-- case is documented in the code below.
--
zippy :: [(EOp,EditTree)] -> [(EOp, EditTree)] -> a -> [WeavePoint a]
--
-- two empty lists, obviously done
--
zippy []              []                _   = []
--
-- empty list and a delete on the LHS means that there exists a
-- node in the LHS that does not exist in the RHS, so we represent
-- this as a RightHole with the subtree that was deleted from the LHS
-- hanging off of the hole.
--
zippy ((Delete,t):xs) []                def = trace "D/nil" $ (RightHole $ leafify t)   :(zippy xs [] def)
--
-- symmetric with previous case : this represents missing nodes on the
-- the LHS, and a correspond left hole.
--
zippy [] ((Delete,t):ys)                def = trace "nil/D" $ (LeftHole $ leafify t)    :(zippy [] ys def)
--
-- if both sides say keep, we have a match.  recurse down into the matching
-- trees
--
zippy ((Keep,xt):xs) ((Keep,yt):ys)     def = (Match (weave xt yt def))     :(zippy xs ys def)
--
-- both sides disagree, so we delete.  this represents a mismatch, which
-- we hang the two mismatching trees off of.
--
zippy ((Delete,xt):xs) ((Delete,yt):ys) def = trace "D/D" $ (Mismatch (leafify xt) (leafify yt)):
                                          (zippy xs ys def)
--
-- deletion on one side, but no delete on the other side (previous case didn't
-- match), so we assume a right hole
--
zippy ((Delete,xt):xs) ys               def = trace "D/ys" $ (RightHole $ leafify xt)  :(zippy xs ys def)
--
-- symmetric with previous case.
--
zippy xs ((Delete,yt):ys)               def = trace "xs/D" $ (LeftHole $ leafify yt)   :(zippy xs ys def)
--
-- by construction of the dynamic programming table in the Yang algorithm,
-- when one tree runs out of nodes, the rest are deleted.  it is impossible
-- to produce a "keep" action in this case, unless there is a bug in the
-- traceback logic in the yang code.  this error is unrecoverable, since it
-- means we have a fatal flaw in the tree matching algorithm.
--
zippy [] ((Keep,_):_)                   _   = error "zippy hit [] ((Keep,_):_) case"
--
-- symmetric pathological case
--
zippy ((Keep,_):_) []                   _   = error "zippy hit ((Keep,_):_) [] case"
